<?xml version="1.0" encoding="ISO-8859-1"?>
<atlanmod.github.org:Repository xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:atlanmod.github.org="http://atlanmod.github.org" name="guava-libraries" description="Guava: Google Core Libraries for Java 1.6+">
  <issues title="Document that Predicates.in uses the contains() method of the collection" body="&#xA;Hi,&#xA;There seems to be a performance bug in the &quot;in&quot; method from the Predicates class.&#xA;&#xA;The problem is that we can generate an In Predicate that has an underlying collection with a slow containment implementation, for example an ArrayList.&#xA;&#xA;The following code exposes the problem:&#xA;&#xA;_________________________________________&#xA;public static void testPredicateIn() {&#xA;&#xA;        ArrayList&lt;Integer> predicateCollection=new ArrayList&lt;Integer>();&#xA;&#xA;        for(int i=0;i&lt;500000;++i)&#xA;            predicateCollection.add(new Integer(i));&#xA;                                                          &#xA;        Predicate&lt;Integer> inPred=Predicates.in(predicateCollection);&#xA;&#xA;        for(int i=0;i&lt;500000;++i) {&#xA;            inPred.apply(new Integer(i));&#xA;        }&#xA;&#xA;    }&#xA;&#xA;__________________________________________-&#xA;Notice that we're creating an in Predicate over an ArrayList of 500000 integers. &#xA;Applying that predicate to the integers between 1 and 500000 takes a few minutes.&#xA;&#xA;I could think of a couple of ways of fixing it:&#xA;&#xA;1) Put a disclaimer in the documentation that the user is advised to pass collections with fast containment methods.&#xA;&#xA;2) Convert slow collections into HashSets, as in the following snippet:&#xA;_______________________________________________________&#xA;    private static &lt;T> Predicate&lt;T> optimizedIn(Collection&lt;? extends T> target) {&#xA;&#xA;        if(target instanceof Set)&#xA;            return Predicates.in(target);&#xA;        else&#xA;            return Predicates.in(new HashSet&lt;T>(target));&#xA;&#xA;    }&#xA;____________________________________________________&#xA;&#xA;&#xA;Here are some experimental results with different sizes for the collection predicate for the original implementation and optimizedIn:&#xA;&#xA;&#xA;      Size      Original     Optimized                                                                                                       &#xA;        10      0m0.972s     0m0.996s                                                                                                        &#xA;       100      0m1.068s     0m1.004s                                                                                                        &#xA;      1000      0m1.572s     0m0.980s                                                                                                        &#xA;     10000      0m8.065s     0m1.016s                                                                                                        &#xA;    100000      1m5.596s     0m1.052s                                                                                                        &#xA;    500000      4m56.423s    0m1.200s               &#xA;&#xA;&#xA;Regards,&#xA; Oswaldo.&#xA;&#xA; relevance: 1" created_at="Oct 20 (3 days ago)" labels="//@labels.19 //@labels.26" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 21 (2 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Actually, I posted the root cause, rather than an actual performance bug in the library code.&#xA;&#xA;Here's a less artificial example, where creating Filtered Collections exposes the performance issue in the slow predicate:&#xA;&#xA;______________________________________________&#xA; public static void testCollections2Filter() {&#xA;&#xA;        ArrayList&lt;Integer> filterCollection=new ArrayList&lt;Integer>();&#xA;        ArrayList&lt;Integer> toAddCollection=new ArrayList&lt;Integer>();&#xA;        for(int i=0;i&lt;500000;++i) {&#xA;            filterCollection.add(new Integer(i));&#xA;            toAddCollection.add(new Integer(i));&#xA;        }&#xA;&#xA;        //      Predicate&lt;Integer> inPred=optimizedIn(filterCollection);                                                                        &#xA;             Predicate&lt;Integer> inPred=Predicates.in(filterCollection);&#xA;&#xA;            Collection&lt;Integer> filteredCollection=Collections2.filter(new ArrayList&lt;Integer>(),inPred);&#xA;&#xA;                filteredCollection.addAll(toAddCollection);&#xA;&#xA;    }&#xA;_______________&#xA;&#xA;Here are the results I'm getting with the original and optimized versions of the &quot;in&quot; predicate:&#xA;&#xA; // Size    Original  Optimized                                                                                                              &#xA;&#xA;       Size  Original  Optimized&#xA;         10  0m1.124s  0m1.096s                                                                                                               &#xA;        100  0m1.112s  0m1.088s                                                                                                               &#xA;       1000  0m1.164s  0m1.152s                                                                                                               &#xA;      10000  0m1.216s  0m1.160s                                                                                                               &#xA;     100000  0m9.421s  0m1.228s                                                                                                               &#xA;     200000  0m50.611s 0m1.252s                                                                                                               &#xA;     500000  > 10 min  0m1.324s    &#xA;&#xA;&#xA;Regards,&#xA; Oswaldo.&#xA;&#xA;" creator="//@users.54"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 21 (2 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;There's a couple points here:&#xA;&#xA;  - The documentation of Predicates.in specifies, &quot;It does not defensively copy the collection passed in, so future changes to it will alter the behavior of the predicate.&quot;  That's a non-@Beta method contract that we would almost certainly not change, and there's not really any way to satisfy that contract and do anything like what you're proposing.&#xA;  - We could document better than the collection's own contains() method is used, and that the performance of the predicate will be equivalent to the performance of the collection's contains() method.&#xA;  - For very short lists, it is not always the case that converting to a HashSet will help performance.&#xA;  - It's possible that it might make sense as a warning or an error in error-prone (http://errorprone.info/) to pass a List to Predicates.in, but we'd have to investigate this -- and that'd be more appropriate as a bug filed against error-prone, rather than Guava.&#xA;&#xA;" creator="//@users.55"/>
  </issues>
  <issues title="Adding a new value to a map if absent however lazily" body="&#xA;Need a putIfAbsent type method which takes a Builder rather than a created object as value along with Key K.&#xA;This in specific tries to create the object iff the key is absent.&#xA;&#xA;Advantage: The value doesn't get un-necessarily created.&#xA;&#xA; relevance: 1" created_at="Oct 20 (3 days ago)" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 20 (3 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Java 8 provides this as a new default method on Map, but I imagine this would be unnecessarily complicated before Java 8, if you had to write the anonymous Supplier instance -- it'd probably take more lines than just writing it the old-fashioned way.&#xA;&#xA;" creator="//@users.5"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 20 (3 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Given that migrating to Java 8 takes significant amount of time ; i was hoping if it were to be implemented in guava&#xA;&#xA;" creator="//@users.31"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 20 (3 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;As I was attempting to say, Guava could only really do this by letting you use an anonymous class, since you can't use lambdas until Java 8, and the anonymous class would be so verbose that your code would be shorter if you wrote it the &quot;normal way.&quot;&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 20 (3 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;OK got it. thanks for clarification&#xA;&#xA;" creator="//@users.31"/>
  </issues>
  <issues title="Order of enqueued events" body="&#xA;The post order of enqueued events is not guaranteed. In practice the order of enqueued events is the same for the majority of the time but not always. In my case, each start of my application could have a different order of posted events. This makes testing and bugfixing a lot harder.&#xA;Changing the subscribersByType from HashMultimap to LinkedHashMultimap in the EventBus class fixed it for me.&#xA;&#xA; relevance: 2" created_at="Oct 10, 2014" creator="//@users.60"/>
  <issues title="Should toStringHelper(Class|Object) use simple name or canonical name (or either)?" body="&#xA;For some nested classes you would really rather toStringHelper chose the canonical name &quot;Foo.Bar&quot; instead of just the simple name &quot;Bar&quot;.&#xA;&#xA;Questions:&#xA;&#xA;1. Which is the best default behavior?&#xA;&#xA;2. If that is the canonical name, would it be evil to change it now? It is perhaps debatable whether the current behavior really is strongly promised by spec. Some overenthusiastic unit tests would have to be changed, but how bad is that?&#xA;&#xA;3. Does this choice actually merit a new configuration option to ToStringHelper? Note that without it, users who want the opposite behavior will need to change typical (85%) usage code like so:&#xA;&#xA; toStringHelper(this) --> toStringHelper(getClass().getCanonicalName())&#xA;&#xA;... which is not pleasant. However, we don't want ToStringHelper to become too complex.&#xA;&#xA; relevance: 2" created_at="Oct 10, 2014" labels="//@labels.25 //@labels.26" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 14, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Possibly we should apply our decision here equally to AutoValue. (AutoValue currently appears to use &quot;Bar.&quot;)&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="Preventing thread starvation in blocking operations" body="&#xA;I've sub-classed ListenableFuture to wrap helper functions from the Futures class to make the futures slightly more composable, however, the issue I'm now facing is preventing potential thread starvation in a fixed worker thread pool (Executors.GLOBAL) in the example below due to someone accidentally blocking in a Function or AsyncFunction (thus potentially blocking all threads in this pool). &#xA;&#xA;Scala's Await.result uses &quot;managed blocking&quot;. i.e., detect the blocking operation and temporarily spawn a new thread (see http://stackoverflow.com/a/13099594). Is there anything equivalent in Guava/Java? &#xA;&#xA;Is this the reason Futures.transform has the option to use the current thread? &#xA;&#xA;    &#xA;public &lt;ReturnType> MFuture&lt;ReturnType> flatMap(AsyncFunction&lt;InputType, ReturnType> fn){&#xA;        return new MFuture&lt;ReturnType>(Futures.transform(listenableFuture, fn, Executors.GLOBAL));&#xA;    }&#xA;&#xA;    public &lt;ReturnType> MFuture&lt;ReturnType> map(Function&lt;InputType, ReturnType> fn){&#xA;        return new MFuture&lt;ReturnType>(Futures.transform(listenableFuture, fn, Executors.GLOBAL));&#xA;    }&#xA;&#xA;&#xA; relevance: 2" created_at="Oct 10, 2014" labels="//@labels.14 //@labels.11" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 10, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I've solved this issue by changing from a FixedThreadPool to a CachedThreadPool, which is probably ok for my scenario, but looking for suggestions. &#xA;&#xA;" creator="//@users.50"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 10, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The Java support for managed blocking that I'm aware of is in the JDK's ForkJoinPool. I don't believe we have anything related in Guava.&#xA;&#xA;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html&#xA;&#xA;As for applying that to your situation, I'm a bit over my head. You might try StackOverflow.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 10, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Thanks, that's exactly what I was looking for. &#xA;&#xA;" creator="//@users.50"/>
  </issues>
  <issues title="Clarify the meaning of &quot;success&quot; of a Future" body="&#xA;From an internal discussion:&#xA;&#xA;---&#xA;&#xA;Huh. I had assumed that &quot;success&quot; was the usual name for this, but I can't find it anywhere in the Future docs. The closest term used there is &quot;completed normally,&quot; used in contrast to &quot;an exception&quot; and &quot;cancellation&quot;: http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone-- But other parts of the doc seem to consider there to be only two cases, &quot;completed normally&quot; and &quot;cancelled,&quot; suggesting that &quot;an exception&quot; is a kind of &quot;completed normally.&quot;&#xA;&#xA;---&#xA;&#xA;The word &quot;success&quot; is used throughout http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html&#xA;&#xA;---&#xA;&#xA;It would be super-confusing for &quot;success&quot; to mean anything other than &quot;completed without throwing&quot;, so the meaning of &quot;success&quot; is relatively obvous.  But it would be better if docs like in FutureCallback replaced &#xA;&#xA;   * Invoked with the result of the {@code Future} computation when it is&#xA;   * successful.&#xA;&#xA;with&#xA;&#xA;   * Invoked with the result of the {@code Future} computation when it completes&#xA;   * normally.&#xA;&#xA;or even more pedantically&#xA;&#xA;   * Invoked with the result of the {@code Future} computation if and when it completes normally (that is, without throwing an exception).&#xA;&#xA;---&#xA;&#xA;I'm still conflicted about this, given that &quot;completed normally&quot; is slightly ambiguous. Perhaps we could define &quot;success&quot; in our package-info and link to that? But mostly I'm just having trouble prioritizing this above other issues.&#xA;&#xA; relevance: 1" created_at="Oct 17 (6 days ago)" labels="//@labels.19 //@labels.11" creator="//@users.60"/>
  <issues title="DenseImmutableTable$Row is not GWT Serializable" body="&#xA;Error from our log:&#xA;com.google.gwt.user.client.rpc.SerializationException: could not get type signature for class com.google.common.collect.DenseImmutableTable$Row&#xA;&#xA;There is no CustomFieldSerializer for the subclasses of ImmutableArrayMap which is an inner class of DenseImmutableTable&#xA;&#xA; relevance: 1" created_at="Jul 30, 2014" labels="//@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 1, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Thanks. I'm hoping that GWT will make some changes to make this easier. I've been hoping that for a while, though. I just filed a GWT feature request to try to get an update:&#xA;&#xA;https://code.google.com/p/google-web-toolkit/issues/detail?id=8844&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="Class name repeated in output of resolveType()" body="&#xA;Test program:&#xA;&#xA;  import com.google.common.reflect.TypeToken;&#xA;&#xA;  public class Outer {&#xA;&#xA;    public abstract static class Inner&lt;T extends Inner&lt;T>> {&#xA;    }&#xA;&#xA;    public void foo(Iterable&lt;? extends Inner&lt;?>> arg) {&#xA;    }&#xA;&#xA;    public static void main(String[] args) throws Exception {&#xA;        System.out.println(&#xA;          TypeToken.of(Outer.class.getMethod(&quot;foo&quot;, Iterable.class)&#xA;          .getGenericParameterTypes()[0]));&#xA;    }&#xA;  }&#xA;&#xA;Expected output:&#xA;&#xA;  java.lang.Iterable&lt;? extends Outer$Inner&lt;?>>&#xA;&#xA;Actual output:&#xA;&#xA;  java.lang.Iterable&lt;? extends Outer.Outer$Inner&lt;?>>&#xA;&#xA;&#xA; relevance: 1" created_at="Jul 30, 2014" labels="//@labels.18 //@labels.17" creator="//@users.40">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Sorry forgot to include: Guava version 1.17.&#xA;&#xA;&#xA;" creator="//@users.28"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Any strong opinion between Outer.Inner vs. Outer$Inner?&#xA;&#xA;The tricky part is when the outer class is parameterized. &#xA;&#xA;innerClass.getName() would print: &quot;O$I&quot;&#xA;&#xA;But one may prefer to see &quot;O&lt;T>.I&lt;S>&quot;.&#xA;&#xA;" creator="//@users.40"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Actually I reduced the test case to something so simple I think it obscured the real bug.&#xA;&#xA;If you add &quot;package pkg&quot; at the top of the test case, then this will be the output:&#xA;&#xA;  java.lang.Iterable&lt;? extends pkg.Outer.pkg.Outer$Inner&lt;?>>&#xA;&#xA;So it's not just a question of preference - &quot;pkg.Outer.pkg.Outer&quot; is clearly wrong.&#xA;&#xA;Back to your question, seems like staying consistent with Class.getName() is good, but that means we lose the outer type parameter, and IMHO the latter is more important... i.e., TypeToken.toString() should reveal as much of its secret type information as possible because people are mainly using it to understand what the type really is.&#xA;&#xA;&#xA;" creator="//@users.28"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 31, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Interestingly, JDK7's built-in ParameterizedType.toString() does the same thing.&#xA;&#xA;Map.Entry&lt;String, String>.toString() => &quot;java.util.Map.java.util.Map$Entry&lt;java.lang.String, java.lang.String>&quot;&#xA;&#xA;Do we want to make our types behave differently from builtin types?&#xA;&#xA;" creator="//@users.40"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 31, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Well. Actually, when you call TypeToken.of(jvmType).toString(), it's really just calling jvmType.toString().&#xA;&#xA;TypeToken isn't doing anything in the middle here.&#xA;&#xA;&#xA;" creator="//@users.40"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 2, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;FWIW I filed a bug on bugs.sun.com (which, in my experience, is just a black hole fronted by a web site).&#xA;&#xA;&#xA;" creator="//@users.28"/>
  </issues>
  <issues title="BloomFilter.create to accept Funnel&lt;? extends T> instead of Funnel&lt;T>" body="&#xA;For now,  BloomFilter.create accepts strictly Funnel&lt;T> which makes it impossible to write type-safe String BloomFilter using builtin funnels:&#xA;&#xA;BloomFilter&lt;String> filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 10000); &#xA;&#xA;does not compile which is somewhat frustrating.&#xA;&#xA;I'd propose to change BloomFilter.create to accept Funnel&lt;? extends T> which should allow such code.&#xA;&#xA; relevance: 1" created_at="Jul 29, 2014" labels="//@labels.24 //@labels.25" creator="//@users.61">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Yep, this looks like an oversight on our part. Should be fixed shortly.&#xA;&#xA;" creator="//@users.61"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I dont quite ubderstand why you couldn't just go with Funnel&lt;CharSequence>?&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Also you mean Funnel&lt;? super T>, right?&#xA;&#xA;" creator="//@users.61"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;2kak@google.com: sure, my bad.&#xA;&#xA;" creator="//@users.20"/>
  </issues>
  <issues title="feature request: intersect method for RangeSet" body="&#xA;[Via email, kevinb encouraged me to submit this request.]&#xA;&#xA;RangeSet is great, and provides me with lots of useful capabilities. There is one fundamental, useful operation that's unexpectedly missing: intersect. There's a subRangeSet method, but it only operates on a single Range, not another RangeSet.&#xA;&#xA;Since there is a union method (aka addAll), and a complement method, I should be able to cobble together an intersect method thus:&#xA;  &lt;T> RangeSet&lt;T> intersect(RangeSet&lt;T> a, RangeSet&lt;T> b) {&#xA;    RangeSet inverse = TreeRangeSet.create(a.complement);&#xA;    inverse.addAll(b.complement());&#xA;    return inverse.complement();&#xA;  }&#xA;&#xA;Nonetheless, life would be simpler and more worry-free for all users if the API directly supported an intersect method.&#xA;&#xA; relevance: 2" created_at="Aug 1, 2014" labels="//@labels.27 //@labels.23" creator="//@users.55">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 5, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;See also issue 1778, which addresses this use case but unfortunately has received no review or triage in two months.&#xA;&#xA;" creator="//@users.44"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 6, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I feel like if we were to do this, it should be a magic view method, which I think would be feasible, just somewhat tricky?&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The code referred to in issue 1778 has been open sourced under the LPGL version 3 or later license.&#xA;&#xA;https://github.com/nmdp-bioinformatics/ngs/tree/master/range/src/main/java/org/nmdp/ngs/range/tree&#xA;&#xA;" creator="//@users.44"/>
  </issues>
  <issues title="Method for using a Invokable as a function?" body="&#xA;Could there be a method on Invokable or static factory in Functions to convert Invokable to a Function assuming arg-less invocation?&#xA;&#xA; relevance: 1" created_at="Jul 31, 2014" creator="//@users.60"/>
  <issues title="Booleans is marked as @GwtCompatible but imports java.util.BitSet which is not emulated by GWT" body="&#xA;The summary pretty much sums it up. &#xA;&#xA;Actually Booleans does only use BitSet in JavaDoc @link references and not in code, however the import is enough for GWT to fail during compilation. Using full qualified @link references should probably fix the problem.&#xA;&#xA;[java]    [ERROR] Errors in 'jar:file:/..../guava-gwt.jar!/com/google/common/primitives/Booleans.java'&#xA;[java]    [ERROR] Line 29: The import java.util.BitSet cannot be resolved&#xA;[java]    [ERROR] Aborting compile due to errors in some input files&#xA;&#xA; relevance: 5" created_at="Aug 1, 2014" labels="//@labels.12 //@labels.18 //@labels.16" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 1, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.61"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 1, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Huh. Apparently our tests don't care. What version of GWT is this, and what compilation flags do you pass?&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 1, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;It was not me who had the problem, I just reported it. After a bit more talk with the guy who has the problem it seems he uses a custom GWT build so I would blame that build.&#xA;&#xA;Actually I just tried it myself with official GWT 2.5.0 and 2.6.1 and I can't produce the error.&#xA;&#xA;I think you can close this issue.&#xA;&#xA;" creator="//@users.2"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 1, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;OK, thanks. Do let us know if you find otherwise.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 20, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;We have same problem here. We are using:&#xA;&#xA;- Windows 8 &#xA;- Java 7 (src/target version 1.6)&#xA;- GXT 2.5.1&#xA;- GWT 2.5.1&#xA;&#xA;Apparently this seems not to make a problem with Windows 7 (like my local machine).&#xA;&#xA;" creator="//@users.57"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 20, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;What flags do you compile with?&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 20, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Currently not at office. But I think there are no special settings activated for the GWT build with Maven. Just Java 1.6 for source and target. As said: Does not work on a Window 8 machine. Works fine on Windows 7 or Debian Linux (build server).&#xA;&#xA;" creator="//@users.57"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 5, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;We might as well fix this, though it's hard to promise that it won't creep back in, since we can't reproduce the problem.&#xA;&#xA;In the long term, the problem might solve itself:&#xA;https://code.google.com/p/google-web-toolkit/issues/detail?id=3279&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I started experiencing this same problem when I switched to jdk8 with GWT 2.5.0 / Guava 15.0.&#xA;&#xA;I took the OPs suggestion of using fully qualified @link references but that didn't seem to help.&#xA;&#xA;" creator="//@users.18"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;My temporary workaround is to copy the source code into sources folder und remove that import. GWT compilation succeeds in my case. But why isn't it just possible to remove that import. In my opinion importing a class that is not really use is a code smell. Or?!&#xA;&#xA;" creator="//@users.57"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I also have Java 8 installed and I am using GWT 2.5.1&#xA;&#xA;" creator="//@users.57"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 17 (6 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I was wrong earlier when I stated that the OPs suggestion did not work.  When I was testing it I changed the references to be fully-qualified but I forgot to remove the import.  With both fully-qualified javadoc references and the removal of the import, our GWT compile is now succeeding.&#xA;&#xA;&#xA;" creator="//@users.18"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 17 (6 days ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I've submitted the fix internally. It will be mirrored out shortly. I didn't find an easy way to test for the problem (short of hardcoding a check for &quot;import java.util.BitSet&quot; for Booleans.java specifically), so I'll hope that we don't reintroduce it in the future. Please let us know if we do.&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="Guava testlib doesn't test support of equal, but not identical (==) map/set keys at all" body="&#xA;Which is a very important case.&#xA;&#xA; relevance: 2" created_at="Sep 30, 2014" labels="//@labels.22 //@labels.27" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Oh, in the test-suite builders? I had never thought about that. We should do something about it.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The thing is everywhere in the framework we just use the given SimpleElements, same object for each &quot;equivalence class&quot; all the time. We don't try to, say, put a value for one key object, and get the value back querying equal, but not identical key.&#xA;&#xA;" creator="//@users.63"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;*SampleElements&#xA;&#xA;" creator="//@users.63"/>
  </issues>
  <issues title="Converter - FindBugs problem" body="&#xA;FindBugs reports &quot;inherits equals and uses Object.hashCode()&quot; for Converter-subclasses.&#xA;&#xA;http://findbugs.sourceforge.net/bugDescriptions.html#HE_INHERITS_EQUALS_USE_HASHCODE&#xA;&#xA;@ test/Test.java @&#xA;&#xA;package test;&#xA;&#xA;import com.google.common.base.Converter;&#xA;&#xA;import java.io.Serializable;&#xA;&#xA;public final class Test {&#xA;&#xA;  private static final class TestConverter&#xA;      extends Converter&lt;String, String> implements Serializable {&#xA;&#xA;    /*package*/ static final TestConverter INSTANCE = new TestConverter();&#xA;&#xA;    private static final long serialVersionUID = 1;&#xA;&#xA;    @Override&#xA;    public String toString() {&#xA;      return &quot;TestConverter.testConverter()&quot;;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected String doForward(String string) {&#xA;      return string;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected String doBackward(String string) {&#xA;      return string;&#xA;    }&#xA;&#xA;    private Object readResolve() {&#xA;      return INSTANCE;&#xA;    }&#xA;  }&#xA;&#xA;  public static Converter&lt;String, String> testConverter() {&#xA;    return TestConverter.INSTANCE;&#xA;  }&#xA;&#xA;  private Test() {&#xA;  }&#xA;}&#xA;&#xA;@ pom.xml @&#xA;&#xA;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#xA;&#x9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;>&#xA;&#x9;&lt;modelVersion>4.0.0&lt;/modelVersion>&#xA;&#x9;&lt;groupId>test&lt;/groupId>&#xA;&#x9;&lt;artifactId>test&lt;/artifactId>&#xA;&#x9;&lt;version>1.0.0-SNAPSHOT&lt;/version>&#xA;&#x9;&lt;dependencies>&#xA;&#x9;&#x9;&lt;dependency>&#xA;&#x9;&#x9;&#x9;&lt;groupId>com.google.guava&lt;/groupId>&#xA;&#x9;&#x9;&#x9;&lt;artifactId>guava&lt;/artifactId>&#xA;&#x9;&#x9;&#x9;&lt;version>18.0&lt;/version>&#xA;&#x9;&#x9;&lt;/dependency>&#xA;&#x9;&lt;/dependencies>&#xA;&#x9;&lt;build>&#xA;&#x9;&#x9;&lt;plugins>&#xA;&#x9;&#x9;&#x9;&lt;plugin>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;groupId>org.codehaus.mojo&lt;/groupId>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;artifactId>findbugs-maven-plugin&lt;/artifactId>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;version>3.0.0&lt;/version>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;executions>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;execution>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;goals>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;goal>check&lt;/goal>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/goals>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/execution>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;/executions>&#xA;&#x9;&#x9;&#x9;&lt;/plugin>&#xA;&#x9;&#x9;&lt;/plugins>&#xA;&#x9;&lt;/build>&#xA;&lt;/project>&#xA;&#xA;@@&#xA;&#xA;mvn clean install&#xA;&#xA;...&#xA;[INFO] --- findbugs-maven-plugin:3.0.0:check (default) @ test ---&#xA;[INFO] BugInstance size is 1&#xA;[INFO] Error size is 0&#xA;[INFO] Total bugs: 1&#xA;[INFO] test.Test$TestConverter inherits equals and uses Object.hashCode() [&quot;test.Test$TestConverter&quot;] At Test.java:[lines 9-32]&#xA;[INFO] ------------------------------------------------------------------------&#xA;[INFO] BUILD FAILURE&#xA;[INFO] ------------------------------------------------------------------------&#xA;[INFO] Total time: 6.516 s&#xA;[INFO] Finished at: 2014-09-29T00:00:54+01:00&#xA;[INFO] Final Memory: 23M/118M&#xA;[INFO] ------------------------------------------------------------------------&#xA;[ERROR] Failed to execute goal org.codehaus.mojo:findbugs-maven-plugin:3.0.0:check (default) on project test: failed with 1 bugs and 0 errors -> [Help 1]&#xA;...&#xA;&#xA;@@&#xA;&#xA;The &quot;problem&quot; is the override in Converter:&#xA;&#xA;  @Override&#xA;  public boolean equals(@Nullable Object object) {&#xA;    return super.equals(object);&#xA;  }&#xA;&#xA;But there is no corresponding override for hashCode:&#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    return super.hashCode();&#xA;  }&#xA;&#xA;This forces everyone to either ignore the FindBugs warning or include the snippet above in their subclass.&#xA;&#xA;Please add &#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    return super.hashCode();&#xA;  }&#xA;&#xA;to Converter, thanks.&#xA;&#xA; relevance: 2" created_at="Sep 28, 2014" labels="//@labels.19 //@labels.26" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 28, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;To be clear, this is actually a false positive from FindBugs (since there isn't actually a bug here).&#xA;&#xA;Looks like we only override equals so we can add additional documentation. I wonder if we should just move that documentation into the class docs, or drop it all together.&#xA;&#xA;" creator="//@users.61"/>
  </issues>
  <issues title="&quot;Throttle&quot; for slowing down rapidly submitted Runnables" body="&#xA;From the mailing-list:&#xA;&#xA;Especially in GUI-applications I often find myself in the need for a throttle which executes a Runnable only after a certain time has passed and only the last Runnable that has been scheduled.&#xA;&#xA;Example: In SWT, when the user resizes a window or a table-column I store that information.&#xA;SWT has a Listener for the resize-event which fires basically for every pixel that is moved, so one resize fires potentially hundreds of events, saving that every time would be slow and I'm only interested in the last value anyway.&#xA;&#xA;I implemented an Executor [0] that can give me an instance of Throttle [1] with a specified timeout..&#xA;&#xA;When a Runnable is submitted to/via the Throttle it is only executed after the timeout has passed. Within this time, every newly submitted Runnable replaces the one waiting.&#xA;&#xA;[0] https://github.com/fab1an/appkit/blob/master/src/main/java/org/appkit/concurrent/SmartExecutor.java&#xA;[1] https://fab1an.github.io/appkit/javadoc/org/appkit/concurrent/Throttle.html&#xA;&#xA;&#xA;&#xA; relevance: 2" created_at="Sep 24, 2014" creator="//@users.60"/>
  <issues title="Sets.newHashSet Javadoc should suggest use of diamond operator" body="&#xA;Lists.newArrayList and Maps.newHashMap include blurbs like:&#xA;&#xA;   * &lt;p>&lt;b>Note for Java 7 and later:&lt;/b> if {@code elements} is a {@link&#xA;   * Collection}, you don't need this method. Use the {@code ArrayList}&#xA;   * {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking&#xA;   * advantage of the new &lt;a href=&quot;http://goo.gl/iz2Wi&quot;>&quot;diamond&quot; syntax&lt;/a>.&#xA;&#xA;Sets.newHashSet should include a similar note.&#xA;&#xA; relevance: 2" created_at="Sep 19, 2014" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 19, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Indeed, a lot of things still need this, thanks for the kick.&#xA;&#xA;" creator="//@users.45"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 22, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;modernizer-maven-plugin has a more complete list of there:&#xA;&#xA;https://github.com/andrewgaul/modernizer-maven-plugin/blob/master/src/main/resources/modernizer.xml&#xA;&#xA;" creator="//@users.38"/>
  </issues>
  <issues title="Missing use case: transforming Optional to Optional" body="&#xA;I have a use case where I am transforming an `Optional`, transforming it into the value of a member variable. The issue: The member variable can be null so I'd like to convert it to an Optional if it exists.&#xA;&#xA;Proposal:&#xA;&#xA;class Optional&lt;T> ... {&#xA;    ...&#xA;&#xA;    public Optional&lt;F> Optional#transformToOptional(Function&lt;T, F> transformer) {&#xA;        try {&#xA;            return this.transform(transformer);&#xA;        catch (NullPointerException e) {&#xA;            return Optional.&lt;F>.absent()&#xA;        }&#xA;    }&#xA;}&#xA;(which reservations to typos and probably not catching NullPointerException in real implementation, instead checking for null)&#xA;&#xA; relevance: 1" created_at="Jul 9, 2014" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 9, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I've reported similar issue in October 2012 and cannot wait for resolution, see https://code.google.com/p/guava-libraries/issues/detail?id=1171 (the cause of NPE can be arbitrary so I feel weird of globally catching NPE, instead I suggested transforming null result to Optional which eventually showed to be consistent with JDK8).&#xA;&#xA;" creator="//@users.12"/>
  </issues>
  <issues title="Immutable collections do not guard against wrong Collection.toArray() method" body="&#xA;ImmutableList etc. can be changed after construction if a collection is passed to copyOf() that keeps a reference to the array returned by toArray(). If the resulting array is of correct size and has more than one element, it is directly used as the backing array of the immutable collection. I attached a file that shows this. The same happens in other places as well, for example in Ordering.immutableSortedCopy().&#xA;&#xA;Such a collection violates the contract of Collection.toArray() which explicitly mentions that the collection may not retain a reference to the array. The only way I could imagine this to happen accidentally might be someone who needs to convert a lot of data back and forth between a List and an array, and implements something like Arrays.asList() but returning the internal array directly in toArray(). Another possibility would be some third-party code that maliciously tries to mangle with internal data structures.&#xA;&#xA;The fix for this would be to do a second copy in these cases, which would probably be a major performance decrease for many users. In our project we do not need this additional protection as we do not have untrusted code, and would certainly prefer the speed of the current solution instead. I guess this is true for a vast majority of users.&#xA;&#xA;A variant of this fix would be to whitelist collections from the java.* and com.google.* packages which are known to be well-behaved in this regard, and do a second copy only for other collections. This would be quite ugly and still costs performance for all users that pass in their own collections.&#xA;&#xA;Thus I suggest to keep the current behavior, and instead document this.&#xA;Currently the wiki states that Guavas immutable collection are &quot;Safe for use by untrusted libraries&quot;, which I would interpret for example such that it is safe to take an immutable collection returned by some untrusted library and use it directly.&#xA;This is not true, regardless of whether the library directly returns an immutable collection, or whether it returns an arbitrary collection and my code calls copyOf().&#xA;Instead, users retrieving collections from untrusted sources and copying them into an immutable collection need to do a second copy themselves with ImmutableList.copyOf(collection.toArray(new T[0])). (Using toArray() would lose the element type, copying into a List would require yet another copy, and using copyOf(copyOf()) of course does not work because the second call does not copy again.)&#xA;&#xA; relevance: 3" created_at="Sep 23, 2014" labels="//@labels.23 //@labels.19" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.61"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;One thing that could be done is&#xA;&#xA;    Object[] array = new Object[elements.size()];&#xA;    checkState(array == elements.toArray(array));&#xA;    return construct(array);&#xA;&#xA;instead of&#xA;&#xA;    return construct(elements.toArray());&#xA;&#xA;I'm not really sure it's worth it just to handle invalid Collection implementations though.&#xA;&#xA;" creator="//@users.24"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Calling toArray(array) will help with unintentional bugs. It's worth consideration, though I wonder if it has performance disadvantages for some collections.&#xA;&#xA;The problem of malicious implementations is one that we've intentionally decided not to tackle. We do need to fix our docs.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I believe the sense in which the wiki page meant things was that it was safe to *pass* ImmutableCollections to untrusted libraries, though there obviously isn't anything we can do about reflection.&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Passing an own array would not help against malicious implementations as they could grab the array anyway. Concerning contracts, it's even worse as I can't see anything like &quot;no references to it are maintained by this collection&quot; in the javadoc of `Collection.toArray(T[])`, though it's somehow obvious.&#xA;&#xA;" creator="//@users.51"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Maaartinus, what do you mean?  The Collection.toArray Javadoc states:&#xA;> The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.&#xA;&#xA;" creator="//@users.5"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I mean the proposal from comment #2 to use *the other* toArray method which gives no such guarantee. Doing something like&#xA;&#xA;&lt;T> T[] toArray(T[] a) {&#xA;    this.gotcha = super.toArray();&#xA;    return this.gotcha;&#xA;}&#xA;&#xA;would violate common sense, but no explicitly stated contract.&#xA;&#xA;" creator="//@users.51"/>
  </issues>
  <issues title="Change size-based eviction to allow for significantly varying segment sizes" body="&#xA;Presently size-based eviction divides maxWeight by the number of segments (concurrency level) and then each segment checks individually on writes for the need to evict entries.  &#xA;&#xA;This leads to under utilization of ram when the size of the data in each segment varies a lot.  One can pick a larger maxWeight, of course, but then if the distribution of the sizes of the segments changes, one is in danger of ram really being overcommitted.  One might also pick a better hash function, but it is not clear that will solve this consistently.&#xA;&#xA;A better solution is to coordinate eviction across the segments so that the total cache more or less stays below the maxWeight, but allows segments to be larger when they are imbalanced.  The additional need is that when one segment is below it's max and yet the cache as a whole is still over weight, one needs to poke at least one other segment to evict. &#xA;&#xA;I have coded a solution to this in https://code.google.com/r/craigwi-guava/.  The tests don't pass and so I'm not sure what to do about them.  It would make sense to change the eviction unit test to account for this change, but that hasn't been done yet.&#xA;&#xA; relevance: 6" created_at="Sep 23, 2014" labels="//@labels.14 //@labels.15" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueEvent" actor="//@users.9" type="mentioned"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Under what sorts of circumstances would the relative size of the segments vary significantly?  I'm having a hard time visualizing when this would happen other than a deliberate hash attack.&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Guava is used in several places in ElasticSearch.  In the case of the fielddata cache, the concurrency level is 16.  Many of us have set the fielddata cache to use size-based eviction only to find that evictions are happening well before the cache is 'full'.  In my case, I specified a 2GB cache and only 650mb was used when evictions started.&#xA;&#xA;You can read more about these cases here: https://groups.google.com/forum/#!msg/elasticsearch/HZj2AR16oss/812kgZb8FhMJ and https://groups.google.com/forum/#!msg/elasticsearch/42qrpYRJvsU/IPArEH8KSYQJ.&#xA;&#xA;" creator="//@users.37"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Ah, I see. So first things first: if each entry was on the order of say ~1 mb or less, this would point to a bad hash function (or hash attack).&#xA;&#xA;It is, however, expected behavior when entries are much coarser than that. You really have 16 independent caches, which is of course where the high concurrency comes from.&#xA;&#xA;So this FR makes sense, but I suspect it's not highly feasible given the way common.cache works now.&#xA;&#xA;" creator="//@users.45"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;In case it wasn't clear, I already wrote the code and worked to ensure the independent (in the concurrency sense) of the segments.  Let me know what you think after reviewing the code.&#xA;&#xA;" creator="//@users.37"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Part of the point of the way LocalCache is currently implemented is that operations on two different segments should not contend for any locks.  From what I can tell, your approach seems to require a global AtomicLong updated on every operation on every segment.&#xA;&#xA;The current approach was a deliberate tradeoff: accepting imprecise weight-based evictions for the sake of keeping segments as independent as possible.  For more typical usages of Cache, this seems likely to be a significant performance loss as lots of small, cheap cache operations are forced to contend on a single AtomicLong.&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The real solution here is to implement the eviction queue globally instead of per-segment. We have an internal issue about this (which needs to be made external), but we know how to do this and even wanted to do it in 2011 but didn't have a compelling case for justifying the change. This seems like a pretty compelling reason to do that right.&#xA;&#xA;" creator="//@users.9"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.9"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Re using AtomicLong, if this is anything more than an interlocked increment or compare exchange at the hardware level, that definitely would be the wrong thing to do.  &#xA;&#xA;As for how often it is called, AtomicLong.addAndGet() is called in two places -- same two places that this.totalWeight is updated.  These calls occur only for writes and removals which already take the per-segment lock and are relative heavy weight.&#xA;&#xA;In particular, AtomicLong.addAndGet() is NOT called in the normal read case.  There is one edge case I covered, but it is likely very rare and may not be worth coding for.&#xA;&#xA;However, I might have missed some other problematic case and would be happy to know what I missed.&#xA;&#xA;As for the &quot;real solution&quot; I agree and of course would be happy with any better solution than the one I have proposed.&#xA;&#xA;" creator="//@users.37"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;> As for how often it is called, AtomicLong.addAndGet() is called in two places -- same two places that this.totalWeight is updated.  These calls occur only for writes and removals which already take the per-segment lock and are relative heavy weight.&#xA;&#xA;My understanding is that taking the segment lock is one thing, but that many threads hammering on a single AtomicLong can be a serious performance issue.  For example, Doug Lea's most recent ConcurrentHashMap implementation avoids AtomicLong for this reason, using some seriously magic alternatives.  We actually have that class in Guava, under the name LongAdder, but I'm not sure we could use that and still preserve the invariant that the cache as a whole never goes over the limit.&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The LongAdder is indeed interesting and inspired me to use a different approach for my requested feature.  &#xA;&#xA;The existing Segment.totalWeight values are like the Cell values in Doug Lea's approach.  I changed my code to avoid the AtomicLong completely at the cost of a sum of the segments totalWeight values.  &#xA;&#xA;I pushed the new approach to https://code.google.com/r/craigwi-guava/.&#xA;&#xA;Let me know what you think.&#xA;&#xA;" creator="//@users.37"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I may be blind, but I can't see there any visibility guarantee for segment.totalWeight in evictEntriesFromLargestSegment.&#xA;&#xA;Concerning the AtomicLong, you could reduce the contention by updating it only when currentSegment.totalWeight has changed significantly since the last update, i.e., let's say by more than 1/8 of the segment capacity. This way you'd maintain an approximation of the total weight within this precision and you could ensure that no eviction takes place before the cache reaches 7/8 (instead of 1/segments.length) of its capacity.&#xA;&#xA;For normally behaving caches, there'd no contention at all as all segments would reach and stay at about their maximum size and never update the AtomicLong.&#xA;&#xA;" creator="//@users.51"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;That's another good idea to reduce the potential cost / contention of using AtomicLong.   &#xA;&#xA;My most recent version avoids AtomicLong altogether -- summing up the total segment weights as needed during eviction.&#xA;&#xA;What are the next steps here?  Do you have perf tests against which we can measure this change?&#xA;&#xA;" creator="//@users.37"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;It was mentioned above and in another forum that perhaps a better hash function would solve this.  The issue stems from the combination of the hash function distribution AND the distribution of the sizes of the elements -- the later of which cannot be encoded in the hash function.  With a &quot;perfect&quot; hash function, each cache segment would have an equal number of (and let's say equal aged) entries.  If the entries vary in size then the cache will still be out of balance (size-wise) and likely never utilize the specified cache fully.  The more the size varies, the more the cache won't utilized RAM fully.&#xA;&#xA;" creator="//@users.37"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 8, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Any update on this?  Would like to get an idea of where this is heading in order to take the appropriate action in ES (see https://github.com/elasticsearch/elasticsearch/issues/7836).&#xA;&#xA;" creator="//@users.11"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 13, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I think my concrete issue with the current version of the change is that it's back to allowing races: totalSegmentView() can have an inconsistent view of the size of the different segments.  You'd encounter this issue with LongAdder, too, I believe.&#xA;&#xA;The current solution manages to *guarantee* that the weight cap is never exceeded even in a multithreaded context, and keeps each operation local to the specific segment it needs to access, without contending with operations on any other segment.  In exchange, it works poorly for a very narrow range of use cases like this, where the size of individual cache entries is a large fraction of the total weight cap, relative to the concurrencyLevel.&#xA;&#xA;To be honest, I can't see any way of maintaining these invariants while accomplishing something like your goal here.  If we come up with a way to maintain these invariants while increasing cache utilization, we can come back to this, but I don't think this is likely to go anywhere in the near term.&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 13, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The current solution, in fact, does NOT guarantee that the weight cap is never exceeded.  On cache miss the following high level steps happen in this order:&#xA;&#xA;1. load new data and store into segment &#xA;    (cf. code called from loadSync())&#xA;2. *then* check to see if segment is *over* full (while (totalWeight > maxSegmentWeight) { &lt;do evict> } )&#xA;    (this is in eviceEntries())&#xA;&#xA;Which means that every segment can be at 100% full and the very next load on any segment will cause the memory usage to exceed the segment weight and thus the whole cache weight.  If this happened all at the same time for many/all segments, each of those segments could go over at the same time and the cache would be over weight by the size of the data just loaded.&#xA;&#xA;I believe that my proposal will result in a cache level over commit amount similar to the current code (not identical, but similar).  &#xA;&#xA;Of course, the problem I'm trying to solve is the under commit amount.  My proposal dramatically improves the behavior on the under commit side.&#xA;&#xA;" creator="//@users.37"/>
  </issues>
  <issues title="Performance tweak for CharSink.write(CharSequence) and related methods" body="&#xA;Hi there. I set-out to replace a little utility with:&#xA;&#xA;  Files.write(CharSequence, File, Charset)&#xA;&#xA;But a quick microbenchmark found Guava's method to be slower on sustained writes of large Strings to individual files. (e.g. +33% longer for 16MB strings.) Results targeting HDD and SSD were similar. Surprisingly, peak memory was heavily impacted too. (I guess Java uses a big in-process write-buffer somewhere.)&#xA;&#xA;Here's a tweak in CharSink which I think will give memory &amp; speed improvements to the Files method above (and maybe others):&#xA;&#xA;   public void write(CharSequence charSequence) throws IOException {&#xA;     checkNotNull(charSequence);&#xA;&#xA;     Closer closer = Closer.create();&#xA;     try {&#xA;-      Writer out = closer.register(openStream());&#xA;+      Writer out = closer.register(charSequence.length() > 8192 ? openBufferedStream() : openStream());&#xA;       out.append(charSequence);&#xA;     //...&#xA;&#xA;In the case of OutputStreamWriter / FileWriter, this change ultimately calls into StreamEncoder.write(char[], int, int) which can use BufferedWriter's char buffer directly; rather than StreamEncoder.write(String, int, int) which makes a copy of the entire string.&#xA;&#xA;The default implementation in Writer also get the same benefit when wrapped by BufferedWriter, so I think this will benefit a range of Writer classes, not just file writers.&#xA;&#xA;I couldn't test the proposed tweak directly, so here's my actual tests which appear to support the theory:&#xA;&#xA;Harness:&#xA;&#xA;    String TEXT = Strings.repeat(&#xA;            &quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;,&#xA;            200_000);&#xA;&#xA;    for (int i = 0; i &lt; 40; i++) {&#xA;        long t0 = System.nanoTime();&#xA;        File out = new File(&quot;T:\\tmp\\i&quot; + i);&#xA;        doWrite(out);&#xA;        System.out.println((System.nanoTime() - t0) / 1_000_000f);&#xA;    }&#xA;&#xA;With these implementations of doWrite:&#xA;&#xA;  Test 1: 44ms per file, 1590 MB peak memory**&#xA;&#xA;        Files.write(TEXT, out, Charset.defaultCharset());&#xA;&#xA;&#xA;  Test 2: 44ms per file, 1590 MB peak memory&#xA;&#xA;        try (Writer w = new FileWriter(out)) {&#xA;            w.append(TEXT);&#xA;            w.flush();&#xA;        }&#xA;&#xA;  Test 3: 32ms per file, 366 MB peak memory&#xA;&#xA;        try (Writer w = new BufferedWriter(new FileWriter(out))) {&#xA;            w.append(TEXT);&#xA;            w.flush();&#xA;        }&#xA;&#xA;Notes: &#xA; * Tested using Java 8 32b running on Win 64b on an i7-860&#xA; * 8192 matches BufferedWriter's buffer, maybe it can be turned further. Or maybe just using BufferedWriters always might be sufficient.&#xA; * A similar tweak may be applicable to ByteSink? (Not tried.)&#xA;&#xA;** memory = &quot;Peak Private Bytes&quot; according to SysInternal's Process Explorer.&#xA;&#xA;&#xA; relevance: 2" created_at="Sep 23, 2014" labels="//@labels.25 //@labels.13" creator="//@users.8">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Interesting... my expectation would be that a Writer implementation, given a single large String, should be able to handle it as efficiently as possible since it has all the cards so to speak. I imagine BufferedWriter to be more useful for collecting many small writes.&#xA;&#xA;But it looks like regardless of how large a chunk you provide the characters to the Writer in, an OutputStreamWriter will only write out 8192 bytes at a time, so copying the large String's char array is basically just a big waste of time. It's actually really surprising to me that StreamEncoder doesn't handle this differently... it could just wrap the String in a CharBuffer and use that with CharsetEncoder without needing to copy the char array at all. Maybe there's some good reason for that I'm not aware of.&#xA;&#xA;Anyway, this does look like a good potential solution.&#xA;&#xA;> A similar tweak may be applicable to ByteSink? (Not tried.)&#xA;&#xA;This seems less likely since byte arrays don't need to go through encoding but can just be passed directly to a native method to be written.&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;> an OutputStreamWriter will only write out 8192 bytes at a time (...)&#xA;&#xA;Huh, so it does. I missed that. &#xA;&#xA;> byte arrays don't need to go through encoding but can just be passed directly to a native method to be written&#xA;&#xA;Indeed. Sorry I should have taken a few minutes to check that.&#xA;&#xA;> It's actually really surprising to me that StreamEncoder doesn't handle this differently (...) Maybe there's some good reason for that I'm not aware of.&#xA;&#xA;I agree. Possibly because StreamEncoder is itself a Writer, and the JDK Writers seem to follow this (undocumented?) pattern:&#xA; 1. call write(char[], int, int) to do the real work&#xA; 2. only call it once&#xA;&#xA;(1) makes some sense when there's lots of overridden and overridable methods in a deep hierarchy. (But maybe it hints of yearning for a better design?)&#xA;&#xA;(2) could be concern about per-call-costs in derived classes? (multiply-wrapped Writers, synchronisation, class CarrierPidgeonIpWriter {handy in the days of NSA snooping} etc.) Or just trying to be more friendly to overridden classes?&#xA;&#xA;Anyway, I'd still rate performance as a higher concern for StreamEncoder than these other things... but no point crying over Java's spilt milk, I guess. It ain't going to help ;-)&#xA;&#xA;&#xA;" creator="//@users.39"/>
  </issues>
  <issues title="Add a checked narrowing operation to TypeToken." body="&#xA;Suppose I have checked at runtime that TypeToken.of(Base.class).isAssignableFrom(type), where &quot;type&quot; is a java Type.&#xA;I now want to do TypeToken.of(type).getSupertype(Base.class).&#xA;However, this will not compile as TypeToken.of(type) returns TypeToken&lt;?>, and getSuperclass wants its argument to be a Class&lt;? super T>, where T is the capture type for &lt;?>.&#xA;&#xA;AFAIK, there is no way to get a TypeToken&lt;? extends Base> from TypeToken.of(type), even if we know at runtime that Base is assignable from &quot;type&quot;.&#xA;&#xA;A possible solution would be to add a checked narrowing operation to TypeToken, such as:&#xA;&#xA;public &lt;U> TypeToken&lt;? extends U> as(TypeToken&lt;U> other) {&#xA;  // check other is assignable from this&#xA;  return (TypeToken&lt;? extends U>) this;&#xA;}&#xA;&#xA;and a similar method that accepts a Class&lt;U> instead of TypeToken&lt;U>.&#xA;This would avoid the need of unchecked conversions by the user.&#xA;&#xA;&#xA; relevance: 3" created_at="Sep 21, 2014" creator="//@users.60"/>
  <issues title="Improved nullability annotations" body="&#xA;There are a number of distinct issues here, and it's not really fair of me to mark them all as duplicates. However, we've got at least 7 bugs filed, and in broad strokes, they come down to 3 basic points:&#xA;&#xA;1. Annotate return types as @Nullable/@NonNull more consistently.&#xA;2. Follow the annotation interpretations used by different versions of Findbugs / by Eclipse / by the Checker Framework.&#xA;3. Take advantage of more annotation and a more sophisticated type system (typically the Checker Framework). (Or, in some cases, introduce extra interfaces to Guava with different annotations on each.)&#xA;&#xA;Kevin is likely to attempt to do some of (1), but we will never get it 100% unless we do (2) or (3), both of which look more difficult than we expect to take on soon.&#xA;&#xA;Again, I apologize for the oversimplification of collapsing these all to one bug. I'm just trying to better capture the way we think of the situation, which is basically &quot;annotation some return types, then give up for a while.&quot;&#xA;&#xA; relevance: 48" created_at="Jul 21, 2014" labels="//@labels.25 //@labels.20" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueEvent" actor="//@users.45" type="mentioned"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 1811  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 1810  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 1677  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 1278  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 1221  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 920  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA; Issue 1279  has been merged into this issue.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;In our main Java application we drew a line in the sand to minimize null values in every class. This involved implementing the Null Object pattern in many cases but mostly being consistent with our annotations. &#xA;&#xA;We started by creating the missing package-level annotations FieldsAreNonnulByDefault and ReturnValuesAreNonnullByDefault and ensuring they are applied to every package along with ParametersAreNonnullByDefault. From there it was easy: apply CheckForNull whenever null is allowed. &#xA;&#xA;The beauty of this approach is that anyone reading the code knows what to expect in the absence of an annotation. If most elements allow null, create your own defaults, but I highly recommend using the same default for fields, parameters, and return values. Mixing defaults across the three will only cause confusion.&#xA;&#xA;I would be happy to help out in this endeavor because I feel it would help lots of developers use this awesome library.&#xA;&#xA;" creator="//@users.10"/>
  </issues>
  <issues title="Document immutability of ranges in the JavaDocs" body="&#xA;I didn't find information on the immutability of `Range` instances in the JavaDocs [1]; only the wiki page [2] explicitly states it.&#xA;&#xA;I suggest documenting the immutability directly in the JavaDocs, and thus in the implementation itself.&#xA;&#xA;[1] http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Range.html&#xA;[2] https://code.google.com/p/guava-libraries/wiki/RangesExplained&#xA;&#xA;&#xA;(Slightly unrelated: The comments disappeared from the wiki, especially helpful ones which I remembered to be on the page on ranges are gone. I'd like to state that I don't welcome that change.)&#xA;&#xA; relevance: 1" created_at="Jul 23, 2014" labels="//@labels.19 //@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Augh! How terrible.&#xA;&#xA;" creator="//@users.45"/>
  </issues>
  <issues title="Support for partially random expiration" body="&#xA;When rolling out an upgrade to a cluster of Guava powered instances there's a risk that local caches will expire within the same time.&#xA;&#xA;Proposal: Add a method to CacheBuilder that allows for randomization of expiration. This will eventually spread expiration evenly over time.&#xA;&#xA;Workaround: Instantiate a Random instance and use it as input to `.expire*` method. Cumbersome.&#xA;&#xA;I'd love to hear your input on this.&#xA;&#xA; relevance: 1" created_at="Jul 24, 2014" labels="//@labels.25 //@labels.15" creator="//@users.60"/>
  <issues title="Allow AsyncEventBus to drain its queue" body="&#xA;As issue #1348 is not really going anywhere right now, I am trying to shut down an AsyncEventBus instance in a controlled manner (ensure that no new events are enqueued, make sure that all events in the queue get dispatched before shut down).&#xA;&#xA;Right now, this is pretty hard and requires dancing around the black box that the event bus is (https://github.com/groupon/jesos/blob/master/src/main/java/com/groupon/mesos/util/ManagedEventBus.java). &#xA;&#xA;It would be great to have a defined way to &quot;shut down&quot; an event bus so that it no longer accepts new events and also a way to ask it whether it is &quot;fully drained&quot; (No events in flight). &#xA;&#xA;As the current event bus code is all package private, the only way to actually implement it is to shim my code into the com.google package which seems to be weird. So consider this another vote to make EventBus and AsyncEventBus easily extendable.&#xA;&#xA; relevance: 2" created_at="Jul 25, 2014" creator="//@users.60"/>
  <issues title="Add Debounce and Throttle to Guava?" body="&#xA;Would it be interesting to have something like Debounce and Throttle functions in Guava?&#xA;&#xA;I really like those 2 and have used them from Underscore.js a couple times.&#xA;&#xA;I Think they are more like a functional thing, but nevertheless they are very useful for handling UI events.&#xA;&#xA;http://underscorejs.org/#throttle&#xA;http://underscorejs.org/#debounce&#xA;&#xA;I could try to send a pull request if you guys thing it would be usefull to Guava to have those.&#xA;&#xA;Cheers&#xA;&#xA; relevance: 1" created_at="Jul 28, 2014" labels="//@labels.25 //@labels.21" creator="//@users.60"/>
  <issues title="ClassSanityTester.testNulls fails on equals" body="&#xA;When I call the following, the test case fails (see full test case in attachment).&#xA;&#xA;  new ClassSanityTester().testNulls(MyObject.class);&#xA;&#xA;I get the following error: No exception thrown for parameter at index 0 from MyObjectTest$MyObject.public boolean MyObjectTest$MyObject.equals(java.lang.Object)[null] for class MyObjectTest$MyObject&#xA;&#xA;Clearly, this indicates that it expects a call to &quot;equals(Object)&quot; to throw a NullPointerException. That method should never throw an exception but rather return true or false. The test seems to skip this assertion and I'm surprised this hasn't been reported earlier. &#xA;&#xA;Please make it so ClassSanityTester#testNulls(Class) doesn't fail when equals is behaving correctly (see the test case where testEquals(MyObject.class succeeds).&#xA;&#xA;On a side note, the text returned should be adapted as it mentions three times MyObjectTest$MyObject. That's 2 too many, and it renders the whole error message nearly not understandable.&#xA;&#xA; relevance: 1" created_at="Jul 29, 2014" labels="//@labels.22 //@labels.18" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Okay, I found one issue on my side: the lack of online javadoc available. I had to check in the code online to find out that it's playing nice only if @Nullable is present.&#xA;&#xA;I checked the front-page of Guava and no, there is no link at all to the testlib javadoc. I played a bit with urls and couldn't find any url for the testlib javadoc.&#xA;&#xA;&#xA;" creator="//@users.49"/>
  </issues>
  <issues title="Make ByteStreams.toByteArray(InputStream, int) public" body="&#xA;I'd like to suggest making the&#xA;&#xA;  ByteStreams.toByteArray(InputStream in, int expectedSize)&#xA;&#xA;method &quot;public&quot; rather than having package visibility. I'm aware that limit() and the single-argument toByteArray() methods could be combined to achieve a similar effect, but that would incur an extra array copy since toByteArray(InputStream in) uses ByteArrayOutputStream's toByteArray() method.&#xA;&#xA; relevance: 1" created_at="Jun 22, 2014" labels="//@labels.27 //@labels.13" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Out of curiosity, what are you interested in using this method for? It's primarily designed around the use case of files, where the actual number of bytes in the stream could differ from what you get when you check the length of the file beforehand (but in most cases won't). It handles the stream having both more and fewer bytes than the expected size gracefully... for other use cases, it's possible that's not the best behavior.&#xA;&#xA;Note that using limit() with toByteArray() does not have the same result: if there are more than the expected number of bytes in the stream when using limit, it will read at most the expected number of bytes, where this method will read all bytes regardless.&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 23, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Dang it, you're right -- I misread the code. However, I could still use it in combination with ByteStreams.limit -- that would get me the behavior I would like, i.e. avoiding the extra copy of ByteStreams.toArray(InputStream). That would probably be too contrived as an API, though.&#xA;&#xA;Thinking a bit more about it, I think I'll probably be better off just using a customized ByteArrayOutputStream (to gain access to its internal buffer) and using ByteStreams.copy().&#xA;&#xA;Feel free to close this.&#xA;&#xA;" creator="//@users.26"/>
  </issues>
  <issues title="InternetDomainName.topPrivateDomain() Fails on Suffix .ET - Ethiopia and .ZM - Zambia" body="&#xA;When calling topPrivateDomain() on a domain that ends with .ET - Ethiopia or .ZM - Zambia   I get an IllegalStateException stating that the domain is &quot;Not under a public suffix&quot;.&#xA;&#xA;.ET - Ethiopia and .ZM - Zambia is on the public suffix list and should return true.&#xA;&#xA; relevance: 1" created_at="Jul 21, 2014" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;example : http://www.ethiotelecom.et&#xA;&#xA;" creator="//@users.62"/>
  </issues>
  <issues title="Immutable supplier of ByteChannels" body="&#xA;I propose to implement something similar to Guava's ByteSource and ByteSink which would provide ReadableByteChannel and WritableByteChannel instances.&#xA;&#xA;These classes should also provide common operations such as copy data from source to sink.&#xA;&#xA;&#xA;&#xA;&#xA; relevance: 2" created_at="Jun 24, 2014" labels="//@labels.27 //@labels.13" creator="//@users.8">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.61"/>
  </issues>
  <issues title="Nullpointerexception if FluentIterable.transformAndConcat()'s function parameter is nullable" body="&#xA;i'm conflicted over the fact that Function.apply is annotated as nullable, yet this causes an exception&#xA;  &#xA; FluentIterable&lt;Object> objects = FluentIterable.from(Arrays.asList(&quot;a&quot;, &quot;b&quot;))&#xA;                .transformAndConcat(new Function&lt;String, Iterable&lt;?>>() {&#xA;                    @Nullable&#xA;                    @Override&#xA;                    public Iterable&lt;?> apply(@Nullable String input) {&#xA;                        return null;&#xA;                    }&#xA;                });&#xA;        try {&#xA;            Iterables.isEmpty(objects);&#xA;        }catch (NullPointerException e){&#xA;            System.err.println(&quot;see?&quot;);&#xA;            e.printStackTrace();&#xA;        }&#xA;    }&#xA;&#xA; relevance: 2" created_at="Sep 4, 2014" labels="//@labels.19 //@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 4, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;The intention of the @Nullable annotations on Function.apply is that implementations of Function may or may not choose to accept or return null, and to make that freedom explicit.  Interpretations of @Nullable vary, however.&#xA;&#xA;The behavior itself looks WAI for FluentIterable.transformAndConcat, though I'm not sure if we should change the documentation to make this more explicit.&#xA;&#xA;" creator="//@users.55"/>
  </issues>
  <issues title="RegularImmutableAsList CustomFieldSerializer depends on RegularImmutableSet but did not include it into Serializationpolicy" body="&#xA;if you have a RemoteService with only 1 method and the signature:&#xA;&#xA;    void testImmutableList(ImmutableList&lt;String> list);&#xA;&#xA;and you call it with&#xA;&#xA;    testImmutableList(ImmutableSet.of(&quot;a&quot;, &quot;b&quot;).asList())&#xA;&#xA;you will get an exception:&#xA;&#xA;    com.google.gwt.user.client.rpc.SerializationException: Type 'com.google.common.collect.RegularImmutableSet' was not included in the set of types which can be deserialized by this SerializationPolicy or its Class object could not be loaded. For security purposes, this type will not be deserialized.&#xA;        at com.google.gwt.user.server.rpc.impl.StandardSerializationPolicy.validateDeserialize(StandardSerializationPolicy.java:158)&#xA;&#xA;this happens because the delegate of RegularImmutableAsList is a RegularImmutableSet which is not included into the serialization policy but is written by the RegularImmutableAsList_CustomFieldSerializer&#xA;&#xA;    writer.writeObject(instance.delegateCollection());&#xA;    writer.writeObject(instance.delegateList());&#xA;&#xA; relevance: 2" created_at="Sep 3, 2014" labels="//@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 3, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;you have to call the RemoteServiceAsync which looks like&#xA;&#xA;    testImmutableList(ImmutableSet.of(&quot;a&quot;, &quot;b&quot;).asList(), new AsyncCallbacl&lt;Void>() { ... });&#xA;&#xA;" creator="//@users.59"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 3, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;That's bad :(&#xA;&#xA;The workaround is to do something like ImmutableList.copyOf(new ArrayList&lt;>(set)), but of course that's not something that we should make you do.&#xA;&#xA;Under the current GWT serialization implementation, this is hard (impossible?) to fix without requiring everyone who serializes ImmutableList to have every possible implementation available on the client side. Some clients don't like the resulting bloat. To avoid that, we'd ideally like for GWT to implement https://code.google.com/p/google-web-toolkit/issues/detail?id=8844&#xA;&#xA;A possible alternative that I've been considering is for us to have a single ImmutableList class that delegates all its implementation to an ImmutableListImpl class. This would allow us to have a single ImmutableList serializer for all ImmutableLists. The downside is indirection and extra memory on the server. It's hard to know how much that would cost. One day I hope to look into this. Until then, we're unlikely to do much here, barring new ideas. Sorry that I don't have something more immediate for you.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 8, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;We have overriden the CustomFieldSerializer with our own implementation and the problem is solved.&#xA;&#xA;" creator="//@users.59"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 8, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Clever! I think we'll do it.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 8, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I'd be happy to take the revised version directly, but we'd need your legal permission:&#xA;&#xA;https://developers.google.com/open-source/cla/individual&#xA;or:&#xA;https://developers.google.com/open-source/cla/corporate&#xA;&#xA;Let me know whether you'd like to do that. Otherwise, I'll figure out what we can do to implement things from scratch.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Oct 1, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Have you found any decision on whether the patch is something you can officially/legally contribute? Thanks.&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="ExceptionInInitializerError" body="&#xA;Hi,&#xA;&#xA;I've got this:&#xA;java.lang.ExceptionInInitializerError&#xA;&#x9;at com.google.common.base.Splitter.&lt;init>(SourceFile:110)&#xA;&#x9;at com.google.common.base.Splitter.on(SourceFile:174)&#xA;&#x9;at com.x.y.BaseApplication.count(SourceFile:900)&#xA;&#x9;at com.x.y.CheckNewApps.doInBackground(SourceFile:106)&#xA;&#x9;at com.x.y.CheckNewApps.doInBackground(SourceFile:1)&#xA;&#x9;at android.os.AsyncTask$2.call(AsyncTask.java:288)&#xA;&#x9;at java.util.concurrent.FutureTask.run(FutureTask.java:237)&#xA;&#x9;at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)&#xA;&#x9;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)&#xA;&#x9;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)&#xA;&#x9;at java.lang.Thread.run(Thread.java:811)&#xA;Caused by: java.lang.UnsupportedOperationException&#xA;&#x9;at com.google.common.base.CharMatcher.a(SourceFile:775)&#xA;&#x9;at com.google.common.base.CharMatcher.&lt;clinit>(SourceFile:212)&#xA;&#x9;... 11 more&#xA;&#xA;&#xA;This is the code:&#xA; public int count(String string, String substring) {&#xA;   int count=0;&#xA;   try{&#xA;&#x9;count = Iterables.size(Splitter.on(substring).split(string)) - 1;&#xA;   } catch (Exception e){&#xA;...&#xA;   }&#xA;&#xA;Yes, count = ... is the line 900?&#xA;&#xA;How can it be? It comes from Galaxy S3 4.4.4&#xA;Thanks&#xA;&#xA; relevance: 1" created_at="Jul 17, 2014" labels="//@labels.26 //@labels.18" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Guava 17.0&#xA;&#xA;" creator="//@users.41"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;String parameters aren't null.&#xA;&#xA;" creator="//@users.41"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;That's pretty strange. The UOE is clearly coming from here:&#xA;&#xA;  public static final CharMatcher JAVA_ISO_CONTROL =&#xA;      inRange('\u0000', '\u001f')&#xA;      .or(inRange('\u007f', '\u009f'))&#xA;      .withToString(&quot;CharMatcher.JAVA_ISO_CONTROL&quot;);&#xA;&#xA;(https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/base/CharMatcher.java?name=v17.0#212)&#xA;&#xA;But withToString is being called on a CharMatcher returned by or(...), and the Or CharMatcher definitely overrides withToString and doesn't throw UOE from it.&#xA;&#xA;Is there another version of Guava on your classpath somehow? Seems unlikely to cause this issue given that the problem here seems to be constrained to just 1 class, but probably worth checking. I also wonder if the obfuscation that appears to have been done could be causing it somehow. This obviously doesn't normally happen, as it would cause CharMatcher and anything that uses it to never work.&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Hi,&#xA;I have on guava lib in the project, but I use proguard.&#xA;&#xA;" creator="//@users.41"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;one guava&#xA;&#xA;" creator="//@users.41"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I have to think this is somehow caused by proguard. I wonder if it's for some reason stripping out the override of withToString from CharMatcher.Or, causing the default implementation of withToString on CharMatcher to be called?&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I'm no an expert, I cannot help you :D&#xA;But if it's a proguard thing why this comes in one device? Is it possibe?&#xA;Why one device? Or it's a rare bug and it was just an accident?&#xA;&#xA;" creator="//@users.41"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 17, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I really have no idea... I don't know much about proguard myself. For Guava 17's original source code, what happened should be impossible. So at the very least I don't think this is a problem with Guava itself. What exactly is causing it, though, I'm not sure.&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 21, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Is it uptodate? Seems to be a bit old&#xA;https://code.google.com/p/guava-libraries/wiki/UsingProGuardWithGuava&#xA;&#xA;" creator="//@users.41"/>
  </issues>
  <issues title="com.google.common.collect.ImmutableCollection.Builder&lt;E> should contain a method to add an Optional&lt;E> if present" body="&#xA;&#xA;&#xA;It would be really useful if com.google.common.collect.ImmutableCollection&lt;E> contained a method of the following.&#xA;&#xA;public com.google.common.collect.ImmutableSet.Builder&lt;E> add(Optional&lt;E> element);&#xA;&#xA;and&#xA;&#xA;public com.google.common.collect.ImmutableSet.Builder&lt;E> add(Optional&lt;E>... element);&#xA;&#xA;which is adds to the builder if element.isPresent() is true.&#xA;&#xA;&#xA;If such a method existed bolier plate code like the following could be avoided&#xA;&#xA;if (element.isPresent()) {&#xA;  builder.add(element.get());&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA; relevance: 2" created_at="Jul 16, 2014" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;You could just do&#xA;&#xA;builder.addAll(element.asSet());&#xA;&#xA;or, with Java 8's Optional, you'll be able to do&#xA;&#xA;element.ifPresent(builder::add);&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;&#xA;builder.addAll(element.asSet());&#xA;&#xA;Feels like smell and I am not sure if there are performance considerations of converting a single Optional value to a Set just to be added to the Builder as well.&#xA;&#xA;&#xA;Second requires use of Java 8 rather than Guava for Optional which has trade offs. Not to mention the requirement of actually using Java 8. &#xA;&#xA;Again this is a nice to have enhancement, but I feel it is so simple and practical, not to mention fits with the paradigm that I am suppressed that something like this does not exist.&#xA;&#xA;&#xA;" creator="//@users.35"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;** surprised &#xA;&#xA;" creator="//@users.35"/>
  </issues>
  <issues title="EventBus.LoggingSubscriberExceptionHandler drops an exception" body="&#xA;The handleException() method on the LoggingSubscriberExceptionHandler is called with exception.getCause(). This is fine - it returns the target exception of the InvocationTargetException.&#xA;However, the handleException() method logs this failure with exception.getCause() which than skips one exception.&#xA;&#xA;A simple workaround is to provide an own SubscriberExceptionHandler.&#xA;&#xA;Guava version 18.&#xA;&#xA; relevance: 2" created_at="Sep 2, 2014" labels="//@labels.18 //@labels.21" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 3, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Good catch. It looks like this is already fixed in some changes to EventBus for Guava 19, but we may need to consider an 18.0.1 release for this.&#xA;&#xA;" creator="//@users.8"/>
  </issues>
  <issues title="Add abstract support superclasses for NavigableSet, NavigableMap" body="&#xA;This issue is a suggestion for some new classes, based on my own experience. Working example code is provided.&#xA;&#xA;Request #1:&#xA;&#xA;  Add support superclasses AbstractNavigableSet and AbstractNavigableMap&#xA;&#xA;Rationale:&#xA;&#xA;Creating NavigableSet and NavigableMap implementations from scratch is really tricky and error-prone, due to the sheer number of methods to implement and their semantic intersection with order reversal, optional lower &amp; upper bounds, subSet(), subMap(), etc.&#xA;&#xA;Fortunately, abstract superclasses can implement most methods in terms of others, and manage the bounds in such a way that leaves the subclass to handle the &quot;essence&quot; of the set/map.&#xA;&#xA;FWIW I've done this already and these classes could be used as an basis to start with. See https://code.google.com/p/jsimpledb/source/browse/#svn%2Ftrunk%2Fsrc%2Fjava%2Forg%2Fjsimpledb%2Futil&#xA;&#xA;Request #2:&#xA;&#xA;  Add a NavigableSet-specific implementation of Sets.intersection()&#xA;&#xA;Rationale:&#xA;&#xA;  Sets.intersection() suffers from the flaw that even if the intersection of two sets is empty, iterating their intersection takes time proportional to the size of first of the two sets given, no matter how small the second set is. Since often you won't know which set is smaller, this means you have a 50% chance of getting it badly wrong. &#xA;&#xA;  For two NavigableSets that use the same Comparator, there is a more efficient algorithm that iterates in O(N) queries, where N is the number of elements in the *smallest* of the two sets - no matter in which order they are presented.&#xA;&#xA;  In common scenarios such as iterating through key/value ranges in large datasets, this can make a huge difference.&#xA;&#xA;I also have an implementation for this intersection iteration algorithm here: https://code.google.com/p/jsimpledb/source/browse/trunk/src/java/org/jsimpledb/util/IntersectionNavigableSet.java&#xA;&#xA;&#xA;&#xA;&#xA;&#xA; relevance: 2" created_at="Jul 16, 2014" labels="//@labels.25 //@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Please file these as separate requests.&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&quot;Add a NavigableSet-specific implementation of Sets.intersection()&quot; filed as  issue #1804 .&#xA;&#xA;&#xA;" creator="//@users.28"/>
  </issues>
  <issues title="FileBackedOutputStream can leak open files on IO error" body="&#xA;In https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/io/FileBackedOutputStream.java#203, if there is a file IO error when transferring to an on-disk buffer we'll leak the temp file (if resetOnFinalize is false) and will leak an open file handle until the finalizer for FileOutputStream happens to run.   &#xA;&#xA; relevance: 1" created_at="Jun 25, 2014" labels="//@labels.18 //@labels.13" creator="//@users.8">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 27, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I think this is a duplicate of #1664 (or at the very least closely related to).&#xA;&#xA;" creator="//@users.32"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.61"/>
  </issues>
  <issues title="Double.POSITIVE_INFINITY seems to poison the com.google.common.util.concurrent.RateLimiter" body="&#xA;Once a RateLimiter is configured with permitsPerSecond == Double.POSITIVE_INFINITY, it can never deliver a non-infinite rate. Tested on Guava 17.0.&#xA;&#xA;Test case:&#xA;&#xA;public static void main(String[] args) {&#xA;        RateLimiter rateLimiter = RateLimiter.create(Double.POSITIVE_INFINITY);&#xA;        final double permitsPerSecond = 1.0;&#xA;        rateLimiter.setRate(permitsPerSecond);&#xA;        final long l = System.currentTimeMillis();&#xA;        final int totalPermits = 60;&#xA;        final int permitsEachTime = 1;&#xA;        for (int i = 0; i &lt; totalPermits; i++) {&#xA;            rateLimiter.acquire(permitsEachTime);&#xA;            System.out.print(i + &quot;,&quot;);&#xA;        }&#xA;        final double seconds = 1.0 * (System.currentTimeMillis() - l) / 1000;&#xA;        System.out.println();&#xA;        System.out.println(seconds);&#xA;        System.out.println((totalPermits / permitsPerSecond));&#xA;    }&#xA;&#xA;The behavior should be that it prints out the numbers about once a second and then prints the two &quot;seconds&quot; metrics roughly in agreement, like &#xA;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,&#xA;59.0&#xA;60.0&#xA;&#xA;When the rate limiter is initialized with a non-infinite value (like 10.0), we see the desired behavior.&#xA;&#xA;What the code above actually produces is:&#xA;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,&#xA;0.002&#xA;60.0&#xA;&#xA;showing that the limiter is still issuing permits at an infinite rate.&#xA;&#xA;&#xA;The culprit seems to be this code:&#xA;in com.google.common.util.concurrent.RateLimiter.Bursty#doSetRate&#xA;    storedPermits = (oldMaxPermits == 0.0)&#xA;          ? 0.0 // initial state&#xA;          : storedPermits * maxPermits / oldMaxPermits;&#xA;once the rate has been set to infinity, we also have an infinite number of stored permits, as well as an infinite number of oldMaxPermits. This division yields NaN, which then goes on to ensure that com.google.common.util.concurrent.RateLimiter#reserveNextTicket will return 0 micros to wait.&#xA;&#xA;It seems you may want to look at the whole rateLimiter with infinity in mind. Infinity is a reasonable value to configure a rate limiter with, so I think you should continue to accept it, but there may be other places where the math requires special handling of Infinity.&#xA;&#xA;Let me know if I can help.&#xA;&#xA;Thanks,&#xA;-John&#xA;&#xA; relevance: 1" created_at="Jun 25, 2014" labels="//@labels.18 //@labels.11" creator="//@users.47">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 25, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Interesting. The test method testInfinity_Bursty() is supposed to check this, but it must miss some case that your test catches. I'll look into it.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 25, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;It looks like the test doesn't catch this because no time elapses between the creation and the changing of the rate. As soon as I tell the fake stopwatch that time has elapsed, things go haywire.&#xA;&#xA;" creator="//@users.47"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jun 25, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;For a fix, I think we can get by with the same test as SmoothWarmingUp.doSetRate has. I don't have 100% confidence in that -- in particular, I can imagine that it's possible for maxPermits or another computed value to overflow to POSITIVE_INFINITY in another way -- but based on the facts that (a) SmoothWarmingUp is set up for this and (b) we had tests for this, I suspect that we'd given at least a passing thought to infinite-rate RateLimiters before.&#xA;&#xA;Thanks for the report. I'll post again when the fix is submitted.&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="Helper for sorting nested nullable properties" body="&#xA;I have been implementing `Ordering`s/Comparators/Comparables of nested properties and everytime I do this I get tired of all the null checks to handle ordering of nullable nested propertys. Currently Guava does not help me here.&#xA;&#xA;Example code I'm tired of:&#xA;&#xA;public int compare(MyProperty left, MyProperty right) {&#xA;  if (left.getSubProperty() == null || right.getSubProperty()) {&#xA;    return 0;&#xA;  }&#xA;  if (left.getSubProperty().getSubSubProperty() == null || right.getSubProperty().getSubSubProperty() == null) {&#xA;    return 0;&#xA;  }&#xA;  return ComparisonChain.start().compare(left.getSubProperty().getSubSubProperty().value(), right.getSubProperty().getSubSubProperty().value()).result();&#xA;}&#xA;&#xA;If I'd like to order by null value it gets even worse:&#xA;&#xA;public int compare(MyProperty left, MyProperty right) {&#xA;  if (left.getSubProperty() == null || right.getSubProperty()) {&#xA;    return ComparisonChain.start().compare(left.getSubProperty(), right.getSubProperty()).result();&#xA;  }&#xA;  if (left.getSubProperty().getSubSubProperty() == null || right.getSubProperty().getSubSubProperty() == null) {&#xA;    return ComparisonChain.start().compare(left.getSubProperty().getSubSubProperty(), right.getSubProperty().getSubSubProperty()).result();&#xA;  }&#xA;  return ComparisonChain.start().compare(left.getSubProperty().getSubSubProperty().value(), right.getSubProperty().getSubSubProperty().value()).result();&#xA;}&#xA;&#xA;Two proposed solutions: https://gist.github.com/JensRantil/3063132784a0945dc6f0&#xA;&#xA;I am leaning towards Example2 and have started using it in my code. I'd love to hear about other solutions.&#xA;&#xA; relevance: 2" created_at="Jul 10, 2014" labels="//@labels.27" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 10, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;FWIW, your first Comparator doesn't satisfy the contract: it's not transitive, since something with a getSubProperty() == null compares as equal to everything, but not everything is equal to everything else.&#xA;&#xA;As far as your approaches go, exceptions of any kind are usually a nasty performance killer, so I'd be concerned about approach 2.  Approach 1 is somewhat interesting, but a bit difficult to follow.&#xA;&#xA;In Java 8, you could do something quite short and neat here:&#xA;&#xA;import static java.util.Comparator.*;&#xA;&#xA;   Comparator&lt;MyProperty> comparator = comparing(MyProperty::getSubProperty,&#xA;     nullsFirst(comparing(SubProperty::getSubSubProperty,&#xA;       nullsFirst(comparing(SubSubProperty::value)))));&#xA;&#xA;" creator="//@users.5"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 12, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Hey,&#xA;&#xA;Thanks for feedback! As for the non-transitiveness it was simply a typo (and cope-pasty error). Apologize for that.&#xA;&#xA;I did not know about exceptions being a performance killer. That's unfortunate, because I really liked that solution!&#xA;&#xA;The idea with example 1 is to have a helper class with the following purposes:&#xA; - to minimize repetition of the values being compared. They are only needed at instantiation and will thus minimize repetition (which is similar goad with other comparison helpers in Guava).&#xA; - easily check if any of the values are null.&#xA; - easily sort based on nulls.&#xA;&#xA;Thinking about this I also realized there's a third solution that does not require any of my helper classes/methods:&#xA;&#xA;ComparisonChain chain = ComparisonChain.start();&#xA;try {&#xA;    chain = chain.compare(left.getSubProperty(), right.getSubProperty());&#xA;    chain = chain.compare(left.getSubProperty().getSubSubProperty(), right.getSubProperty().getSubSubProperty());&#xA;    chain = chain.compare(left.getSubProperty().getSubSubProperty().value(), right.getSubProperty().getSubSubProperty().value());&#xA;catch (NullPointerException e) {&#xA;    return chain.result();&#xA;}&#xA;&#xA;This obviously would use exceptions, too, but [1] hints that exceptions thrown and caught within the same method is performant and effectively handled by a goto[2]. Then there's the debate of catching NullpointerExceptions...&#xA;&#xA;I'd love to hear your opinion and whether there's an Guava-idiomatic way of doing these kind of comparisons.&#xA;&#xA;[1] http://stackoverflow.com/a/299315/260805&#xA;[2] ..although, I haven't benchmarked this myself.&#xA;&#xA;" creator="//@users.15"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Jul 16, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;To reduce duplication, could you extract a method that pulls out the sub-sub value (or null)? Then you could call it on each input and compare the values. Or, at that point, you could use Ordering.onResultOf:&#xA;&#xA;private static Ordering&lt;MyProperty> ORDER = Ordering.natural().nullsFirst().onResultOf(&#xA;    new Function&lt;MyProperty, SubSubProperty>() {&#xA;      @Override public SubSubProperty getSubSubProperty(MyProperty property) {&#xA;        return (property.getSubProperty() == null || property.getSubProperty().getSubSubProperty() == null)&#xA;            ? null&#xA;            : property.getSubProperty().getSubSubProperty().value();&#xA;      }&#xA;    };&#xA;&#xA;There's less duplication, but there's still a bunch of boilerplate. I'd be happy to hear better suggestions, but I'm not sure how much better we'll do without Louis's Java 8 suggestion.&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="Hashing support for bcrypt" body="&#xA;Please support bcrypt in com.google.common.hash.Hashing&#xA;&#xA;http://en.wikipedia.org/wiki/Bcrypt&#xA;&#xA;&quot;A Future-Adaptable Password Scheme&quot; by Niels Provos and David Mazieres (USENIX, 1999)&#xA;http://www.openbsd.org/papers/bcrypt-paper.ps&#xA;&#xA; relevance: 3" created_at="Sep 17, 2014" labels="//@labels.24 //@labels.27" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;No one should be using bcrypt for hash tables, which is what Hashing is for.&#xA;&#xA;" creator="//@users.24"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Hashing is not only (or even primarily) for hash tables: https://code.google.com/p/guava-libraries/wiki/HashingExplained&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Bcrypt is one of the three good password hashing schemes -- md5() or sha256() are outdated and insecure.&#xA;&#xA;https://password-hashing.net&#xA;&#xA;http://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage&#xA;&#xA;http://codahale.com/how-to-safely-store-a-password/&#xA;&#xA;" creator="//@users.30"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 24, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;> sha256() are outdated and insecure.&#xA;&#xA;That's pure nonsense. SHA-256 is still rather modern (SHA-3 is out, but it'll take years) and secure HASH FUNCTION.&#xA;&#xA;bcrypt is NO hash function, it's a key derivation function. Using hash functions as a KDF is insecure, no matter how good the function.&#xA;&#xA;A KDF is no com.google.common.hash.HashFunction as it always needs a salt. This is can be an additional input[1] or generated randomly[2]. Fitting it to the interface by fixing an argument would be a very stupid idea. Allowing a hash function to behave randomly would be no smarter.&#xA;&#xA;I'm not saying that it doesn't belong to Guava, I'm just saying that it doesn't belong to the hash package. No HF is a KDF and vice versa.&#xA;&#xA;[1]:&#xA;http://docs.spring.io/autorepo/docs/spring-security/3.1.7.RELEASE/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html&#xA;[2]:&#xA;https://github.com/wg/scrypt/blob/master/src/main/java/com/lambdaworks/crypto/SCrypt.java&#xA;&#xA;" creator="//@users.51"/>
  </issues>
  <issues title="In Guava 18, MapMaker.makeComputingMap scope has changed, but it's referenced from Guice 4 Beta4" body="&#xA;java.lang.IllegalAccessError: tried to access method com.google.common.collect.MapMaker.makeComputingMap(Lcom/google/common/base/Function;)Ljava/util/concurrent/ConcurrentMap; from class com.google.inject.internal.Annotations$AnnotationChecker&#xA;at com.google.inject.internal.Annotations$AnnotationChecker.(Annotations.java:104)&#xA;at com.google.inject.internal.Annotations.(Annotations.java:122)&#xA;at com.google.inject.spi.InjectionPoint.(InjectionPoint.java:94)&#xA;at com.google.inject.spi.InjectionPoint$InjectableField.toInjectionPoint(InjectionPoint.java:440)&#xA;at com.google.inject.spi.InjectionPoint.getInjectionPoints(InjectionPoint.java:725)&#xA;at com.google.inject.spi.InjectionPoint.forInstanceMethodsAndFields(InjectionPoint.java:358)&#xA;at com.google.inject.spi.InjectionPoint.forInstanceMethodsAndFields(InjectionPoint.java:377)&#xA;at com.google.inject.internal.BindingBuilder.toInstance(BindingBuilder.java:84)&#xA;&#xA;I know the method is marked as deprecated, but changing it's scope has resulted in other libraries with dependencies on it that haven't been updated; including Guice.&#xA;&#xA; relevance: 2" created_at="Sep 13, 2014" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 13, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Cross reference Guice issue: https://github.com/google/guice/issues/846&#xA;&#xA;" creator="//@users.23"/>
  </issues>
  <issues title="Improve Joiner#join documentation and exception message for null behavior" body="&#xA;I'm not sure whether it is an actual bug so I formulated the subject as a question, but I think that if some instances of Joiner (namely those not generated from skipNulls() or useForNull(String)) don't support null arguments and explicitly throw an NPE the parameters of the Joiner#join() method shouldn't be annotated @Nullable.&#xA;&#xA;I also think having a subtype of Joiner (something like NullSupportedJoiner) just for this wouldn't make sense, so if this is done to prevent unnecessary static analysis warnings on Joiner#join() method calls with possibly null parameter values, I would suggest that it at least is added to the documentation of the join() method (that the Joiner instance needs to support null values for the parameters to be nullable).&#xA;It IS explained in the javadoc of the class but it's easy to miss when just looking at the method documentation (e.g. from an IDE).&#xA;&#xA;Throwing a more explicit error (e.g. adding a message about &quot;skipNulls()&quot; call requirement to the thrown NPE) may also be a nice way to document this requirement.&#xA;&#xA;Let me know if I misunderstood something.&#xA;&#xA; relevance: 2" created_at="Sep 15, 2014" labels="//@labels.19 //@labels.26" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Sep 18, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I think we take the position that a parameter has to be @Nullable if *any* implementation of the type permits nulls there. This is certainly not ideal. (It's also not ideal that I'm not 100% sure that I have our policy right.) For general despair around the issue of nullability annotations, see issue 1812.&#xA;&#xA;For this specific case, we can be more optimistic. We can improve the error message and the doc. I'm modifying this bug's title to focus on that.&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="AbstractLoadingCache missing get(Object, Callable)" body="&#xA;AbstractLoadingCache says:&#xA;&quot;To implement a cache, the programmer needs only to extend this class and provide an implementation for the #get(Object) and #getIfPresent methods. #getUnchecked, #get(Object, Callable), and #getAll are implemented in terms of get&quot;&#xA;&#xA;But this is simply not true; get(Object, Callable) is not defined in AbstractLoadingCache, and in AbstractCache it throws UnsupportedOperationException.&#xA;&#xA; relevance: 1" created_at="Today (14 hours ago)" creator="//@users.60"/>
  <issues title="Maps.unmodifiableNavigableMap not covariant in V" body="&#xA;Maps.unmodifiableNavigableMap is declared as follows:&#xA;&#xA;&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, V> map);&#xA;&#xA;this could be changed to &#xA;&#xA;&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V> map);&#xA;&#xA;as there are no methods in NavigableMap that take a V as a method parameter. This would also be consistent with the declarations of Collections.unmodifiableSortedMap and ImmutableSortedMap.copyOfSorted.&#xA;&#xA; relevance: 1" created_at="Yesterday (25 hours ago)" labels="//@labels.23 //@labels.18" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Yesterday (20 hours ago)" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I believe you are correct. And this will probably be sufficiently safe to change. Thanks!&#xA;&#xA;" creator="//@users.45"/>
  </issues>
  <issues title="RangeSet does not document concurrent modification of asRanges()" body="&#xA;RangeSet#asRanges() document how changes to the set are propagated to the inherited set. Is the asRanges() result immutable? Are changes propagated? Or are concurrent modifications not allowed?&#xA;&#xA; relevance: 2" created_at="Aug 12, 2014" labels="//@labels.19 //@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 12, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Eh, sorry should have been &quot;RangeSet#asRanges() _does not_ document&quot;. I was a bit too quick there..&#xA;&#xA;" creator="//@users.15"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 12, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Looks like it all boils down to a call to SortedMap#values() whose result has undefined behaviour when the map is modified.&#xA;&#xA;" creator="//@users.15"/>
  </issues>
  <issues title="Canonicalize a whole RangeSet at once" body="&#xA;I recently noticed/realized that RangeSets over discrete numbers aren't fully reduced. I fully understand why this happens (to handle continuous ranges, such as Floats), however there are cases when it would be really useful to fully reduce a discrete RangeSet. My current use case I'd like to summarize/log a bunch of Long IDs that am storing in a database. Adding `Range#singleton`s will not suffice since the ranges aren't reduced.&#xA;&#xA;To workaround this, I wrote a piece of code that does exactly this:&#xA;&#xA;&#xA;    private void reduceRangeSet(RangeSet&lt;Long> rangeSet) {&#xA;        restart: while (true) {&#xA;            Set&lt;Range&lt;Long>> ranges = rangeSet.asRanges();&#xA;            if (ranges.size() &lt;= 1)&#xA;                break;&#xA;            Range&lt;Long> prevRange = null;&#xA;            for (Range&lt;Long> range : ranges) {&#xA;                if (prevRange != null &amp;&amp; range.contains(range.lowerEndpoint()) // Takes care of checking open/close range end&#xA;                        &amp;&amp; prevRange.contains(range.lowerEndpoint() - 1)) {&#xA;                    rangeSet.add(Range.closedOpen(range.lowerEndpoint() - 1, range.lowerEndpoint()));&#xA;                    &#xA;                    // Must restart outer loop since rangeSet.asRanges() might not update on changes.&#xA;                    continue restart;&#xA;                }&#xA;                prevRange = range;&#xA;            }&#xA;            &#xA;            // If we came here we found nothing to reduce.&#xA;            break;&#xA;        }&#xA;    }&#xA;&#xA;The code does it's job for me, but I suggest it's rewritten to not use nested loops if possible.&#xA;&#xA;A proposal would be to add something similar to maybe &quot;RangeSets.reduce(RangeSet&lt;Long> ...&quot; and possibly also add &quot;RangeSets.reduce(RangeSet&lt;Integer> ...&quot; and maybe even &quot;RangeSets.reduce(RangeSet&lt;Byte> ...&quot;.&#xA;&#xA; relevance: 3" created_at="Aug 12, 2014" labels="//@labels.27 //@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 12, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;It's not clear to me why you'd use this approach, or why you'd special-case for all these types.  The idea is intended to be that you call Range.canonical(DiscreteDomain), passing in the appropriate DiscreteDomain for your type, before adding or removing it from the RangeSet.  &#xA;&#xA;If you canonicalize all Ranges you use to modify your RangeSet, your RangeSet should only contain canonical ranges no matter how ranges get merged, subtracted, etc.&#xA;&#xA;Is there a reason that solution doesn't work for you?&#xA;&#xA;" creator="//@users.55"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 12, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Ignorant question: would it make any sense to add a canonicalize(DiscreteDomain) method to RangeSet, which would basically replace every Range in the set with its canonical version? Maybe that would result in a different set of ranges than you'd get if you only added canonical ranges to the set in the first place?&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 15, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;lowas: Did not know about canonical. It solved my issue. In my case calling canonical for every add is a better solution as I'm using RangeSet to reduce memory pressure.&#xA;&#xA;cgdecker: A canonicalize method is, after my fix, not necessary. So far, I have not had a use case for that now that I know of canonical form of a Range.&#xA;&#xA;" creator="//@users.15"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 15, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I love the happy resolution to your problem.&#xA;&#xA;Let's keep this open to consider the value of a RangeSet canonicalization function.&#xA;&#xA;" creator="//@users.45"/>
  </issues>
  <issues title="missing functionality in CacheStats" body="&#xA;&#xA;Hi,&#xA;&#xA;it looks like CacheStats is missing putCount, which makes statistics not complete if you have situations where cache is populated by load and explicit put.&#xA;&#xA;An possible implementation can be found at:&#xA;&#xA;https://code.google.com/r/kofemann-kofemann-cache-with-put-count/source/detail?r=4810e0e85ea406b0e23324f0379351a23f8eb514&#xA;&#xA;-k&#xA;&#xA; relevance: 3" created_at="Aug 25, 2014" labels="//@labels.25 //@labels.15" creator="//@users.55">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 25, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.61"/>
  </issues>
  <issues title="Overloaded versions of Ints/Longs.tryParse with a radix" body="&#xA;Please add these overloaded methods:&#xA;&#xA;Ints.tryParse(String s, int radix)&#xA;Longs.tryParse(String s, int radix)&#xA;&#xA;That way, Ints/Longs.tryParse could be used as drop-in replacements both String versions of Integer/Long.valueOf&#xA;&#xA;Another thing worth thinking about would be to add similar methods that return Optional&lt;Integer / Long>, forcing client code to actually react on the changed semantics of using tryParse rather than valueOf. Of course the question of how to name these methods is a nasty one. tryParse would've been a perfect naming choice for that&#xA;&#xA; relevance: 2" created_at="Aug 29, 2014" labels="//@labels.27 //@labels.12" creator="//@users.55">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;(No comment was entered for this change.)&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 29, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Did we have any reservations that tryParse(&quot;foo&quot;, 10) might look like it's providing a default value rather than a radix? I forget.&#xA;&#xA;(We did give some thought to Optional&lt;Integer> and so forth. Our reasoning for sticking with Integer was that the method was intended to be fast. But it's not clear cut. For example, and extreme version of that reasoning could have led to our choosing to return |long| with an out-of-int-bounds value used to indicate invalid inputs. We could also have introduced OptionalInteger/OptionalLong classes.)&#xA;&#xA;" creator="//@users.47"/>
  </issues>
  <issues title="ImmutableSortedSet with 1 non-Comparable element" body="&#xA;Creating a singleton immutable sorted set by calling of() with a non-Comparable object is not allowed (via &quot;FauxverideShim&quot;). However, one can be created by first instantiating a single element Collection and creating a copyOf() it.&#xA;&#xA;Example (throws Exception):&#xA;  Object notComparable = new Object();&#xA;  ImmutableSortedSet.of(notComparable);&#xA;&#xA;Example (works):&#xA;  Object notComparable = new Object();&#xA;  ImmutableSortedSet.copyOf(ImmutableSet.of(notComparable));&#xA;&#xA;I submit that they should both work or both fail. While technically a singleton non-comparable SortedSet violates the SortedSet contract (&quot;All elements inserted into a sorted set must implement the Comparable interface&quot;), it make senses to me that an immutable SortedSet of 1 element could be an exception (and thus not throw an Exception). In fact, TreeSet does not fail with a single non-Comparable element:&#xA;&#xA;  SortedSet&lt;Object> sortedSet = new TreeSet&lt;Object>();&#xA;  sortedSet.add(notComparable);&#xA;&#xA; relevance: 2" created_at="Aug 19, 2014" labels="//@labels.18 //@labels.23" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 20, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;Nice find. I believe we should make copyOf fail.&#xA;&#xA;I believe the TreeSet bug you mention is finally fixed for JDK 8.&#xA;&#xA;" creator="//@users.45"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 20, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I checked and you're correct that the TreeSet bug is fixed (in a Java 7 release). For enterprise (read too boring to enumerate here) reasons, we're still on a late build of Java 6. I retract my final comment and agree with your assessment.&#xA;&#xA;" creator="//@users.43"/>
  </issues>
  <issues title="Probable EventBus memory leak when shared class loader used" body="&#xA;Hi,&#xA;&#xA;I am having Guava loaded by shared classloader inside Tomcat and every webapp can register into static singleton EventBus waiting to incoming events. Problem is that it looks like that EventBus from shared classloader is unable to free registered methods when webapp is undeployed.&#xA;&#xA;I have attached test case with workaround and probable fix when LoadingCache uses weakKeys with weakValues.&#xA;&#xA;Could you look at it - code will tell you more. You can build test case with Guava 14 and 17 (Maven profile) when symptoms are the same. &#xA;&#xA;Thx&#xA;Ivos&#xA;&#xA;&#xA;*Test case 1*&#xA;{{{Using Guava version 17.0&#xA;class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@1d6535bf&#xA;class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@1d6535bf&#xA;--- start ---&#xA;Test using ordinary Guava&#xA;class guava.Callback loaded by java.net.URLClassLoader@25b0eadd&#xA;class guava.Callback$Event loaded by java.net.URLClassLoader@25b0eadd&#xA;onEvent(guava.Callback$Event@edea70b)&#xA;&#x9;Callback&#x9;java.net.URLClassLoader@25b0eadd&#xA;&#x9;Event&#x9;&#x9;java.net.URLClassLoader@25b0eadd&#xA;--- end ---&#xA;Loading cache result {class guava.Callback=[public void guava.Callback.onEvent(guava.Callback$Event)]}&#xA;=== Memory leak detected? ===}}}&#xA;&#xA;*Test case 2*&#xA;_Note: take a look at inconsistency message_&#xA;{{{Using Guava version 17.0&#xA;class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;--- start ---&#xA;Test with weak values loading cache&#xA;class com.google.common.cache.LocalCache$LocalLoadingCache loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;class guava.Callback loaded by java.net.URLClassLoader@1f4cc34b&#xA;class guava.Callback$Event loaded by java.net.URLClassLoader@1f4cc34b&#xA;onEvent(guava.Callback$Event@c063ed4)&#xA;&#x9;Callback&#x9;java.net.URLClassLoader@1f4cc34b&#xA;&#x9;Event&#x9;&#x9;java.net.URLClassLoader@1f4cc34b&#xA;--- end ---&#xA;Loading cache result {}&#xA;=== Memory leak detected? ===&#xA;Inconsistent .toString({}) and .size(1) when LoadingCache.asMap() called ???}}}&#xA;&#xA;*Test case 3*&#xA;{{{Using Guava version 17.0&#xA;class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;--- start ---&#xA;Test with loading cache invalidation workaround&#xA;class guava.Callback loaded by java.net.URLClassLoader@f785762&#xA;class guava.Callback$Event loaded by java.net.URLClassLoader@f785762&#xA;onEvent(guava.Callback$Event@2aae2481)&#xA;&#x9;Callback&#x9;java.net.URLClassLoader@f785762&#xA;&#x9;Event&#x9;&#x9;java.net.URLClassLoader@f785762&#xA;--- end ---&#xA;Loading cache result {} }}}&#xA;&#xA;&#xA; relevance: 3" created_at="Aug 23, 2014" labels="//@labels.25 //@labels.21" creator="//@users.60">
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 27, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I guess this is caused by the static members of `SubscriberRegistry`: `flattenHierarchyCache` and `subscriberMethodsCache`. They use `weakKeys`, but this seems to be of no use at all, because of the strong value references. In your example, an entry linking `Callback.class` to `ImmutableList.of(Callback#onEvent)` gets created, and the method strongly references its class, so nothing can be GC'ed.&#xA;&#xA;" creator="//@users.51"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 27, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I know why it is caused :-) . Anyways thanks for summarization...&#xA;&#xA;" creator="//@users.19"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I'm not sure what can be done about this. In the flattenHierarchyCache case (used for event types), I think we could safely store the values in WeakReferences. In the subscriberMethodsCache, I'm pretty sure we can't, because Class always returns *copies* of the Method objects. In other words, if we store WeakReferences to the Methods, nothing will be strongly referencing those Method objects and they'll just get GC'ed, meaning we aren't really caching anything. And just not caching the Methods seems like it could have a significant performance impact.&#xA;&#xA;As an aside, I don't feel like using a shared EventBus to communicate between separate web applications is a good idea. In particular, I'd be concerned about things like different applications loading the &quot;same&quot; class with different classloaders. There are other tools that are better suited for what is effectively interprocess communication.&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;> nothing will be strongly referencing those Method objects&#xA;&#xA;I'd say, as long as they're used in an `EventBus`, their `Subscriber`s will. But if they're not, then they can be GC'd even when their classes are loaded and this is AFAIK unsolvable without ephemerons.&#xA;&#xA;And you'd have to use `ImmutableList&lt;WeakReference&lt;Method>>` which means that you could get an incomplete method list from the cache. Surely solvable, but ugly.&#xA;&#xA;Anyway, using `weakKeys` in the current design doesn't help at all, does it?&#xA;&#xA;A minor optimization: I guess `getAnnotatedMethodsNotCached` could use `flattenHierarchyCache` instead of `TypeToken.of(clazz).getTypes().rawTypes()`.&#xA;&#xA;&#xA;" creator="//@users.51"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 30, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;> I'd say, as long as they're used in an `EventBus`, their `Subscriber`s will. But if they're not, then they can be GC'd even when their classes are loaded and this is AFAIK unsolvable without ephemerons.&#xA;&#xA;True, though if you've got a class that is subscribed and unsubscribed repeatedly it's not really helping.&#xA;&#xA;> And you'd have to use `ImmutableList&lt;WeakReference&lt;Method>>` which means that you could get an incomplete method list from the cache. Surely solvable, but ugly.&#xA;&#xA;Actually, if the Methods are being thrown into WeakReferences in the CacheLoader, they wouldn't have any strong references left even before the call to LoadingCache.get that loads them completes. Which makes it sound like it's possible that you might *never* get a complete list of Methods back. &#xA;&#xA;> Anyway, using `weakKeys` in the current design doesn't help at all, does it?&#xA;&#xA;No, not really.&#xA;&#xA;> A minor optimization: I guess `getAnnotatedMethodsNotCached` could use `flattenHierarchyCache` instead of `TypeToken.of(clazz).getTypes().rawTypes()`.&#xA;&#xA;It could, but I don't feel like it's really an optimization at all given that the result of getAnnotatedMethodsNotCached is cached itself. Right now, that TypeToken.of(clazz).getTypes().rawTypes() should only be called once per class anyway, so we'd be caching the result for no reason. (And I think it's very unlikely that there would be any overlap between the current usage of flattenHiearchyCache and this, since currently it's only used for event classes, while this would be using it for subscriber classes.) If we weren't caching the result, that would be a different story.&#xA;&#xA;" creator="//@users.8"/>
    <elements xsi:type="atlanmod.github.org:IssueComment" created_at="Aug 31, 2014" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;&#xA;I think that good enought solution would be having flush cache methods on EventBus (or on AnnotatedSubscriberFinder) like JavaBeans Introspector have. &#xA;&#xA;java.beans.Introspector#flushCaches()&#xA;java.beans.Introspector#flushFromCaches(Class&lt;?>)&#xA;&#xA;Btw. In my design I have MyEvent classes loaded by same shared classloader which loads Guava. And shared event classes refer to classes from same shared classloader or from parent class loaders.&#xA;&#xA;" creator="//@users.19"/>
  </issues>
  <labels name="eventbus"/>
  <labels name="Helpers"/>
  <labels name="Collections"/>
  <labels name="Libraries"/>
  <labels name="IO"/>
  <labels name="Caching"/>
  <labels name="Google"/>
  <labels name="Concurrency"/>
  <labels name="Utilities"/>
  <labels name="Java"/>
  <labels name="Primitives"/>
  <labels name="Package-Concurrent"/>
  <labels name="Package-Primitives"/>
  <labels name="Package-IO"/>
  <labels name="Type-Performance"/>
  <labels name="Package-Cache"/>
  <labels name="Milestone-Release19"/>
  <labels name="Package-Reflect"/>
  <labels name="Type-Defect"/>
  <labels name="Type-ApiDocs"/>
  <labels name="Package-General"/>
  <labels name="Package-EventBus"/>
  <labels name="Package-Testing"/>
  <labels name="Package-Collect"/>
  <labels name="Package-Hash"/>
  <labels name="Type-Enhancement"/>
  <labels name="Package-Base"/>
  <labels name="Type-Addition"/>
  <wiki>
    <pages name="Project Description" is_home="true" body="The Guava project contains several of Google's core libraries that we rely on in our Java-based projects: collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, and so forth.&#xA;The latest release is 18.0, released August 25, 2014.&#xA;Start using Guava&#xA;You can download a JAR at:&#xA;guava-18.0.jar guava-gwt-18.0.jar (for GWT users)&#xA;Guava is also available in Maven Central under the following identifiers:&#xA;com.google.guava:guava com.google.guava:guava-gwt (for GWT users)&#xA;Learn more about how to UseGuavaInYourBuild.&#xA;Please see the 18.0 release notes for more details about this release.&#xA;Learn about Guava&#xA;Our users' guide, GuavaExplained Browse API docs for the most recent release Browse API diffs for the most recent release Presentation slides focusing on base, primitives, and io Presentation slides focusing on cache Presentation slides focusing on util.concurrent A nice collection of other helpful links&#xA;How to communicate with us (and each other)&#xA;To stay informed and get &quot;tip of the week&quot;-style posts, follow +Google Guava on Google+.&#xA;To just stay informed, period, about important news that every Guava user needs to know, subscribe to guava-announce. It is very low-traffic.&#xA;To report a defect or request a feature, click the Issues tab above and enter a new issue.&#xA;To get help on a specific question or problem, post a question to Stack Overflow with the tag &quot;guava&quot;. We monitor these questions using this RSS feed.)&#xA;Keep an eye on project updates using any of these Project Feeds. (The &quot;Updates&quot; feed is an aggregation of all the others.) You can view our code changes as they happen, and comment on them using the code-review tool.&#xA;We have a read-only mailing list consisting of email notifications of issue tracker activity, which can be easier to follow in a threaded manner than the project feed.&#xA;For general discussion that doesn't fit neatly into any of these categories, join our discussion group guava-discuss.&#xA;Important Warnings&#xA;Guava contains a strictly compatible superset of the old, deprecated Google Collections Library. You should not use that library anymore.&#xA;APIs marked with the @Beta annotation at the class or method level are subject to change. They can be modified in any way, or even removed, in any major release. If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard). Here is a current list of all the beta APIs.&#xA;Serialized forms of ALL objects are subject to change. Do not persist these and assume they can be read by a future version of the library.&#xA;Deprecated non-beta APIs will be removed eighteen months after the release in which they are first deprecated. You must fix your usages before this time. If you don't, any manner of breakage might result (you are not guaranteed a compilation error).&#xA; licenseApache License 2.0"/>
    <pages name="UsingAndAvoidingNullExplained" body="summary: Guava tools to use and avoid the use of null, explained.&#xA;&quot;Null sucks.&quot; -Doug Lea&#xA;&#xA;&quot;I call it my billion-dollar mistake.&quot; - Sir C. A. R. Hoare, on his invention of the null reference&#xA;&#xA;Using and avoiding null&#xA;Careless use of null can cause a staggering variety of bugs. Studying the Google code base, we found that something like 95% of collections weren't supposed to have any null values in them, and having those fail fast rather than silently accept null would have been helpful to developers.&#xA;Additionally, null is unpleasantly ambiguous. It's rarely obvious what a null return value is supposed to mean -- for example, Map.get(key) can return null either because the value in the map is null, or the value is not in the map. Null can mean failure, can mean success, can mean almost anything. Using something other than null makes your meaning clear.&#xA;That said, there are times when null is the right and correct thing to use. null is cheap, in terms of memory and speed, and it's unavoidable in object arrays. But in application code, as opposed to libraries, it is a major source of confusion, difficult and weird bugs, and unpleasant ambiguities -- e.g. when Map.get returns null, it can mean the value was absent, or the value was present and null. Most critically, null gives no indication what a null value means.&#xA;For these reasons, many of Guava's utilities are designed to fail fast in the presence of null rather than allow nulls to be used, so long as there is a null-friendly workaround available. Additionally, Guava provides a number of facilities both to make using null easier, when you must, and to help you avoid using null.&#xA;Specific Cases&#xA;If you're trying to use null values in a Set or as a key in a Map -- don't; it's clearer (less surprising) if you explicitly special-case null during lookup operations.&#xA;If you want to use null as a value in a Map -- leave out that entry; keep a separate Set of non-null keys (or null keys). It's very easy to mix up the cases where a Map contains an entry for a key, with value null, and the case where the Map has no entry for a key. It's much better just to keep such keys separate, and to think about what it means to your application when the value associated with a key is null.&#xA;If you're using nulls in a List -- if the list is sparse, might you rather use a Map&lt;Integer, E>? This might actually be more efficient, and could potentially actually match your application's needs more accurately.&#xA;Consider if there is a natural &quot;null object&quot; that can be used. There isn't always. But sometimes. For example, if it's an enum, add a constant to mean whatever you're expecting null to mean here. For example, java.math.RoundingMode has an UNNECESSARY value to indicate &quot;do no rounding, and throw an exception if rounding would be necessary.&quot;&#xA;If you really need null values, and you're having problems with a null-hostile collection implementations, use a different implementation. For example, use Collections.unmodifiableList(Lists.newArrayList()) instead of ImmutableList.&#xA;Optional&#xA;Many of the cases where programmers use null is to indicate some sort of absence: perhaps where there might have been a value, there is none, or one could not be found. For example, Map.get returns null when no value is found for a key.&#xA;Optional&lt;T> is a way of replacing a nullable T reference with a non-null value. An Optional may either contain a non-null T reference (in which case we say the reference is &quot;present&quot;), or it may contain nothing (in which case we say the reference is &quot;absent&quot;). It is never said to &quot;contain null.&quot;&#xA;Optional&lt;Integer> possible = Optional.of(5);&#xA;possible.isPresent(); // returns true&#xA;possible.get(); // returns 5&#xA;Optional is not intended as a direct analogue of any existing &quot;option&quot; or &quot;maybe&quot; construct from other programming environments, though it may bear some similarities.&#xA;We list some of the most common Optional operations here.&#xA;Making an Optional&#xA;Each of these are static methods on Optional.&#xA;Optional.of(T) Make an Optional containing the given non-null value, or fail fast on null. Optional.absent() Return an absent Optional of some type. Optional.fromNullable(T) Turn the given possibly-null reference into an Optional, treating non-null as present and null as absent.&#xA;&#xA;Query methods&#xA;Each of these are non-static methods on a particular Optional&lt;T> value. boolean isPresent() Returns true if this Optional contains a non-null instance. T get() Returns the contained T instance, which must be present; otherwise, throws an IllegalStateException.T or(T) Returns the present value in this Optional, or if there is none, returns the specified default. T orNull() Returns the present value in this Optional, or if there is none, returns null. The inverse operation of fromNullable. Set&lt;T> asSet() Returns an immutable singleton Set containing the instance in this Optional, if there is one, or otherwise an empty immutable set.&#xA;&#xA;Optional provides several more handy utility methods besides these; consult the Javadoc for details.&#xA;What's the point?&#xA;Besides the increase in readability that comes from giving null a name, the biggest advantage of Optional is its idiot-proof-ness. It forces you to actively think about the absent case if you want your program to compile at all, since you have to actively unwrap the Optional and address that case. Null makes it disturbingly easy to simply forget things, and though FindBugs helps, we don't think it addresses the issue nearly as well.&#xA;This is especially relevant when you're returning values that may or may not be &quot;present.&quot; You (and others) are far more likely to forget that other.method(a, b) could return a null value than you're likely to forget that a could be null when you're implementing other.method. Returning Optional makes it impossible for callers to forget that case, since they have to unwrap the object themselves for their code to compile.&#xA;Convenience methods&#xA;Whenever you want a null value to be replaced with some default value instead, use Objects.firstNonNull(T, T). As the method name suggests, if both of the inputs are null, it fails fast with a NullPointerException. If you are using an Optional, there are better alternatives -- e.g. first.or(second).&#xA;A couple of methods dealing with possibly-null String values are provided in Strings. Specifically, we provide the aptly named: emptyToNull(String) isNullOrEmpty(String) nullToEmpty(String)&#xA;&#xA;We would like to emphasize that these methods are primarily for interfacing with unpleasant APIs that equate null strings and empty strings. Every time you write code that conflates null strings and empty strings, the Guava team weeps. (If null strings and empty strings mean actively different things, that's better, but treating them as the same thing is a disturbingly common code smell.)&#xA; owner: wasserman.louis&#xA; last update: Mar 20, 2012"/>
    <pages name="StripedExplained" body="summary: The `Striped` locking utility, explained.&#xA;Striped, to be released in Guava 13.0, is a tool for assigning locks to objects in a configurable, flexible manner.&#xA;When you want to associate a lock with an object, the key guarantee you need is that if key1.equals(key2), then the lock associated with key1 is the same as the lock associated with key2.&#xA;The crudest way to do this is to associate every key with the same lock, which results in the coarsest synchronization possible. On the other hand, you can associate every distinct key with a different lock, but this requires linear memory consumption and concurrency management for the system of locks itself, as new keys are discovered.&#xA;Striped allows the programmer to select a number of locks, which are distributed between keys based on their hash code. This allows the programmer to dynamically select a tradeoff between concurrency and memory consumption, while retaining the key invariant that if key1.equals(key2), then striped.get(key1) == striped.get(key2).&#xA;Striped contains overloads allowing it to be used for Lock, ReadWriteLock, or Semaphore.&#xA;Additionally, Striped offers variants of each of these with lazily initialized, weakly referenced locks. Essentially, when no thread still references a lock, it can't be waited on or waiting to be released, so it can be safely garbage-collected; this can reduce memory consumption if only a few locks will be in use at any given time.&#xA; owner: wasserman.louis&#xA; last update: Jun 27, 2012"/>
    <pages name="PhilosophyExplained" body="summary: Some points on the Guava philosophy, explained.&#xA;In progress&#xA;What Guava Is&#xA;Guava is the open-sourced version of Google's core Java libraries: the core utilities that Googlers use every day in their code. The Guava utilities have been carefully designed, tested, optimized and used in production at Google. You don't need to write them, test them, or optimize them: you can just use them.&#xA;Guava is a productivity multiplier for Java projects across the board: we aim to make working in the Java language more pleasant and more productive. The JDK utilities, e.g. the Collections API, have been widely adopted and have significantly simplified virtually all Java code. We hope to continue in that tradition.&#xA;I Could've Invented That&#xA;Effective Java item 47, &quot;Know and use the libraries,&quot; is our favorite explanation of why using libraries is, by and large, preferable to writing your own utilities. The final paragraph bears repeating:&#xA;To summarize, don&#x2019;t reinvent the wheel. If you need to do something that seems like it should be reasonably common, there may already be a class in the libraries that does what you want. If there is, use it; if you don&#x2019;t know, check. Generally speaking, library code is likely to be better than code that you&#x2019;d write yourself and is likely to improve over time. This is no reflection on your abilities as a programmer. Economies of scale dictate that library code receives far more attention than most developers could afford to devote to the same functionality.&#xA;We'd also like to mention that:&#xA;Guava has been battle-tested in production at Google. Guava has staggering numbers of unit tests: as of July 2012, the guava-tests package includes over 286,000 individual test cases. Most of these are automatically generated, not written by hand, but Guava's test coverage is extremely thorough, especially for com.google.common.collect. Guava is under active development and has a strong, vocal, and involved user base. The best libraries seem obvious in retrospect, but achieving this state is notoriously challenging.&#xA;When In Doubt...&#xA;We can be somewhat conservative on adding features to Guava. Guava sits so low in the stack that removing features without breaking users is extremely difficult, so we tend to hold off on adding features we're not sure about. (Sometimes, we'll trial-run features &quot;Google-internally,&quot; where we can migrate users away from a failed feature ourselves.)&#xA;Guava's primary metric when deciding whether to add a new feature is frequently summed up as utility times ubiquity.&#xA;A feature is said to have utility when it represents a substantial improvement on the simplest available workaround. In principle, there is always some workaround -- even if it's just writing that utility method, or that data structure, yourself. On the other hand, adding a feature to Guava might&#xA;save you significant amounts of code avoid forcing you to write code that's difficult to debug, or that's easy to get wrong improve readability improve speed&#xA;as compared to the available workarounds.&#xA;A feature has ubiquity when there are a diverse range of use cases for it.&#xA;When trying to estimate the ubiquity of a feature, we frequently use the Google internal code base as a reference: if not one project inside Google found a use for some code, then does anybody really need that feature? Having such a large code base to examine gives us lots of data to work with...and it's always nice to be able to cite hard numbers.&#xA;Not all Guava features have much utility (see e.g. Lists.newArrayList) or ubiquity (see e.g. MinMaxPriorityQueue), but we generally try to maximize their product.&#xA;A few general design principles Guava aims for are:&#xA;There should always be some use case for which the API is clearly the best solution possible. If we're not sure this is the best API possible for the job, think about it until we are sure. The semantics of methods and classes should be obvious and intuitive from their signatures, as opposed to &quot;smart.&quot; Internal implementations can do smart things in special cases, but the semantics for those special cases should be the same. Encourage good code habits in Guava users, and exemplify good code habits ourselves in Guava source. (This has many corollaries, including &quot;fail fast,&quot; &quot;reject nulls,&quot; and the like.) Don't try to address every use case individually -- provide generic tools that can be composed to address use cases we haven't thought of yet. Emphasize maintainability, and leave room for future refactorings. (Corollary: most exposed classes should be final, as per Effective Java item 17; exposing &quot;skeleton&quot; AbstractXXX classes should be done very conservatively.)&#xA;Iteration&#xA;In contrast to the JDK -- which maintains extremely strict backwards compatibility even for its worst mistakes -- Guava deprecates, and yes, deletes unwanted features over time. It is important to us that when you see a feature in the Javadocs, it represents the Guava team's best work, and not a feature that in retrospect was a bad idea.&#xA;We do, however, work to make sure that we don't wantonly break our users. If we aren't ready to freeze the API on some particular component, for whatever reason, we will mark the component as @Beta. More details on this are below.&#xA;Beta APIs&#xA;Beta APIs represent Guava features that we aren't ready to freeze for whatever reason: because the methods might not find enough users, because they might be moved, because their uses might be too narrow to include them in Guava.&#xA;That said, @Beta APIs are fully tested and supported, and treated with all the care and affection that the rest of Guava receives.&#xA;The biggest connotation of the @Beta annotation is that annotated classes or methods are subject to change. They can be modified in any way, or even removed, at any time. If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard).&#xA;All this said, @Beta features tend to remain relatively stable. If we decide to delete a @Beta feature, we will typically deprecate it for one release before deleting it.&#xA;On the other hand, if you want something taken out of @Beta, file an issue. We generally promote features out of @Beta only when it's specifically requested, so if you don't ask, it won't happen.&#xA;Non-Beta APIs&#xA;Deprecated non-beta APIs will be removed eighteen months after the release in which they are first deprecated. You must fix your references before this time. If you don't, any manner of breakage could result (you are not guaranteed a compilation error).&#xA;Guava originated from the now-defunct Google Collections API. However, the Google Collections API is now old enough that some parts have gone through the eighteen-month deprecation period and been deleted. If you are still using Google Collections, and have problems migrating, ask for help on the mailing list.&#xA;Support and Feedback&#xA;The Guava community is very active. Generally speaking:&#xA;Ask for help on a specific question or problem on StackOverflow. File feature requests, bug reports, and the like under the Issues tab. General discussion that doesn't fit into these categories takes place on our discussion group.&#xA;The Guava team is generally highly active in all of these areas.&#xA; owner: wasserman.louis&#xA; last update: Jul 29, 2012"/>
    <pages name="Release08" body="summary: Release notes for Guava Release 08&#xA;Guava Release 08: Release Notes&#xA;Release 08 was released on January 27, 2011. (See ReleaseHistory.)&#xA;Download it&#xA;Javadocs are included, but more complete javadocs (using the &quot;-linksource&quot; and &quot;-use&quot; javadoc options) are always available on-line:&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;Here are some code/config snippets for how to UseGuavaInYourBuild.&#xA;This release is identified in the Maven &quot;central&quot; repository used by maven, ivy, gradle, ant (with maven ant tasks) as com.google.guava:guava:r08. (Note: the GWT artifact is not yet released to the maven central repository. Stay tuned.)&#xA;API Changes&#xA;Full JDiff Report of changes since release 07&#xA;To build a combined report of the API changes between release 08 and any older release, check out our source tree and run svn/tags/release08/javadoc/jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 05).&#xA;Issues resolved&#xA;Issues fixed&#xA; owner: wasserman.louis&#xA; last update: Mar 20, 2012"/>
    <pages name="HashingExplained" body="summary: Guava hashing utilities, explained.&#xA;Overview&#xA;Java's baked-in concept of hash codes is constrained to 32 bits, and provides no separation between hash algorithms and the data they act on, so alternate hash algorithms can't be easily substituted. Also, implementations of hashCode tend to be poor-quality, in part because they end up depending on other existing poor-quality hashCode implementations, including those in many JDK classes.&#xA;Object.hashCode implementations tend to be very fast, but have weak collision prevention and no expectation of bit dispersion. This leaves them perfectly suitable for use in hash tables, because extra collisions cause only a slight performance hit, while poor bit dispersion is easily corrected using a secondary hash function (which all reasonable hash table implementations in Java use). For the many uses of hash functions beyond simple hash tables, however, Object.hashCode almost always falls short -- hence, com.google.common.hash.&#xA;Organization&#xA;Looking at the package Javadoc, we see a lot of different types, but it's not obvious how they fit together.&#xA;Let's look at a sample piece of code using this library.&#xA;HashFunction hf = Hashing.md5();&#xA;HashCode hc = hf.newHasher()&#xA;       .putLong(id)&#xA;       .putString(name, Charsets.UTF_8)&#xA;       .putObject(person, personFunnel)&#xA;       .hash();&#xA;HashFunction&#xA;HashFunction is a pure (referentially transparent), stateless function that maps an arbitrary block of data to a fixed number of bits, with the property that equal inputs always yield equal outputs, and unequal inputs yield unequal outputs as often as possible.&#xA;Hasher&#xA;A HashFunction can be asked for a stateful Hasher, which provides fluent syntax to add data to the hash and then retrieve the hash value. A Hasher can accept any primitive input, byte arrays, slices of byte arrays, character sequences, character sequences in some charset, and so on, or any other Object, provided with an appropriate Funnel.&#xA;Hasher implements the PrimitiveSink interface, which specifies a fluent API for an object that accepts a stream of primitive values.&#xA;Funnel&#xA;A Funnel describes how to decompose a particular object type into primitive field values. For example, if we had&#xA;class Person {&#xA;  final int id;&#xA;  final String firstName;&#xA;  final String lastName;&#xA;  final int birthYear;&#xA;}&#xA;our Funnel might look like&#xA;Funnel&lt;Person> personFunnel = new Funnel&lt;Person>() {&#xA;  @Override&#xA;  public void funnel(Person person, PrimitiveSink into) {&#xA;    into&#xA;      .putInt(person.id)&#xA;      .putString(person.firstName, Charsets.UTF_8)&#xA;      .putString(person.lastName, Charsets.UTF_8)&#xA;      .putInt(birthYear);&#xA;  }&#xA;};&#xA;Note: putString(&quot;abc&quot;, Charsets.UTF_8).putString(&quot;def&quot;, Charsets.UTF_8) is fully equivalent to putString(&quot;ab&quot;, Charsets.UTF_8).putString(&quot;cdef&quot;, Charsets.UTF_8), because they produce the same byte sequence. This can cause unintended hash collisions. Adding separators of some kind can help eliminate unintended hash collisions.&#xA;HashCode&#xA;Once a Hasher has been given all its input, its hash() method can be used to retrieve a HashCode. (The behavior of hash() is unspecified if called more than once.) HashCode supports equality testing and such, as well as asInt(), asLong(), asBytes() methods, and additionally, writeBytesTo(array, offset, maxLength), which writes the first maxLength bytes of the hash into the array.&#xA;BloomFilter&#xA;Bloom filters are a lovely application of hashing that cannot be done simply using Object.hashCode(). Briefly, Bloom filters are a probabilistic data structure, allowing you to test if an object is definitely not in the filter, or was probably added to the Bloom filter. The Wikipedia page is fairly comprehensive, and we recommend this tutorial.&#xA;Our hashing library has a built-in Bloom filter implementation, which requires only that you implement a Funnel to decompose your type into primitive types. You can obtain a fresh BloomFilter&lt;T> with create(Funnel funnel, int expectedInsertions, double falsePositiveProbability), or just accept the default false probability of 3%. BloomFilter&lt;T> offers the methods boolean mightContain(T) and void put(T), which are self-explanatory enough.&#xA;BloomFilter&lt;Person> friends = BloomFilter.create(personFunnel, 500, 0.01);&#xA;for(Person friend : friendsList) {&#xA;  friends.put(friend);&#xA;}&#xA;// much later&#xA;if (friends.mightContain(dude)) {&#xA;  // the probability that dude reached this place if he isn't a friend is 1%&#xA;  // we might, for example, start asynchronously loading things for dude while we do a more expensive exact check&#xA;}&#xA;Hashing&#xA;The Hashing utility class provides a number of stock hash functions and utilities to operate on HashCode objects.&#xA;Provided Hash Functions&#xA;md5() murmur3_128() murmur3_32() sha1() sha256() sha512() goodFastHash(int bits)&#xA;&#xA;HashCode Operations&#xA;Method Description HashCode combineOrdered(Iterable&lt;HashCode>) Combines hash codes in an ordered fashion, so that if two hashes obtained from this method are the same, then it is likely that each was computed from the same hashes in the same order. HashCode combineUnordered(Iterable&lt;HashCode>) Combines hash codes in an unordered fashion, so that if two hashes obtained from this method are the same, then it is likely that each was computed from the same hashes in some order. int consistentHash(HashCode, int buckets) Assigns the hash code a consistent &quot;bucket&quot; which minimizes the need for remapping as the number of buckets grows. See Wikipedia for details.&#xA; owner: kurt.kluever&#xA; last update: Apr 18, 2013"/>
    <pages name="InternetDomainNameExplained" body="summary: InternetDomainName tips and pitfalls.&#xA;Introduction&#xA;InternetDomainName is a useful tool for parsing and manipulating domain names. It can be used as a validator, a component extractor, and as a value type for passing around domain names in a type-safe way.&#xA;However, there are some aspects of InternetDomainName behavior which may be surprising, and which can lead to bugs in calling code. This document addresses these concerns.&#xA;Details&#xA;Public suffixes and private domains&#xA;An InternetDomainName object is guaranteed to be syntactically valid according to relevant RFC specifications, but it is not guaranteed to correspond to an actual addressable domain on the Internet. It is impossible to do that without doing a net lookup of the domain and trying to contact it, and that is unacceptable overhead for most common cases.&#xA;Still, it is often very useful to determine whether a given domain name might represent an actual domain on the Internet. For this purpose, we use data from the Public Suffix List (PSL), a list maintained by the Mozilla Foundation. There are methods on InternetDomainName to determine the relationship of a given domain to the PSL. To put it in its most basic terms, if domain.hasPublicSuffix() returns true, then the domain might correspond to a real Internet address; otherwise, it almost certainly does not.&#xA;At this point we need to back up and define some terms. There are three terms of interest:&#xA;Top-Level Domain (TLD): A single-label domain managed by ICANN, such as com or au. Public suffix: A domain under which people can register subdomains, and on which cookies should not be set. Effective Top-Level Domain: A deprecated synonym for &quot;public suffix&quot;.&#xA;It's worth reading the linked articles carefully before proceeding.&#xA;A major source of confusion is that people say &quot;TLD&quot; when they mean &quot;public suffix&quot;. These are independent concepts. So, for example,&#xA;uk is a TLD, but not a public suffix co.uk is a public suffix, but not a TLD squerf is neither a TLD nor a public suffix com is both a TLD and a public suffix&#xA;This confusion is especially dangerous because TLD has a crisp, formal definition, while public suffix does not. In the end, a public suffix is something that a credible source has asked the PSL maintainers to add to the list. Credible sources include ICANN and country-domain managers, but also include private companies offering services that share the characteristics that (fuzzily) define a public suffix -- independent subdomains and supercookie suppression. So, for example, many Google-owned domains (e.g. blogspot.com) are included in the PSL.&#xA;Getting back to InternetDomainName, as long as we limit ourselves to using hasPublicSuffix() to validate that the domain is a plausible Internet domain, all is well. The danger arises from the methods that identify or extract the &quot;top private domain&quot;. From a technical point of view, the top private domain is simply the rightmost superdomain preceding the public suffix. So for example, www.foo.co.uk has a public suffix of co.uk, and a top private domain of foo.co.uk.&#xA;As noted in the documentation on isUnderPublicSuffix(), isTopPrivateDomain(), and topPrivateDomain(), the only thing these methods are (mostly) reliable for is determining where one can set cookies. However, what many people are actually trying to do is find the &quot;real&quot; domain, or the &quot;owner&quot; domain, from a subdomain. For example, in mail.google.com they would like to identify google.com as the owner domain. So they write&#xA;InternetDomainName owner = InternetDomainName.from(&quot;mail.google.com&quot;).topPrivateDomain();&#xA;...and sure enough, owner ends up with the domain google.com. Indeed, this idiom (and ones like it) work a great deal of the time. It seems intuitive that &quot;the domain under the public suffix&quot; should be semantically equivalent to &quot;the owner domain&quot;.&#xA;But it's not, and therein lies the problem. Consider blogspot.com, which appears in the PSL. While it has the characteristics of a public suffix -- people can register domains under it (for their blogs), and cookies should not be allowed to be set on it (to prevent cross-blog cookie shenanigans), it is itself an addressable domain on the Internet (which happens to redirect to blogger.com as I write this, but that could easily change).&#xA;So if I use the idiom above on foo.blogspot.com, owner will be that same domain, foo.blogspot.com. This is the right answer in the terms we have been discussing, but it is obviously surprising to many people.&#xA;The big lessons here are:&#xA;TLDs and public suffixes are not the same thing. Public suffixes are defined by humans, for strictly limited purposes (mostly domain validation and supercookie prevention), and change unpredictably. There is no defined mapping between the relationship of a given domain to a public suffix, the ability of that domain to respond to web requests, and the &quot;ownership&quot; of that domain. You can use InternetDomainName to determine whether a given string represents a plausibly addressable domain on the Internet, and to determine what portion of a domain is likely to allow cookies to be set. You cannot use InternetDomainName to determine if a domain exists on the Internet as an addressable host, nor what superdomain &quot;owns&quot; that domain in a business or administrative sense.&#xA;Remember that if you do not heed this advice, your code will appear to work on a huge variety of inputs...but the failure cases are all bugs just waiting to happen, and the set of failure cases will change as PSL updates are incorporated into the code underlying InternetDomainName.&#xA; owner: cbe...@google.com&#xA; last update: Jan 25, 2013"/>
    <pages name="OrderingExplained" body="summary: Guava's fluent comparator class, Ordering, explained.&#xA;Example&#xA;assertTrue(byLengthOrdering.reverse().isOrdered(list));&#xA;Overview&#xA;Ordering is Guava's &quot;fluent&quot; Comparator class, which can be used to build complex comparators and apply them to collections of objects.&#xA;At its core, an Ordering instance is nothing more than a special Comparator instance. Ordering simply takes the methods that rely on a Comparator (for example, Collections.max) and makes them available as instance methods. For additional power, Ordering class provides chaining methods to tweak and enhance existing comparators.&#xA;Creation&#xA;Common orderings are provided by static methods:&#xA;Method Description natural() Uses the natural ordering on Comparable types. usingToString() Compares objects by the lexicographical ordering of their string representations, as returned by toString().&#xA;&#xA;Making a preexisting Comparator into an Ordering is as simple as using Ordering.from(Comparator).&#xA;But the more common way to create a custom Ordering is to skip the Comparator entirely in favor of extending the Ordering abstract class directly:&#xA;Ordering&lt;String> byLengthOrdering = new Ordering&lt;String>() {&#xA;  public int compare(String left, String right) {&#xA;    return Ints.compare(left.length(), right.length());&#xA;  }&#xA;};&#xA;Chaining&#xA;A given Ordering can be wrapped to obtain derived orderings. Some of the most commonly used variations include:&#xA;Method Description reverse() Returns the reverse ordering. nullsFirst() Returns an Ordering that orders nulls before non-null elements, and otherwise behaves the same as the original Ordering. See also nullsLast(). compound(Comparator) Returns an Ordering which uses the specified Comparator to &quot;break ties.&quot; lexicographical() Returns an Ordering that orders iterables lexicographically by their elements. onResultOf(Function) Returns an Ordering which orders values by applying the function to them and then comparing the results using the original Ordering.&#xA;&#xA;For example, let's say you want a comparator for the class...&#xA;class Foo {&#xA;  @Nullable String sortedBy;&#xA;  int notSortedBy;&#xA;}&#xA;...that can deal with null values of sortedBy. Here is a solution built atop the chaining methods:&#xA;Ordering&lt;Foo> ordering = Ordering.natural().nullsFirst().onResultOf(new Function&lt;Foo, String>() {&#xA;  public String apply(Foo foo) {&#xA;    return foo.sortedBy;&#xA;  }&#xA;});&#xA;When reading a chain of Ordering calls, work &quot;backward&quot; from right to left. The example above orders Foo instances by looking up their sortedBy field values, first moving any null sortedBy values to the top and then sorting the remaining values by natural string ordering. This backward order arises because each chaining call is &quot;wrapping&quot; the previous Ordering into a new one.&#xA;(Exception to the &quot;backwards&quot; rule: For chains of calls to compound, read from left to right. To avoid confusion, avoid intermixing compound calls with other chained calls.)&#xA;Chains longer than a few calls can be difficult to understand. We recommend limiting chaining to about three calls as in the example above. Even then, you may wish to simplify the code by separating out intermediate objects such as Function instances:&#xA;Ordering&lt;Foo> ordering = Ordering.natural().nullsFirst().onResultOf(sortKeyFunction);&#xA;Application&#xA;Guava provides a number of methods to manipulate or examine values or collections using the ordering. We list some of the most popular here.&#xA;Method Description See also greatestOf(Iterable iterable, int k) Returns the k greatest elements of the specified iterable, according to this ordering, in order from greatest to least. Not necessarily stable. leastOf isOrdered(Iterable) Tests if the specified Iterable is in nondecreasing order according to this ordering. isStrictlyOrdered sortedCopy(Iterable) Returns a sorted copy of the specified elements as a List. immutableSortedCopy min(E, E) Returns the minimum of its two arguments according to this ordering. If the values compare as equal, the first argument is returned. max(E, E) min(E, E, E, E...) Returns the minimum of its arguments according to this ordering. If there are multiple least values, the first is returned. max(E, E, E, E...) min(Iterable) Returns the minimum element of the specified Iterable. Throws a NoSuchElementException if the Iterable is empty. max(Iterable), min(Iterator), max(Iterator)&#xA; owner: cpov...@google.com&#xA; last update: Jun 27, 2013"/>
    <pages name="ReleaseHistory" body="summary: List of releases&#xA;Release Date javadoc API changes r01*% 2009-09-15 javadoc r02* 2010-01-04 javadoc r03 2010-04-09 javadoc r04 2010-04-27 javadoc API changes r05 2010-05-28 javadoc API changes r06 2010-07-07 javadoc API changes Release07 2010-09-22 javadoc API changes Release08 2011-01-27 javadoc API changes Release09 2011-04-07 javadoc API changes Release10 2011-09-28, 2011-10-10 javadoc API changes Release11 2011-12-18, 2012-01-09, 2012-02-22 javadoc API changes Release12 2012-04-30, 2012-07-10 javadoc API changes Release13 2012-08-03, 2012-08-28 javadoc API changes Release14 2013-02-25, 2013-03-15 javadoc API changes Release15 2013-09-06 javadoc API changes Release16 2014-01-17, 2014-02-03 javadoc API changes Release17 2014-04-22 javadoc API changes Release18 2014-08-25 javadoc API changes&#xA;&#xA;* source release only&#xA;% did not include Google Collections&#xA;Note: Releases 1 through 11 required JDK 1.5. Releases 12 and on require JDK 1.6.&#xA; owner: cgdecker@google.com&#xA; last update: Aug 25, 2014"/>
    <pages name="CollectionHelpersExplained" body="summary: Making it easier to extend collections tools yourself, explained.&#xA;Introduction&#xA;Sometimes you need to write your own collection extensions. Perhaps you want to add special behavior when elements are added to a list, or you want to write an Iterable that's actually backed by a database query. Guava provides a number of utilities to make these tasks easier for you, and for us. (We are, after all, in the business of extending the collections framework ourselves.)&#xA;Forwarding Decorators&#xA;For all the various collection interfaces, Guava provides Forwarding abstract classes to simplify using the decorator pattern.&#xA;The Forwarding classes define one abstract method, delegate(), which you should override to return the decorated object. Each of the other methods delegate directly to the delegate: so, for example, ForwardingList.get(int) is simply implemented as delegate().get(int).&#xA;By subclassing ForwardingXXX and implementing the delegate() method, you can override only selected methods in the targeted class, adding decorated functionality without having to delegate every method yourself.&#xA;Additionally, many methods have a standardMethod implementation which you can use to recover expected behavior, providing some of the same benefits as e.g. extending AbstractList or the other skeleton classes in the JDK.&#xA;Let's do an example. Suppose you wanted to decorate a List so that it logged all elements added to it. Of course, we want to log elements no matter which method is used to add them -- add(int, E), add(E), or addAll(Collection) -- so we have to override all of these methods.&#xA;class AddLoggingList&lt;E> extends ForwardingList&lt;E> {&#xA;  final List&lt;E> delegate; // backing list&#xA;  @Override protected List&lt;E> delegate() {&#xA;    return delegate;&#xA;  }&#xA;  @Override public void add(int index, E elem) {&#xA;    log(index, elem);&#xA;    super.add(index, elem);&#xA;  }&#xA;  @Override public boolean add(E elem) {&#xA;    return standardAdd(elem); // implements in terms of add(int, E)&#xA;  }&#xA;  @Override public boolean addAll(Collection&lt;? extends E> c) {&#xA;    return standardAddAll(c); // implements in terms of add&#xA;  }&#xA;}&#xA;Remember, by default, all methods forward directly to the delegate, so overriding ForwardingMap.put will not change the behavior of ForwardingMap.putAll. Be careful to override every method whose behavior must be changed, and make sure that your decorated collection satisfies its contract.&#xA;Generally, most methods provided by the abstract collection skeletons like AbstractList are also provided as standard implementations in the Forwarding decorators.&#xA;Interfaces that provide special views sometimes provide Standard implementations of those views. For example, ForwardingMap provides StandardKeySet, StandardValues, and StandardEntrySet classes, each of which delegate their methods to the decorated map whenever possible, or otherwise, they leave methods that can't be delegated as abstract.&#xA;Interface Forwarding Decorator Collection ForwardingCollection List ForwardingList Set ForwardingSet SortedSet ForwardingSortedSet Map ForwardingMap SortedMap ForwardingSortedMap ConcurrentMap ForwardingConcurrentMap Map.Entry ForwardingMapEntry Queue ForwardingQueue Iterator ForwardingIterator ListIterator ForwardingListIterator Multiset ForwardingMultiset Multimap ForwardingMultimap ListMultimap ForwardingListMultimap SetMultimap ForwardingSetMultimap&#xA;&#xA;PeekingIterator&#xA;Sometimes, the normal Iterator interface isn't enough.&#xA;Iterators supports the method Iterators.peekingIterator(Iterator), which wraps an Iterator and returns a PeekingIterator, a subtype of Iterator that lets you peek() at the element that will be returned by the next call to next().&#xA;Note: the PeekingIterator returned by Iterators.peekingIterator does not support remove() calls after a peek().&#xA;Let's do an example: copying a List while eliminating consecutive duplicate elements.&#xA;List&lt;E> result = Lists.newArrayList();&#xA;PeekingIterator&lt;E> iter = Iterators.peekingIterator(source.iterator());&#xA;while (iter.hasNext()) {&#xA;  E current = iter.next();&#xA;  while (iter.hasNext() &amp;&amp; iter.peek().equals(current)) {&#xA;    // skip this duplicate element&#xA;    iter.next();&#xA;  }&#xA;  result.add(current);&#xA;}&#xA;The traditional way to do this involves keeping track of the previous element, and falling back under certain conditions, but that's a tricky and bug-prone business. PeekingIterator is comparatively straightforward to understand and use.&#xA;AbstractIterator&#xA;Implementing your own Iterator? AbstractIterator can make your life easier.&#xA;It's easiest to explain with an example. Let's say we wanted to wrap an iterator so as to skip null values.&#xA;public static Iterator&lt;String> skipNulls(final Iterator&lt;String> in) {&#xA;  return new AbstractIterator&lt;String>() {&#xA;    protected String computeNext() {&#xA;      while (in.hasNext()) {&#xA;        String s = in.next();&#xA;        if (s != null) {&#xA;          return s;&#xA;        }&#xA;      }&#xA;      return endOfData();&#xA;    }&#xA;  };&#xA;}&#xA;You implement one method, computeNext(), that just computes the next value. When the sequence is done, just return endOfData() to mark the end of the iteration.&#xA;Note: AbstractIterator extends UnmodifiableIterator, which forbids the implementation of remove(). If you need an iterator that supports remove(), you should not extend AbstractIterator.&#xA;AbstractSequentialIterator&#xA;Some iterators are more easily expressed in other ways. AbstractSequentialIterator provides another way of expressing an iteration.&#xA;&#xA;   Iterator&lt;Integer> powersOfTwo = new AbstractSequentialIterator&lt;Integer>(1) { // note the initial value!&#xA;     protected Integer computeNext(Integer previous) {&#xA;       return (previous == 1 &lt;&lt; 30) ? null : previous * 2;&#xA;     }&#xA;   };&#xA;Here, we implement the method computeNext(T), which accepts the previous value as an argument.&#xA;Note that you must additionally pass an initial value, or null if the iterator should end immediately. Note that computeNext assumes that a null value implies the end of iteration -- AbstractSequentialIterator cannot be used to implement an iterator which may return null.&#xA; owner: wasserman.louis&#xA; last update: Jan 29, 2013"/>
    <pages name="PreconditionsExplained" body="summary: Using Guava's precondition checking utilities, explained.&#xA;Preconditions&#xA;Guava provides a number of precondition checking utilities. We strongly recommend importing these statically. (How to do this easily in Eclipse.)&#xA;Each method has three variants:&#xA;No extra arguments. Any exceptions are thrown without error messages. An extra Object argument. Any exception is thrown with the error message object.toString(). An extra String argument, with an arbitrary number of additional Object arguments. This behaves something like printf, but for GWT compatibility and efficiency, it only allows %s indicators. Example:&#xA;checkArgument(i >= 0, &quot;Argument was %s but expected nonnegative&quot;, i);&#xA;checkArgument(i &lt; j, &quot;Expected i &lt; j, but %s > %s&quot;, i, j);&#xA;&#xA;Signature (not including extra args) Description Exception thrown on failure checkArgument(boolean) Checks that the boolean is true. Use for validating arguments to methods. IllegalArgumentException checkNotNull(T) Checks that the value is not null. Returns the value directly, so you can use checkNotNull(value) inline. NullPointerException checkState(boolean) Checks some state of the object, not dependent on the method arguments. For example, an Iterator might use this to check that next has been called before any call to remove. IllegalStateException checkElementIndex(int index, int size) Checks that index is a valid element index into a list, string, or array with the specified size. An element index may range from 0 inclusive to size exclusive. You don't pass the list, string, or array directly; you just pass its size.&#xA;Returns index. IndexOutOfBoundsException checkPositionIndex(int index, int size) Checks that index is a valid position index into a list, string, or array with the specified size. A position index may range from 0 inclusive to size inclusive. You don't pass the list, string, or array directly; you just pass its size.&#xA;Returns index. IndexOutOfBoundsException checkPositionIndexes(int start, int end, int size) Checks that [start, end) is a valid sub range of a list, string, or array with the specified size. Comes with its own error message. IndexOutOfBoundsException&#xA;&#xA;We preferred rolling our own preconditions checks over e.g. the comparable utilities from Apache Commons for a few reasons. Piotr Jagielski discusses why he prefers our utilities, but briefly:&#xA;After static imports, the Guava methods are clear and unambiguous. checkNotNull makes it clear what is being done, and what exception will be thrown. checkNotNull returns its argument after validation, allowing simple one-liners in constructors: this.field = checkNotNull(field). Simple, varargs &quot;printf-style&quot; exception messages. (This advantage is also why we recommend continuing to use checkNotNull over Objects.requireNonNull introduced in JDK 7.)&#xA;We recommend that you split up preconditions into distinct lines, which can help you figure out which precondition failed while debugging. Additionally, you should provide helpful error messages, which is easier when each check is on its own line.&#xA; owner: wasserman.louis&#xA; last update: Apr 23, 2012"/>
    <pages name="ApacheCommonCollectionsEquivalents" body="summary: Know how to do something in Common Collections but not in Guava?&#xA;CollectionUtils (source)&#xA;&#xA;void *addAll*(Collection, Enumeration)&#xA;Iterators.addAll(collection, Iterators.forEnumeration(enumeration))void *addAll*(Collection, Iterator)&#xA;Iterators.addAll(collection, iterator)void *addAll*(Collection, Object[])&#xA;Collections.addAll(collection, array) (JDK)boolean *addIgnoreNull*(Collection, Object)&#xA;if (o != null) { collection.add(o); }int *cardinality*(Object, Collection)&#xA;Iterables.frequency(collection, object)Collection *collect*(Collection, Transformer)&#xA;newArrayList(Collections2.transform(input, function))Collection *collect*(Collection, Transformer, Collection)&#xA;output.addAll(Collections2.transform(input, function))Collection *collect*(Iterator, Transformer)&#xA;newArrayList(Iterators.transform(input, function))Collection *collect*(Iterator, Transformer, Collection)&#xA;Iterators.addAll(output, Iterators.transform(input, function))boolean *containsAny*(Collection coll1, Collection coll2)&#xA;!Collections.disjoint(coll1, coll2) (JDK)int *countMatches*(Collection, Predicate)&#xA;Iterables.size(Iterables.filter(collection, predicate))Collection *disjunction*(Collection, Collection)&#xA;Sets.symmetricDifference(set1, set2)boolean *exists*(Collection, Predicate)&#xA;Iterables.any(collection, predicate)void *filter*(Collection, Predicate)&#xA;Iterables.removeIf(collection, not(predicate)) (see also Iterables.transform, which creates a view instead of mutating the input)Object *find*(Collection, Predicate)&#xA;Iterables.find(collection, predicate)void *forAllDo*(Collection, Closure)&#xA;for (Object o : collection) { closure.execute(o); }Object *get*(Object, int)&#xA;Iterables.get(o, index), supplemented with calls to entrySet(), forEnumeration(), etc.Map *getCardinalityMap*(Collection)&#xA;ImmutableMultiset.copyOf(collection)Object *index*(Object, int)&#xA;Iterables.get(o, index), supplemented with calls to keySet(), forEnumeration(), etc.Object *index*(Object, Object)&#xA;Iterables.get(o, index), supplemented with calls to entrySet(), forEnumeration(), etc.Collection *intersection*(Collection, Collection)&#xA;Sets/Multisets.intersection(a, b)boolean *isEmpty*(Collection)&#xA;collection == null || collection.isEmpty()boolean *isEqualCollection*(Collection, Collection)&#xA;If both are Sets or Multisets, use equals(); otherwise ImmutableMultiset.copyOf(a).equals(ImmutableMultiset.copyOf(b)boolean *isFull*(Collection)&#xA;No equivalent--no BoundedCollection type.boolean *isNotEmpty*(Collection)&#xA;collection != null &amp;&amp; !collection.isEmpty()boolean *isProperSubCollection*(Collection, Collection)&#xA;No equivalent--check that a.size() &lt; b.size() and then use the check described below.boolean *isSubCollection*(Collection, Collection)&#xA;Multisets.containsOccurrences(ImmutableMultiset.copyOf(coll1), ImmutableMultiset.copyOf(coll2))int *maxSize*(Collection)&#xA;No equivalent--no BoundedCollection type.Collection *predicatedCollection*(Collection, Predicate)&#xA;Constraints.constrainedCollection/List/Set/etc.Collection *removeAll*(Collection, Collection)&#xA;newArrayList(Iterables.filter(collection, Predicates.not(Predicates.in(remove))))Collection *retainAll*(Collection, Collection)&#xA;newArrayList(Iterables.filter(collection, Predicates.in(retain)))void *reverseArray*(Object[])&#xA;Lists.reverse(Arrays.asList(array)) (returns an inverse List view without modifying array)Collection *select*(Collection, Predicate)&#xA;newArrayList(Iterables.filter(collection, predicate))void *select*(Collection, Predicate, Collection)&#xA;Iterables.addAll(output, Iterables.filter(input, predicate))Collection *selectRejected*(Collection, Predicate)&#xA;newArrayList(Iterables.filter(collection, Predicates.not(predicate)))void *selectRejected*(Collection, Predicate, Collection)&#xA;Iterables.addAll(output, Iterables.filter(input, Predicates.not(predicate)))int *size*(Object)&#xA;Collection/Map.size(), array.length, Iterables/Iterators.size (with forEnumeration() if necessary)boolean *sizeIsEmpty*(Object)&#xA;Collection/Map.isEmpty(), array.length == 0, Iterables/Iterators.isEmpty (with forEnumeration() if necessary)Collection *subtract*(Collection, Collection)&#xA;No equivalent--create an ArrayList containing a and then call remove on it for each element in b.Collection *synchronizedCollection*(Collection)&#xA;Collections.synchronizedCollection(collection) (JDK)void *transform*(Collection, Transformer)&#xA;No equivalent for transforming a Collection in place... not very useful. Prefer transformed views (Lists/Collections2.transform) or copies of them.Collection *transformedCollection*(Collection, Transformer)&#xA;No equivalent for transforming Objects that are added to a Collection... a ForwardingCollection could easily handle this, though.Collection *typedCollection*(Collection, Class)&#xA;Collections.checkedCollection/Set/List/etc. (JDK)Collection *union*(Collection, Collection)&#xA;Sets.union(a, b)Collection *unmodifiableCollection*(Collection)&#xA;Collections.unmodifiableCollection/Set/List/etc. (JDK) Consider ImmutableCollection types if you want immutability.&#xA;&#xA;Additions&#xA;I can't find a way to make the Wiki world-writable, so post any additions as comments. I'll check for new ones every so often and approve their authors as Wiki editors.&#xA; owner: wasserman.louis&#xA; last update: Jul 2, 2012"/>
    <pages name="BridgeMethodInjectorOpportunities" body="summary: Where might we use the Bridge Method Injector in Guava?&#xA;Where might we use the Bridge Method Injector in Guava?&#xA;We're not yet sure whether we want to use it at all, but part of making that decision will be having a list of possible uses in front of us.&#xA;Note that any of these changes might introduce source incompatibilities (e.g., for people who call ImmutableSet.of(immediateFuture(...))).&#xA;Iterables.(various) -> FluentIterable ImmutableMultiset.elementSet -> ImmutableSet Iterators.forArray, singletonIterator -> UnmodifiableListIterator Splitter.split -> List (or FluentIterable if we could depend on collect from base) Sets.filter (etc.) -> SetView Futures.immediate*Future -> ListenableScheduledFuture?&#xA; owner: cpov...@google.com&#xA; last update: Jul 12, 2013"/>
    <pages name="HowToContribute" body="summary: Instructions for how to contribute code to Guava&#xA;Contributing to Guava&#xA;Thank you so much for wanting to contribute to Guava! There are a couple ways to help out.&#xA;Evangelize!&#xA;Just tell people about Guava. We believe that a bigger, more involved community makes for a better library, and that better libraries make the world a better place. We can always use more feedback.&#xA;Bug Reports&#xA;If you come across a bug in Guava, please file a bug report. Guava gets used in production at Google, so it's rare for bugs to survive very long without us noticing, but bugs do happen.&#xA;Warning us of a bug is possibly the single most valuable contribution you can make to Guava. If you encounter a bug that hasn't already been filed, please file a report with an SSCCE demonstrating the bug.&#xA;If you think something might be a bug, but you're not sure, ask on StackOverflow or on guava-discuss.&#xA;Join Discussions&#xA;There's no Guava community without active, public discussions. Chime in with your opinion of feature requests; say what you think about a potential change.&#xA;In particular, a lot of what we look for in feature requests is a variety of real-world use cases for a proposed feature. Maybe we can't think of an application for some feature -- but you came across one just yesterday, or this new feature would make your current project massively easier.&#xA;Join guava-discuss for general discussion about Guava, and guava-issues to follow Guava issues, feature requests, and discussions.&#xA;Feature Requests&#xA;Filing feature requests is one of the most popular ways to contribute to Guava.&#xA;Be aware, though: most feature requests are not accepted, not even if they're suggested by a full-time Guava team member. The feedback from our users has said that they really appreciate Guava's high power-to-weight ratio. It's important to us to keep Guava as easy to pick up and understand as we can. That means boiling features down to compact but powerful abstractions, and controlling feature bloat carefully.&#xA;Guava's main yardstick for evaluating features proposed features can be summed up as utility times ubiquity.&#xA;Utility: compare with alternatives&#xA;There is always some alternative to adding this new feature to Guava, even if it's just forking Guava yourself.&#xA;We want to see that new features have some significant advantage over the alternatives. These advantages can take many forms, but taking the time to discuss them in detail will make it much clearer why this feature should be added to Guava.&#xA;What helps the most is to have the following laid out clearly:&#xA;What are you trying to do? What's the best code you can write to accomplish that using only today's Guava? What would that same code look like if we added your feature?&#xA;Having the two approaches to a use case side by side can make it much easier to pick out the differences between them.&#xA;Additionally, it's very useful to us if you can provide a &quot;straw API&quot; -- what the method signatures would look like, for example, even if the method and class names are still in flux. This can make the feature you're suggesting much clearer to us.&#xA;Ubiquity: provide concrete use cases&#xA;Did you actually encounter the need for this feature in a real-world scenario, or is it just a feature that seems like a sensible addition to Guava?&#xA;Before new features get added to Guava, we really want to be sure that it's a use case that actually comes up in the real world. We want to hear the real-world use case so the community can discuss and debate whether this feature is actually the best way to address the real use case, or whether or not a different abstraction might be appropriate.&#xA;It's okay that you can't always give us complete context on a use case. Not all of you are at liberty to discuss the details of what you're working on.&#xA;But Guava aims to provide features that are useful across boundaries of projects, companies, or even industries -- utilities useful for a sizable proportion of all Java programmers everywhere. If you can give enough detail that any of us can imagine coming across in our own work, that's extremely helpful in studying how broadly useful the feature will be.&#xA;Code Contributions&#xA;Contributing code is one of the more difficult ways to contribute to Guava, and is almost never what the project really needs most.&#xA;New Features&#xA;Is there some feature request that you'd like to code up yourself? Is there a feature you asked for yourself that you'd like to code?&#xA;Here's how to contribute code for a new feature to Guava. (A &quot;new feature&quot; is any change to Guava that exposes new methods, classes, fields, or interfaces, or changes method signatures.)&#xA;File a feature request, if you haven't already. Discuss the feature request until it is marked Accepted. Hammer out the API, if necessary. Method and class names can still be in flux, but method signatures (arguments and return type) should be agreed on. Comment on the issue, saying that you'd like to implement it. Ask for a reviewer to volunteer. Sign the Google Individual CLA before sending us any code! (If you're contributing on behalf of your company, the company must have signed the Google Corporate CLA instead.) Implement the change. Get your change through the (difficult) Guava code review process. Expect to spend as much time on documentation and tests as you do on the source code. Don't get discouraged -- this always takes many rounds. Your reviewer will import the change into Google's source control system, and your change will get mirrored out in a day or two. Congratulations!&#xA;Note: We know it's tempting to submit code before the feature is accepted, but this is not always a good use of your time. First, the community has to discuss whether the feature is a good fit for Guava, then the API gets hammered out, and then code happens. Sending in code won't help a feature request get accepted.&#xA;If someone else has already started implementing a feature, they'll you know when you request a reviewer. Even so, volunteers are always appreciated to help review and discuss new features.&#xA;Optimizations, Tests, and Documentation&#xA;The overwhelming majority of changes to Guava don't add new features at all. Optimizations, tests, documentation, refactorings -- these are all part of making Guava meet the highest standards of code quality and usability.&#xA;Contributing improvements in these areas is much easier, and much less of a hassle, than contributing code for new features.&#xA;Just email the guava-discuss mailing list with a summary of the improvements you'd like to make and why, and ask for a reviewer. If the community agrees that it's a good change to make, code up the change and send it to your reviewer as above. There's no need to write a feature request or anything.&#xA;Getting Started&#xA;Are you ready to start coding? See this page for instructions on how to get Guava checked out and building, and how to send in code for review.&#xA; owner: kevinb@google.com&#xA; last update: Jul 27, 2014"/>
    <pages name="ContributorSetUp" body="summary: How to get set up to contribute to Guava.&#xA;Setting Up Your Clone&#xA;TODO: pictures&#xA;TODO: add current as-accurate-as-possible Eclipse formatter download&#xA;Eventually, you'll be dealing with three clones of the Guava repository:&#xA;The original repository, at https://code.google.com/p/guava-libraries/ Your online repository, for the Guava team to pull from. Your local repository, on your machine to develop on.&#xA;If you want to host your online repository on Google Code, then at the bottom of this page, create a clone. This is on Google Code, and it's easiest for the Guava team to pull from.&#xA;Assuming you're using Eclipse, follow these instructions to get a Guava clone working with both Git and Maven:&#xA;Make sure you have the EGit and m2eclipse plugins installed in Eclipse. Open the &quot;Git Repositories&quot; perspective. On the &quot;Git Repositories&quot; tab, click the &quot;Clone a Git Repository&quot; button. Paste https://code.google.com/p/guava-libraries/ into the URI, and give your googlecode.com username and password. Check out all branches of the source.&#xA;&#xA;You should now have a local clone of Guava on your machine, albeit it's not a Java or Maven project. We now want it to get built.&#xA;Run mvn install antrun:run enforcer:enforce, if those plugins are not already installed. In Eclipse, use &quot;File/Import&quot;, and choose &quot;Maven/Existing Maven Projects&quot;. Designate the root directory of your repository -- typically ~/git/guava-libraries. Select the root pom.xml, labeled guava-parent. If you encounter Maven problems, choose &quot;Resolve All Later.&quot;&#xA;You're almost done! You should now have several projects in Eclipse:&#xA;guava-parent, the &quot;root&quot; project, with which you'll do all your interacting with Git: commits, pushes, pulls, rebases, checkouts, etc. guava: the main source of Guava. guava-gwt: the GWT-compatible supersource that helps make Guava GWT-compatible. guava-testlib: the test suite builders that assemble customized, exhaustive test suites for collection implementations. guava-tests: the tests for Guava.&#xA;Right-click on guava-parent, and go to Team/Share Project. Select &quot;Git,&quot; and choose &quot;Use repository in parent folder of project,&quot; which will tell Eclipse to use the preexisting repository that already has all the Guava history and the connection to the remote master branch.&#xA;Now you have the Guava source checked out into Eclipse, and working with Maven! Yay!&#xA;Build and Test&#xA;TODO: fill this in&#xA;mvn clean install&#xA;Pass -Dmaven.test.skip=true to skip tests.&#xA;Code Reviews&#xA;The Guava team uses http://codereview.appspot.com to do code reviews for external submissions. (It's inspired by the Google-internal code review system.)&#xA;First, you'll need to get your Google account set up at http://codereview.appspot.com. Next, follow the instructions here. Once you've downloaded upload.py, the usual command line to upload a change is&#xA;upload.py --rev master -r &lt;reviewer email> --send_mail&#xA;from your root Guava directory -- typically ~/git/guava-libraries/.&#xA;Once you get an LGTM from your reviewer, send your reviewer a link to your change, typically in the form of a Guava clone and the branch with your change. (This is typically the Google Code clone, but it can also be hosted on e.g. GitHub.) Your reviewer will make sure the change is imported internally and then mirrored back out.&#xA;The first time you submit code to Guava, you may need to e-sign a SLA. It's quite painless. Ask your reviewer for details once you receive an LGTM.&#xA; owner: cpov...@google.com&#xA; last update: Aug 1, 2012"/>
    <pages name="ClosingResourcesExplained" body="summary: Overview of alternatives for closing Closeable resources.&#xA;Closing Resources&#xA;Closing Closeable resources properly when finished with them is important for ensuring that socket connections are closed, file descriptors are not leaked, etc. as well as for ensuring correct program behavior. Pre-JDK7, it's extremely difficult to do properly, with many pitfalls that may not be immediately obvious. It's notoriously almost never done correctly, even within the JDK itself.&#xA;Here's an example of some typical code to open, use and close an InputStream in JDK6:&#xA;InputStream in = null;&#xA;try {&#xA;  in = openInputStream();&#xA;  // do something with in&#xA;} finally {&#xA;  if (in != null) {&#xA;    in.close();&#xA;  }&#xA;}&#xA;This code, while far more complicated than we'd like, is about as simple as you can get using standard JDK APIs. Unfortunately, even it has a problem: if an exception is thrown inside the try block and then an exception is thrown when calling in.close() in the finally block, the exception from the try block will be swallowed by the exception thrown in finally and you won't see the details of that error or even get any indication that it occurred at all!&#xA;It gets much, much worse if there are two streams that must be open at the same time:&#xA;InputStream in = null;&#xA;try {&#xA;  in = openInputStream();&#xA;  OutputStream out = null;&#xA;  try {&#xA;    out = openOutputStream();&#xA;    // do something with in and out&#xA;  } finally {&#xA;    if (out != null) {&#xA;      out.close();&#xA;    }&#xA;  }&#xA;} finally {&#xA;  if (in != null) {&#xA;    in.close();&#xA;  }&#xA;}&#xA;The nested try/finally blocks here are extremely unreadable, and the code still has the same issues with exceptions as above.&#xA;Input vs. output streams&#xA;There's an important difference between input and output streams when it comes to closing resources.&#xA;With input stream, an error that occurs when attempting to close the stream is unlikely to be significant to your program: you're done with it, you've read everything you need.&#xA;With output streams, exceptions thrown when closing the stream must be treated as just as significant as exceptions thrown when actually using the stream. The reason for this is that output streams may buffer data that is written to them and need to flush buffered data to the underlying output sink when close() is called. In other words, the close() call may be triggering an actual write to a file or other sink, so an exception thrown from that call may indicate actual failure to complete the intended write operations.&#xA;Solutions&#xA;try-with-resources&#xA;If you're using JDK7, this is easy: use try-with-resources. Here's an example of opening and closing multiple resources using try-with-resources:&#xA;try (InputStream in = openInputStream();&#xA;     OutputStream out = openOutputStream()) {&#xA;  // do stuff with in and out&#xA;}&#xA;Both streams will automatically be closed at the end of the try block, and if multiple exceptions are thrown, the first exception thrown will suppress the other two, and the stack traces of all the exceptions will be present in the single exception thrown from the try block. It's easy, it fixes all the problems, use it!&#xA;Sources and Sinks&#xA;ByteSource and CharSource represent readable sources of binary and character data, respectively. ByteSink and CharSink represent writable sinks for binary and character data, respectively. All should be able to open multiple independent streams (e.g. InputStream or Writer) for reading from or writing to them.&#xA;When possible, creating an implementation of one of these types (or using a provided implementation such as Files.asByteSource(File)) allows you to circumvent the problem of opening and closing streams entirely by allowing you to use methods on those classes that handle opening and closing the resource for you. For example, you can copy the contents of a File to some ByteSink using the following:&#xA;ByteSink sink = ...&#xA;Files.asByteSource(file).copyTo(sink);&#xA;Closer&#xA;Closer is a new class added to Guava in release 14.0. It's intended as a poor man's try-with-resources block for code that must compile and run under JDK6. Here's an example of using it:&#xA;Closer closer = Closer.create();&#xA;try {&#xA;  InputStream in = closer.register(openInputStream());&#xA;  OutputStream out = closer.register(openOutputStream());&#xA;  // do stuff with in and out&#xA;} catch (Throwable e) { // must catch Throwable&#xA;  throw closer.rethrow(e);&#xA;} finally {&#xA;  closer.close();&#xA;}&#xA;Calling close() on the Closer will safely close all Closeable objects that have been registered with it. When running under Java 7, it even uses the same mechanism for suppressing additional exceptions that try-with-resources uses, producing behavior that should be identical. Do note that when using Closer, it's very important to follow the prescribed usage pattern: any Throwable thrown from the block where the Closeable resources are used must be caught and rethrown through Closer's rethrow method before calling closer.close(). Also note that if you wish to catch any exception thrown from this whole block of code, you should wrap the entire thing in another try block.&#xA; owner: cgdecker@google.com&#xA; last update: Jan 29, 2013"/>
    <pages name="StringsExplained" body="summary: Guava's string utilities, explained&#xA;Joiner&#xA;Joining together a sequence of strings with a separator can be unnecessarily tricky -- but it shouldn't be. If your sequence contains nulls, it can be even harder. The fluent style of Joiner makes it simple.&#xA;Joiner joiner = Joiner.on(&quot;; &quot;).skipNulls();&#xA;return joiner.join(&quot;Harry&quot;, null, &quot;Ron&quot;, &quot;Hermione&quot;);&#xA;returns the string &quot;Harry; Ron; Hermione&quot;. Alternately, instead of using skipNulls, you may specify a string to use instead of null with useForNull(String).&#xA;You may also use Joiner on objects, which will be converted using their toString() and then joined.&#xA;Joiner.on(&quot;,&quot;).join(Arrays.asList(1, 5, 7)); // returns &quot;1,5,7&quot;&#xA;Warning: joiner instances are always immutable. The joiner configuration methods will always return a new Joiner, which you must use to get the desired semantics. This makes any Joiner thread safe, and usable as a static final constant.&#xA;Splitter&#xA;The built in Java utilities for splitting strings can have some quirky behaviors. For example, String.split silently discards trailing separators, and StringTokenizer respects exactly five whitespace characters and nothing else.&#xA;Quiz: &quot;,a,,b,&quot;.split(&quot;,&quot;) returns...&#xA;&quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;&quot; null, &quot;a&quot;, null, &quot;b&quot;, null &quot;a&quot;, null, &quot;b&quot; &quot;a&quot;, &quot;b&quot; None of the above&#xA;&#xA;The correct answer is none of the above: &quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;. Only trailing empty strings are skipped. What is this I don't even.&#xA;Splitter allows complete control over all this confusing behavior using a reassuringly straightforward fluent pattern.&#xA;Splitter.on(',')&#xA;       .trimResults()&#xA;       .omitEmptyStrings()&#xA;       .split(&quot;foo,bar,,   qux&quot;);&#xA;returns an Iterable&lt;String> containing &quot;foo&quot;, &quot;bar&quot;, &quot;qux&quot;. A Splitter may be set to split on any Pattern, char, String, or CharMatcher.&#xA;Base Factories&#xA;Method Description Example Splitter.on(char) Split on occurrences of a specific, individual character. Splitter.on(';') Splitter.on(CharMatcher) Split on occurrences of any character in some category. Splitter.on(CharMatcher.BREAKING_WHITESPACE)&#xA;Splitter.on(CharMatcher.anyOf(&quot;;,.&quot;))Splitter.on(String) Split on a literal String. Splitter.on(&quot;, &quot;) Splitter.on(Pattern)&#xA;Splitter.onPattern(String) Split on a regular expression. Splitter.onPattern(&quot;\r?\n&quot;) Splitter.fixedLength(int) Splits strings into substrings of the specified fixed length. The last piece can be smaller than length, but will never be empty. Splitter.fixedLength(3)&#xA;&#xA;Modifiers&#xA;Method Description Example omitEmptyStrings() Automatically omits empty strings from the result. Splitter.on(',').omitEmptyStrings().split(&quot;a,,c,d&quot;) returns &quot;a&quot;, &quot;c&quot;, &quot;d&quot; trimResults() Trims whitespace from the results; equivalent to trimResults(CharMatcher.WHITESPACE). Splitter.on(',').trimResults().split(&quot;a, b, c, d&quot;) returns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; trimResults(CharMatcher) Trims characters matching the specified CharMatcher from results. Splitter.on(',').trimResults(CharMatcher.is('_')).split(&quot;_a ,_b_ ,c__&quot;) returns &quot;a &quot;, &quot;b_ &quot;, &quot;c&quot;. limit(int) Stops splitting after the specified number of strings have been returned. Splitter.on(',').limit(3).split(&quot;a,b,c,d&quot;) returns &quot;a&quot;, &quot;b&quot;, &quot;c,d&quot;&#xA;&#xA;TODO: Map splitters&#xA;If you wish to get a List, just use Lists.newArrayList(splitter.split(string)) or the like.&#xA;Warning: splitter instances are always immutable. The splitter configuration methods will always return a new Splitter, which you must use to get the desired semantics. This makes any Splitter thread safe, and usable as a static final constant.&#xA;&#xA;CharMatcher&#xA;In olden times, our StringUtil class grew unchecked, and had many methods like these: allAscii collapse collapseControlChars collapseWhitespace indexOfChars lastIndexNotOf numSharedChars removeChars removeCrLf replaceChars retainAllChars strip stripAndCollapse stripNonDigits&#xA;&#xA;They represent a partial cross product of two notions:&#xA;what constitutes a &quot;matching&quot; character? what to do with those &quot;matching&quot; characters?&#xA;To simplify this morass, we developed CharMatcher.&#xA;Intuitively, you can think of a CharMatcher as representing a particular class of characters, like digits or whitespace. Practically speaking, a CharMatcher is just a boolean predicate on characters -- indeed, CharMatcher implements Predicate&lt;Character> -- but because it is so common to refer to &quot;all whitespace characters&quot; or &quot;all lowercase letters,&quot; Guava provides this specialized syntax and API for characters.&#xA;But the utility of a CharMatcher is in the operations it lets you perform on occurrences of the specified class of characters: trimming, collapsing, removing, retaining, and much more. An object of type CharMatcher represents notion 1: what constitutes a matching character? It then provides many operations answering notion 2: what to do with those matching characters? The result is that API complexity increases linearly for quadratically increasing flexibility and power. Yay!&#xA;String noControl = CharMatcher.JAVA_ISO_CONTROL.removeFrom(string); // remove control characters&#xA;String theDigits = CharMatcher.DIGIT.retainFrom(string); // only the digits&#xA;String spaced = CharMatcher.WHITESPACE.trimAndCollapseFrom(string, ' ');&#xA;  // trim whitespace at ends, and replace/collapse whitespace into single spaces&#xA;String noDigits = CharMatcher.JAVA_DIGIT.replaceFrom(string, &quot;*&quot;); // star out all digits&#xA;String lowerAndDigit = CharMatcher.JAVA_DIGIT.or(CharMatcher.JAVA_LOWER_CASE).retainFrom(string);&#xA;  // eliminate all characters that aren't digits or lowercase&#xA;Note: CharMatcher deals only with char values; it does not understand supplementary Unicode code points in the range 0x10000 to 0x10FFFF. Such logical characters are encoded into a String using surrogate pairs, and a CharMatcher treats these just as two separate characters.&#xA;Obtaining CharMatchers&#xA;Many needs can be satisfied by the provided CharMatcher constants:&#xA;ANY NONE WHITESPACE BREAKING_WHITESPACE INVISIBLE DIGIT JAVA_LETTER JAVA_DIGIT JAVA_LETTER_OR_DIGIT JAVA_ISO_CONTROL JAVA_LOWER_CASE JAVA_UPPER_CASE ASCII SINGLE_WIDTH&#xA;&#xA;Other common ways to obtain a CharMatcher include:&#xA;anyOf(CharSequence) Specify all the characters you wish matched. For example, CharMatcher.anyOf(&quot;aeiou&quot;) matches lowercase English vowels. is(char) Specify exactly one character to match.inRange(char, char) Specify a range of characters to match, e.g. CharMatcher.inRange('a', 'z').&#xA;&#xA;Additionally, CharMatcher has negate(), and(CharMatcher), and or(CharMatcher). These provide simple boolean operations on CharMatcher.&#xA;Using CharMatchers&#xA;CharMatcher provides a wide variety of methods to operate on occurrences of the specified characters in any CharSequence. There are more methods provided than we can list here, but some of the most commonly used are:&#xA;collapseFrom(CharSequence, char) Replace each group of consecutive matched characters with the specified character. For example, WHITESPACE.collapseFrom(string, ' ') collapses whitespaces down to a single space. matchesAllOf(CharSequence) Test if this matcher matches all characters in the sequence. For example, ASCII.matchesAllOf(string) tests if all characters in the string are ASCII. removeFrom(CharSequence) Removes matching characters from the sequence. retainFrom(CharSequence) Removes all non-matching characters from the sequence. trimFrom(CharSequence) Removes leading and trailing matching characters. replaceFrom(CharSequence, CharSequence) Replace matching characters with a given sequence.&#xA;&#xA;(Note: all of these methods return a String, except for matchesAllOf, which returns a boolean.)&#xA;Charsets&#xA;Don't do this:&#xA;try {&#xA;  bytes = string.getBytes(&quot;UTF-8&quot;);&#xA;} catch (UnsupportedEncodingException e) {&#xA;  // how can this possibly happen?&#xA;  throw new AssertionError(e);&#xA;}&#xA;Do this instead:&#xA;bytes = string.getBytes(Charsets.UTF_8);&#xA;Charsets provides constant references to the six standard Charset implementations guaranteed to be supported by all Java platform implementations. Use them instead of referring to charsets by their names.&#xA;TODO: an explanation of charsets and when to use them&#xA;(Note: If you're using JDK7, you should use the constants in StandardCharsets instead!)&#xA;CaseFormat&#xA;CaseFormat is a handy little class for converting between ASCII case conventions -- like, for example, naming conventions for programming languages. Supported formats include:&#xA;Format Example LOWER_CAMEL lowerCamel LOWER_HYPHEN lower-hyphen LOWER_UNDERSCORE lower_underscore UPPER_CAMEL UpperCamel UPPER_UNDERSCORE UPPER_UNDERSCORE&#xA;&#xA;Using it is relatively straightforward:&#xA;CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, &quot;CONSTANT_NAME&quot;)); // returns &quot;constantName&quot;&#xA;We find this especially useful, for example, when writing programs that generate other programs.&#xA; owner: kak@google.com&#xA; last update: Apr 5, 2014"/>
    <pages name="PrimitivesExplained" body="summary: Guava's primitives utilities, explained.&#xA;Overview&#xA;The primitive types of Java are the basic types:&#xA;byte short int long float double char boolean&#xA;&#xA;Before searching Guava for a method, you should check if it is in Arrays or the corresponding JDK wrapper type, e.g. Integer.&#xA;These types cannot be used as objects or as type parameters to generic types, which means that many general-purpose utilities cannot be applied to them. Guava provides a number of these general-purpose utilities, ways of interfacing between primitive arrays and collection APIs, conversion from types to byte array representations, and support for unsigned behaviors on certain types.&#xA;Primitive Type Guava Utilities (all in com.google.common.primitives) byte Bytes, SignedBytes, UnsignedBytes short Shorts int Ints, UnsignedInteger, UnsignedInts long Longs, UnsignedLong, UnsignedLongs float Floats double Doubles char Chars boolean Booleans&#xA;&#xA;Methods that differ in behavior for signed and unsigned bytes are completely skipped in Bytes, but only present in the SignedBytes and UnsignedBytes utilities, since the signedness of bytes is somewhat more ambiguous than the signedness of other types.&#xA;Unsigned variants of methods on int and long are provided in the UnsignedInts and UnsignedLongs classes, but since most uses of those types are signed, the Ints and Longs classes treat their inputs as signed.&#xA;Additionally, Guava provides &quot;wrapper types&quot; for unsigned int and long values, UnsignedInteger and UnsignedLong, to help you use the type system to enforce distinctions between signed and unsigned values, in exchange for a small performance cost. These classes directly support simple arithmetic operations in the style of BigInteger.&#xA;All method signatures use Wrapper to refer to the corresponding JDK wrapper type, and prim to refer to the primitive type. (Prims, where applicable, refers to the corresponding Guava utilities class.)&#xA;Primitive array utilities&#xA;Primitive arrays are the most efficient way (in both memory and performance) to work with primitive types in aggregate. Guava provides a variety of utilities to work with these methods.&#xA;Signature Description Collection analogue Availability List&lt;Wrapper> asList(prim... backingArray) Wraps a primitive array as a List of the corresponding wrapper type. Arrays.asList Sign-independent* prim[] toArray(Collection&lt;Wrapper> collection) Copies a collection into a new prim[]. This method is as thread-safe as collection.toArray(). Collection.toArray() Sign-independent prim[] concat(prim[]... arrays) Concatenate several primitive arrays. Iterables.concat Sign-independent boolean contains(prim[] array, prim target) Determines if the specified element is in the specified array. Collection.contains Sign-independent int indexOf(prim[] array, prim target) Finds the index of the first appearance of the value target in array, or returns -1 if no such value exists. List.indexOf Sign-independent int lastIndexOf(prim[] array, prim target) Finds the index of the last appearance of the value target in array, or returns -1 if no such value exists. List.lastIndexOf Sign-independent prim min(prim... array) Returns the minimum element of the array. Collections.min Sign-dependent** prim max(prim... array) Returns the maximum element of the array. Collections.max Sign-dependent String join(String separator, prim... array) Constructs a string containing the elements of array, separated by separator. Joiner.on(separator).join Sign-dependent Comparator&lt;prim[]> lexicographicalComparator() A comparator which compares primitive arrays lexicographically. Ordering.natural().lexicographical() Sign-dependent&#xA;&#xA;* Sign-independent methods are present in: Bytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans. Not UnsignedInts, UnsignedLongs, SignedBytes, or UnsignedBytes.&#xA;** Sign-dependent methods are present in: SignedBytes, UnsignedBytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans, UnsignedInts, UnsignedLongs. Not Bytes.&#xA;General utility methods&#xA;Guava provides a number of basic utilities which were not part of JDK 6. Some of these methods, however, are available in JDK 7.&#xA;Signature Description Availability int compare(prim a, prim b) A traditional Comparator.compare method, but on the primitive types. Provided in the JDK wrapper classes as of JDK 7. Sign-dependent prim checkedCast(long value) Casts the specified value to prim, unless the specified value does not fit into a prim, in which case an IllegalArgumentException is thrown. Sign-dependent for integral types only* prim saturatedCast(long value) Casts the specified value to prim, unless the specified value does not fit into a prim, in which case the closest prim value is used. Sign-dependent for integral types only&#xA;&#xA;*Here, integral types include byte, short, int, long. Integral types do not include char, boolean, float, or double.&#xA;Note: Rounding from double is provided in com.google.common.math.DoubleMath, and supports a variety of rounding modes. See the article for details.&#xA;Byte conversion methods&#xA;Guava provides methods to convert primitive types to and from byte array representations in big-endian order. All methods are sign-independent, except that Booleans provides none of these methods.&#xA;Signature Description int BYTES Constant representing the number of bytes needed to represent a prim value. prim fromByteArray(byte[] bytes) Returns the prim value whose big-endian representation is the first Prims.BYTES bytes in the array bytes. Throws an IllegalArgumentException if bytes.length &lt;= Prims.BYTES. prim fromBytes(byte b1, ..., byte bk) Takes Prims.BYTES byte arguments. Returns the prim value whose byte representation is the specified bytes in big-endian order. byte[] toByteArray(prim value) Returns an array containing the big-endian byte representation of value.&#xA;&#xA;Unsigned support&#xA;The UnsignedInts and UnsignedLongs utility classes provide some of the generic utilities that Java provides for signed types in their wrapper classes. UnsignedInts and UnsignedLongs deal with the primitive type directly: it is up to you to make sure that only unsigned values are passed to these utilities.&#xA;Additionally, for int and long, Guava provides &quot;unsigned&quot; wrapper types (UnsignedInteger and UnsignedLong) to help you enforce distinctions between unsigned and signed values in the type system, in exchange for a small performance penalty.&#xA;Generic utilities&#xA;These methods' signed analogues are provided in the wrapper classes in the JDK.&#xA;Signature Explanation int UnsignedInts.parseUnsignedInt(String)&#xA;long UnsignedLongs.parseUnsignedLong(String) Parses an unsigned value from a string in base 10. int UnsignedInts.parseUnsignedInt(String string, int radix)&#xA;long UnsignedLongs.parseUnsignedLong(String string, int radix) Parses an unsigned value from a string in the specified base. String UnsignedInts.toString(int)&#xA;String UnsignedLongs.toString(long) Returns a string representation of the unsigned value in base 10. String UnsignedInts.toString(int value, int radix)&#xA;String UnsignedLongs.toString(long value, int radix) Returns a string representation of the unsigned value in the specified base.&#xA;&#xA;Wrapper&#xA;The provided unsigned wrapper types include a number of methods to make their use and conversion easier.&#xA;Signature Explanation UnsignedPrim plus(UnsignedPrim), minus, times, dividedBy, mod Simple arithmetic operations. UnsignedPrim valueOf(BigInteger) Returns the value from a BigInteger as an UnsignedPrim, or throw an IAE if the specified BigInteger is negative or does not fit. UnsignedPrim valueOf(long) Returns the value from the long as an UnsignedPrim, or throw an IAE if the specified long is negative or does not fit. UnsignedPrim fromPrimBits(prim value) View the given value as unsigned. For example, UnsignedInteger.fromIntBits(1 &lt;&lt; 31) has the value 231, even though 1 &lt;&lt; 31 is negative as an int. BigInteger bigIntegerValue() Get the value of this UnsignedPrim as a BigInteger. toString(), toString(int radix) Returns a string representation of this unsigned value.&#xA; owner: kak@google.com&#xA; last update: May 8, 2014"/>
    <pages name="TenThingsAboutImmutableCollections" body="summary: Ten Things You Might Not Know About Guava's Immutable Collections!&#xA;(In progress. rough outline.)&#xA;Memory efficiency&#xA;Without mutability, there's no need to leave space for elements that might be added later. Immutable collections are always more compact than mutable equivalents.&#xA;Order is preserved. Every immutable collection (except the sorted ones, of course) iterates over elements in the order they were added to the builder. copyOf() short-circuiting. You can always call ImmutableXXX.copyOf defensively on collections passed to your methods, and it's smart enough that if the collection is already immutable, and the collection isn't a partial view of a larger collection, it won't actually do the copying. They're types, not implementations -- think of them like interfaces. ImmutableCollections have an asList() view They don't like null. How they're better than unmodifiable() ImmutableList has a reverse() view They have builders They don't try to protect you from your equals() or hashCode() method being slow. As with all immutable objects, no thread-safety concerns (as long as the contents are thread safe)&#xA; owner: wasserman.louis&#xA; last update: Mar 20, 2012"/>
    <pages name="IOExplained" body="summary: Guava's I/O package utilities, explained.&#xA;ByteStreams and CharStreams&#xA;Guava uses the term &quot;stream&quot; to refer to a Closeable stream for I/O data which has positional state in the underlying resource. The term &quot;byte stream&quot; refers to an InputStream or OutputStream, while &quot;char stream&quot; refers to a Reader or Writer (though their supertypes Readable and Appendable are often used as method parameter types). Corresponding utilities are divided into the utility classes ByteStreams and CharStreams.&#xA;Most Guava stream-related utilities deal with an entire stream at a time and/or handle buffering themselves for efficiency. Also note that Guava methods that take a stream do not close the stream: closing streams is generally the responsibility of the code that opens the stream.&#xA;Some of the methods provided by these classes include:&#xA;ByteStreams CharStreams byte[] toByteArray(InputStream) String toString(Readable) N/A List&lt;String> readLines(Readable) long copy(InputStream, OutputStream) long copy(Readable, Appendable) void readFully(InputStream, byte[]) N/A void skipFully(InputStream, long) void skipFully(Reader, long) OutputStream nullOutputStream() Writer nullWriter()&#xA;&#xA;A note on InputSupplier and OutputSupplier&#xA;Many of the methods in ByteStreams, CharStreams and other classes in the common.io package still use the InputSupplier and OutputSupplier interfaces. These interfaces and the methods that use them are deprecated: they are being replaced by the source and sink types described below and will eventually be removed.&#xA;Sources and sinks&#xA;It's common to create I/O utility methods that help you to avoid dealing with streams at all when doing basic operations. For example, Guava has Files.toByteArray(File) and Files.write(File, byte[]). However, you end up with similar methods scattered all over, each dealing with a different kind of source of data or sink to which data can be written. For example, Guava has Resources.toByteArray(URL) which does the same thing as Files.toByteArray(File), but using a URL as the source of data rather than a file.&#xA;To address this, Guava has a set of abstractions over different types of data sources and sinks. A source or sink is a resource of some sort that you know how to open a new stream to, such as a File or URL. Sources are readable, while sinks are writable. Additionally, sources and sinks are broken down according to whether you are dealing with byte or char data.&#xA;Bytes Chars Reading ByteSource CharSource Writing ByteSink CharSink&#xA;&#xA;The advantage of these APIs is that they provide a common set of operations. Once you've wrapped your data source as a ByteSource, for example, you get the same set of methods no matter what that source happens to be.&#xA;Creating sources and sinks&#xA;Guava provides a number of source and sink implementations:&#xA;Bytes Chars Files.asByteSource(File) Files.asCharSource(File, Charset) Files.asByteSink(File, FileWriteMode...) Files.asCharSink(File, Charset, FileWriteMode...) Resources.asByteSource(URL) Resources.asCharSource(URL, Charset) ByteSource.wrap(byte[]) CharSource.wrap(CharSequence) ByteSource.concat(ByteSource...) CharSource.concat(CharSource...) ByteSource.slice(long, long) N/A N/A ByteSource.asCharSource(Charset) N/A ByteSink.asCharSink(Charset)&#xA;&#xA;In addition, you can extend the source and sink classes yourself to create new implementations.&#xA;Note: While it can be tempting to create a source or sink that wraps an open stream (such as an InputStream), this should be avoided. Your source/sink should instead open a new stream each time its openStream() method is called. This allows the source or sink to control the full lifecycle of that stream and allows it to be usable multiple times rather that becoming unusable the first time any method on it is called. Additionally, if you're opening the stream before creating the source or sink you may still have to deal with ensuring that the stream is closed correctly if an exception is thrown elsewhere in your code, which defeats many of the advantages of using a source or sink in the first place.&#xA;Using Sources and Sinks&#xA;Once you have a source or sink instance, you have access to a number of operations for reading or writing.&#xA;Common operations&#xA;All sources and sinks provide the ability to open a new stream for reading or writing. By default, other operations are all implemented by calling one of these methods to get a stream, doing something, and then ensuring that the stream is closed.&#xA;These methods are all named:&#xA;openStream() - returns an InputStream, OutputStream, Reader or Writer depending on the type of source or sink. openBufferedStream() - returns an InputStream, OutputStream, BufferedReader or Writer depending on the type of source or sink. The returned stream is guaranteed to be buffered if necessary. For example, a source that reads from a byte array has no need for additional buffering in memory. This is why the methods do not return BufferedInputStream etc. except in the case of BufferedReader, because it defines the readLine() method.&#xA;Source operations&#xA;ByteSource CharSource byte[] read() String read() N/A ImmutableList&lt;String> readLines() N/A String readFirstLine() long copyTo(ByteSink) long copyTo(CharSink) long copyTo(OutputStream) long copyTo(Appendable) long size() (in bytes) N/A boolean isEmpty() boolean isEmpty() boolean contentEquals(ByteSource) N/A HashCode hash(HashFunction) N/A&#xA;&#xA;Sink operations&#xA;ByteSink CharSink void write(byte[]) void write(CharSequence) long writeFrom(InputStream) long writeFrom(Readable) N/A void writeLines(Iterable&lt;? extends CharSequence>) N/A void writeLines(Iterable&lt;? extends CharSequence>, String)&#xA;&#xA;Examples&#xA;// Read the lines of a UTF-8 text file&#xA;ImmutableList&lt;String> lines = Files.asCharSource(file, Charsets.UTF_8)&#xA;    .readLines();&#xA;&#xA;// Count distinct word occurrences in a file&#xA;Multiset&lt;String> wordOccurrences = HashMultiset.create(&#xA;  Splitter.on(CharMatcher.WHITESPACE)&#xA;    .trimResults()&#xA;    .omitEmptyStrings()&#xA;    .split(Files.asCharSource(file, Charsets.UTF_8).read()));&#xA;&#xA;// SHA-1 a file&#xA;HashCode hash = Files.asByteSource(file).hash(Hashing.sha1());&#xA;&#xA;// Copy the data from a URL to a file&#xA;Resources.asByteSource(url).copyTo(Files.asByteSink(file));&#xA;Files&#xA;In addition to methods for creating file sources and sinks, the Files class contains a number of convenience methods that you might be interested in.&#xA;createParentDirs(File) Creates necessary but nonexistent parent directories of the file. getFileExtension(String) Gets the file extension of the file described by the path. getNameWithoutExtension(String) Gets the name of the file with its extension removed simplifyPath(String) Cleans up the path. Not always consistent with your filesystem; test carefully! fileTreeTraverser() Returns a TreeTraverser that can traverse file trees&#xA; owner: cgdecker@google.com&#xA; last update: Dec 20, 2013"/>
    <pages name="Release09" body="summary: Release notes for Guava Release 09&#xA;Guava Release 09: Release Notes&#xA;Release 09 was released on April 7, 2011. (See ReleaseHistory.)&#xA;Download it&#xA;Javadocs are included, but more complete javadocs (using the &quot;-linksource&quot; and &quot;-use&quot; javadoc options) are always available on-line:&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;Here are some code/config snippets for how to UseGuavaInYourBuild.&#xA;This release will be identified in the Maven &quot;central&quot; repository used by maven, ivy, gradle, ant (with maven ant tasks) as com.google.guava:guava:r09.&#xA;API Changes&#xA;Full JDiff Report of changes since release 08&#xA;To build a combined report of the API changes between release 09 and any older release, check out our source tree and run svn/tags/release09/javadoc/jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 05).&#xA;Issues resolved&#xA;Issues fixed&#xA; owner: fry@google.com&#xA; last update: Mar 20, 2012"/>
    <pages name="UsingProGuardWithGuava" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;Guava is a fairly sizable JAR file, and your app may be using only a small portion of it. If you'd like an easy way to include just the parts of Guava you really need in your own application, we recommend you look into ProGuard.&#xA;Here's a very simple quick-start guide.&#xA;First, download ProGuard and copy proguard.jar into your lib directory.&#xA;Unfortunately, you'll also need to grab jsr305.jar, which is not included in the Guava zip distribution because you don't need it under normal circumstances.&#xA;Create a file called myapplication.pro containing:&#xA;-injars path/to/myapplication.jar&#xA;-injars lib/guava-r07.jar&#xA;-libraryjars lib/jsr305.jar&#xA;-outjars myapplication-dist.jar&#xA;&#xA;-dontoptimize&#xA;-dontobfuscate&#xA;-dontwarn sun.misc.Unsafe&#xA;-dontwarn com.google.common.collect.MinMaxPriorityQueue&#xA;&#xA;-keepclasseswithmembers public class * {&#xA;    public static void main(java.lang.String[]);&#xA;}&#xA;Then use&#xA;java -jar lib/proguard.jar -libraryjars $JAVA_HOME/jre/lib/rt.jar @myapplication.pro&#xA;Of course, you may have other entry points or any number of other considerations, so by all means peruse the ProGuard manual to learn more.&#xA;Other note: if &quot;myapplication&quot; is actually a library, which will be used by other users outside your control (who might also use Guava or use other libraries that do), this procedure is probably not a good idea. It's much safer if your users who are building applications bring in the Guava dependency separately. You may want to communicate to them what is the minimum version of Guava you require. Unlike most users, you should avoid any Guava APIs marked @Beta. An alternative to all of this is to use ProGuard's repackaging feature to create your own private version of Guava that will serve your library alone, but this is clearly not the best solution for application performance.&#xA;We would like to hear about your experiences using ProGuard with Guava so we can improve this page.&#xA; owner: wasserman.louis&#xA; last update: May 8, 2012"/>
    <pages name="ExplainedContents" body="summary: Sidebar for Guava Explained.&#xA;Introduction Basic Utilities Using/avoiding null Optional&#xA;Preconditions Ordering Creation Chaining Application&#xA;Object methods equals hashCode toString compare/compareTo&#xA;Throwables&#xA;Collections Immutable collections New collection types Multiset Multimap BiMap Table ClassToInstanceMap RangeSet&#xA;Utility Classes Iterables Lists Sets Maps Multisets Multimaps Tables&#xA;Extension Utilities Forwarding Decorators PeekingIterator AbstractIterator&#xA;&#xA;Caches Applicability Population Eviction Removal Listeners Refresh Timed Eviction Size Caps Garbage Collection Explicit Removals&#xA;Features Statistics&#xA;Interruption&#xA;Functional Idioms Obtaining Using Predicates Using Functions&#xA;Concurrency ListenableFuture Service Using Implementations&#xA;&#xA;Strings Joiner Splitter CharMatcher Charsets&#xA;Networking InternetDomainName&#xA;Primitives Primitive arrays General utilities Byte conversion Unsigned support&#xA;Ranges Building Operations Discrete Domains&#xA;I/O Closing Resources&#xA;Hashing BloomFilter&#xA;EventBus Math Integral Overflow Checking&#xA;Floating Point&#xA;Reflection TypeToken Invokable Dynamic Proxies ClassPath&#xA;Releases Release 18 Release 17 Release 16 Release 15 Release 14 Release 13 Release 12 Release 11 Release 10&#xA;Tips Philosophy Building with Guava Shrinking JARs with ProGuard Translating from Apache Commons Guava and Compatibility Idea Graveyard Friends of Guava How to Contribute&#xA;Glossary Mailing List Stack Overflow Footprint of JDK/Guava data structures&#xA; owner: cgdecker@google.com&#xA; last update: Aug 5, 2014"/>
    <pages name="EventBusExplained" body="summary: Guava's event bus utility, explained.&#xA;EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-process event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.&#xA;Example&#xA;// Class is typically registered by the container.&#xA;class EventBusChangeRecorder {&#xA;  @Subscribe public void recordCustomerChange(ChangeEvent e) {&#xA;    recordChange(e.getChange());&#xA;  }&#xA;}&#xA;// somewhere during initialization&#xA;eventBus.register(new EventBusChangeRecorder());&#xA;// much later&#xA;public void changeCustomer() {&#xA;  ChangeEvent event = getChangeEvent();&#xA;  eventBus.post(event);&#xA;}&#xA;One-Minute Guide&#xA;Converting an existing EventListener-based system to use the EventBus is easy.&#xA;For Listeners&#xA;To listen for a specific flavor of event (say, a CustomerChangeEvent)...&#xA;...in traditional Java events: implement an interface defined with the event -- such as CustomerChangeEventListener. ...with EventBus: create a method that accepts CustomerChangeEvent as its sole argument, and mark it with the Subscribe annotation.&#xA;&#xA;To register your listener methods with the event producers...&#xA;...in traditional Java events: pass your object to each producer's registerCustomerChangeEventListener method. These methods are rarely defined in common interfaces, so in addition to knowing every possible producer, you must also know its type. ...with EventBus: pass your object to the EventBus.register(Object) method on an EventBus. You'll need to make sure that your object shares an EventBus instance with the event producers.&#xA;To listen for a common event supertype (such as EventObject or Object)... ...in traditional Java events: not easy. ...with EventBus: events are automatically dispatched to listeners of any supertype, allowing listeners for interface types or &quot;wildcard listeners&quot; for Object.&#xA;&#xA;To listen for and detect events that were dispatched without listeners...&#xA;...in traditional Java events: add code to each event-dispatching method (perhaps using AOP). ...with EventBus: subscribe to DeadEvent. The EventBus will notify you of any events that were posted but not delivered. (Handy for debugging.)&#xA;For Producers&#xA;To keep track of listeners to your events...&#xA;...in traditional Java events: write code to manage a list of listeners to your object, including synchronization, or use a utility class like EventListenerList. ...with EventBus: EventBus does this for you.&#xA;&#xA;To dispatch an event to listeners...&#xA;...in traditional Java events: write a method to dispatch events to each event listener, including error isolation and (if desired) asynchronicity. ...with EventBus: pass the event object to an EventBus's EventBus.post(Object) method.&#xA;&#xA;Glossary&#xA;The EventBus system and code use the following terms to discuss event distribution: Event Any object that may be posted to a bus.SubscribingThe act of registering a listener with an EventBus, so that its handler methods will receive events.ListenerAn object that wishes to receive events, by exposing handler methods.Handler method A public method that the EventBus should use to deliver posted events. Handler methods are marked by the Subscribe annotation.Posting an event Making the event available to any listeners through the EventBus.&#xA;&#xA;FAQ&#xA;Why must I create my own Event Bus, rather than using a singleton?&#xA;EventBus doesn't specify how you use it; there's nothing stopping your application from having separate EventBus instances for each component, or using separate instances to separate events by context or topic. This also makes it trivial to set up and tear down EventBus objects in your tests.&#xA;Of course, if you'd like to have a process-wide EventBus singleton, there's nothing stopping you from doing it that way. Simply have your container (such as Guice) create the EventBus as a singleton at global scope (or stash it in a static field, if you're into that sort of thing).&#xA;In short, EventBus is not a singleton because we'd rather not make that decision for you. Use it how you like.&#xA;Can I unregister a listener from the Event Bus?&#xA;Yes, using EventBus.unregister, but we find this is needed only rarely:&#xA;Most listeners are registered on startup or lazy initialization, and persist for the life of the application. Scope-specific EventBus instances can handle temporary event distribution (e.g. distributing events among request-scoped objects) For testing, EventBus instances can be easily created and thrown away, removing the need for explicit unregistration.&#xA;Why use an annotation to mark handler methods, rather than requiring the listener to implement an interface?&#xA;We feel that the Event Bus's @Subscribe annotation conveys your intentions just as explicitly as implementing an interface (or perhaps more so), while leaving you free to place event handler methods wherever you wish and give them intention-revealing names.&#xA;Traditional Java Events use a listener interface which typically sports only a handful of methods -- typically one. This has a number of disadvantages:&#xA;Any one class can only implement a single response to a given event. Listener interface methods may conflict. The method must be named after the event (e.g. handleChangeEvent), rather than its purpose (e.g. recordChangeInJournal). Each event usually has its own interface, without a common parent interface for a family of events (e.g. all UI events).&#xA;&#xA;The difficulties in implementing this cleanly has given rise to a pattern, particularly common in Swing apps, of using tiny anonymous classes to implement event listener interfaces.&#xA;Compare these two cases:&#xA;   class ChangeRecorder {&#xA;     void setCustomer(Customer cust) {&#xA;       cust.addChangeListener(new ChangeListener() {&#xA;         public void customerChanged(ChangeEvent e) {&#xA;           recordChange(e.getChange());&#xA;         }&#xA;       };&#xA;     }&#xA;   }&#xA;versus&#xA;   // Class is typically registered by the container.&#xA;   class EventBusChangeRecorder {&#xA;     @Subscribe public void recordCustomerChange(ChangeEvent e) {&#xA;       recordChange(e.getChange());&#xA;     }&#xA;   }&#xA;The intent is actually clearer in the second case: there's less noise code, and the event handler has a clear and meaningful name.&#xA;What about a generic Handler&lt;T> interface?&#xA;Some have proposed a generic Handler&lt;T> interface for EventBus listeners. This runs into issues with Java's use of type erasure, not to mention problems in usability.&#xA;Let's say the interface looked something like the following:&#xA;interface Handler&lt;T> {&#xA;  void handleEvent(T event);&#xA;}&#xA;Due to erasure, no single class can implement a generic interface more than once with different type parameters. This is a giant step backwards from traditional Java Events, where even if actionPerformed and keyPressed aren't very meaningful names, at least you can implement both methods!&#xA;Doesn't EventBus destroy static typing and eliminate automated refactoring support?&#xA;Some have freaked out about EventBus's register(Object) and post(Object) methods' use of the Object type.&#xA;Object is used here for a good reason: the Event Bus library places no restrictions on the types of either your event listeners (as in register(Object)) or the events themselves (in post(Object)).&#xA;Event handler methods, on the other hand, must explicitly declare their argument type -- the type of event desired (or one of its supertypes). Thus, searching for references to an event class will instantly find all handler methods for that event, and renaming the type will affect all handler methods within view of your IDE (and any code that creates the event).&#xA;It's true that you can rename your @Subscribed event handler methods at will; Event Bus will not stop this or do anything to propagate the rename because, to Event Bus, the names of your handler methods are irrelevant. Test code that calls the methods directly, of course, will be affected by your renaming -- but that's what your refactoring tools are for. We see this as a feature, not a bug: being able to rename your handler methods at will lets you make their meaning clearer.&#xA;What happens if I register a listener without any handler methods?&#xA;Nothing at all.&#xA;The Event Bus was designed to integrate with containers and module systems, with Guice as the prototypical example. In these cases, it's convenient to have the container/factory/environment pass every created object to an EventBus's register(Object) method.&#xA;This way, any object created by the container/factory/environment can hook into the system's event model simply by exposing handler methods.&#xA;What Event Bus problems can be detected at compile time?&#xA;Any problem that can be unambiguously detected by Java's type system. For example, defining a handler method for a nonexistent event type.&#xA;What Event Bus problems can be detected immediately at registration?&#xA;Immediately upon invoking register(Object) , the listener being registered is checked for the well-formedness of its handler methods. Specifically, any methods marked with @Subscribe must take only a single argument.&#xA;Any violations of this rule will cause an IllegalArgumentException to be thrown.&#xA;(This check could be moved to compile-time using APT, a solution we're researching.)&#xA;What EventBus problems may only be detected later, at runtime?&#xA;If a component posts events with no registered listeners, it may indicate an error (typically an indication that you missed a @Subscribe annotation, or that the listening component is not loaded).&#xA;(Note that this is not necessarily indicative of a problem. There are many cases where an application will deliberately ignore a posted event, particularly if the event is coming from code you don't control.)&#xA;To handle such events, register a handler method for the DeadEvent class. Whenever EventBus receives an event with no registered handlers, it will turn it into a DeadEvent and pass it your way -- allowing you to log it or otherwise recover.&#xA;How do I test event listeners and their handler methods?&#xA;Because handler methods on your listener classes are normal methods, you can simply call them from your test code to simulate the EventBus.&#xA;Why can't I do &lt;magic thing> with EventBus?&#xA;EventBus is designed to deal with a large class of use cases really, really well. We prefer hitting the nail on the head for most use cases to doing decently on all use cases.&#xA;Additionally, making EventBus extensible -- and making it useful and productive to extend, while still allowing ourselves to make additions to the core EventBus API that don't conflict with any of your extensions -- is an extremely difficult problem.&#xA;If you really, really need magic thing X, that EventBus can't currently provide, you should file an issue, and then design your own alternative.&#xA; owner: wasserman.louis&#xA; last update: Apr 13, 2012"/>
    <pages name="CollectionUtilitiesExplained" body="summary: Guava's static collections utilities, explained.&#xA;TODO: Queues, Tables&#xA;Any programmer with experience with the JDK Collections Framework knows and loves the utilities available in java.util.Collections. Guava provides many more utilities along these lines: static methods applicable to all collections. These are among the most popular and mature parts of Guava.&#xA;Methods corresponding to a particular interface are grouped in a relatively intuitive manner:&#xA;Interface JDK or Guava? Corresponding Guava utility class Collection JDK Collections2 (avoiding conflict with java.util.Collections) List JDK Lists Set JDK Sets SortedSet JDK Sets Map JDK Maps SortedMap JDK Maps Queue JDK Queues Multiset Guava Multisets Multimap Guava Multimaps BiMap Guava Maps Table Guava Tables&#xA;&#xA;Looking for transform, filter, and the like? That stuff is here, under functional idioms.&#xA;Static constructors&#xA;Before JDK 7, constructing new generic collections requires unpleasant code duplication:&#xA;List&lt;TypeThatsTooLongForItsOwnGood> list = new ArrayList&lt;TypeThatsTooLongForItsOwnGood>();&#xA;I think we can all agree that this is unpleasant. Guava provides static methods that use generics to infer the type on the right side:&#xA;List&lt;TypeThatsTooLongForItsOwnGood> list = Lists.newArrayList();&#xA;Map&lt;KeyType, LongishValueType> map = Maps.newLinkedHashMap();&#xA;To be sure, the diamond operator in JDK 7 makes this less of a hassle:&#xA;List&lt;TypeThatsTooLongForItsOwnGood> list = new ArrayList&lt;>();&#xA;But Guava goes further than this. With the factory method pattern, we can initialize collections with their starting elements very conveniently.&#xA;Set&lt;Type> copySet = Sets.newHashSet(elements);&#xA;List&lt;String> theseElements = Lists.newArrayList(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;);&#xA;Additionally, with the ability to name factory methods (Effective Java item 1), we can improve the readability of initializing collections to sizes:&#xA;List&lt;Type> exactly100 = Lists.newArrayListWithCapacity(100);&#xA;List&lt;Type> approx100 = Lists.newArrayListWithExpectedSize(100);&#xA;Set&lt;Type> approx100Set = Sets.newHashSetWithExpectedSize(100);&#xA;The precise static factory methods provided are listed with their corresponding utility classes below.&#xA;Note: New collection types introduced by Guava don't expose raw constructors, or have initializers in the utility classes. Instead, they expose static factory methods directly, for example:&#xA;Multiset&lt;String> multiset = HashMultiset.create();&#xA;Iterables&#xA;Whenever possible, Guava prefers to provide utilities accepting an Iterable rather than a Collection. Here at Google, it's not out of the ordinary to encounter a &quot;collection&quot; that isn't actually stored in main memory, but is being gathered from a database, or from another data center, and can't support operations like size() without actually grabbing all of the elements.&#xA;As a result, many of the operations you might expect to see supported for all collections can be found in Iterables. Additionally, most Iterables methods have a corresponding version in Iterators that accepts the raw iterator.&#xA;The overwhelming majority of operations in the Iterables class are lazy: they only advance the backing iteration when absolutely necessary. Methods that themselves return Iterables return lazily computed views, rather than explicitly constructing a collection in memory.&#xA;As of Guava 12, Iterables is supplemented by the FluentIterable class, which wraps an Iterable and provides a &quot;fluent&quot; syntax for many of these operations.&#xA;The following is a selection of the most commonly used utilities, although many of the more &quot;functional&quot; methods in Iterables are discussed in Guava functional idioms.&#xA;General&#xA;Method Description See Also concat(Iterable&lt;Iterable>) Returns a lazy view of the concatenation of several iterables. concat(Iterable...) frequency(Iterable, Object) Returns the number of occurrences of the object. Compare Collections.frequency(Collection, Object); see Multiset partition(Iterable, int) Returns an unmodifiable view of the iterable partitioned into chunks of the specified size. Lists.partition(List, int), paddedPartition(Iterable, int) getFirst(Iterable, T default) Returns the first element of the iterable, or the default value if empty. Compare Iterable.iterator().next()&#xA;FluentIterable.first() getLast(Iterable) Returns the last element of the iterable, or fails fast with a NoSuchElementException if it's empty. getLast(Iterable, T default)&#xA;FluentIterable.last() elementsEqual(Iterable, Iterable) Returns true if the iterables have the same elements in the same order. Compare List.equals(Object) unmodifiableIterable(Iterable) Returns an unmodifiable view of the iterable. Compare Collections.unmodifiableCollection(Collection) limit(Iterable, int) Returns an Iterable returning at most the specified number of elements. FluentIterable.limit(int) getOnlyElement(Iterable) Returns the only element in Iterable. Fails fast if the iterable is empty or has multiple elements. getOnlyElement(Iterable, T default)&#xA;&#xA;Iterable&lt;Integer> concatenated = Iterables.concat(&#xA;  Ints.asList(1, 2, 3),&#xA;  Ints.asList(4, 5, 6));&#xA;// concatenated has elements 1, 2, 3, 4, 5, 6&#xA;&#xA;String lastAdded = Iterables.getLast(myLinkedHashSet);&#xA;&#xA;String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);&#xA;  // if this set isn't a singleton, something is wrong!&#xA;Collection-Like&#xA;Typically, collections support these operations naturally on other collections, but not on iterables.&#xA;Each of these operations delegates to the corresponding Collection interface method when the input is actually a Collection. For example, if Iterables.size is passed a Collection, it will call the Collection.size method instead of walking through the iterator.&#xA;Method Analogous Collection method FluentIterable equivalent addAll(Collection addTo, Iterable toAdd) Collection.addAll(Collection) contains(Iterable, Object) Collection.contains(Object) FluentIterable.contains(Object)removeAll(Iterable removeFrom, Collection toRemove) Collection.removeAll(Collection) retainAll(Iterable removeFrom, Collection toRetain) Collection.retainAll(Collection) size(Iterable) Collection.size() FluentIterable.size() toArray(Iterable, Class) Collection.toArray(T[]) FluentIterable.toArray(Class) isEmpty(Iterable) Collection.isEmpty() FluentIterable.isEmpty() get(Iterable, int) List.get(int) FluentIterable.get(int) toString(Iterable) Collection.toString() FluentIterable.toString()&#xA;&#xA;FluentIterable&#xA;Besides the methods covered above and in the functional idioms article, FluentIterable has a few convenient methods for copying into an immutable collection:&#xA;ImmutableList ImmutableSet toImmutableSet() ImmutableSortedSet toImmutableSortedSet(Comparator)&#xA;&#xA;Lists&#xA;In addition to static constructor methods and functional programming methods, Lists provides a number of valuable utility methods on List objects.&#xA;Method Description partition(List, int) Returns a view of the underlying list, partitioned into chunks of the specified size. reverse(List) Returns a reversed view of the specified list. Note: if the list is immutable, consider ImmutableList.reverse() instead.&#xA;&#xA;List&lt;Integer> countUp = Ints.asList(1, 2, 3, 4, 5);&#xA;List&lt;Integer> countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1}&#xA;&#xA;List&lt;List&lt;Integer>> parts = Lists.partition(countUp, 2); // {{1, 2}, {3, 4}, {5}}&#xA;Static Factories&#xA;Lists provides the following static factory methods:&#xA;Implementation Factories ArrayList basic, with elements, from Iterable, with exact capacity, with expected size, from Iterator LinkedList basic, from Iterable&#xA;&#xA;Sets&#xA;The Sets utility class includes a number of spicy methods.&#xA;Set-Theoretic Operations&#xA;We provide a number of standard set-theoretic operations, implemented as views over the argument sets. These return a SetView, which can be used:&#xA;as a Set directly, since it implements the Set interface by copying it into another mutable collection with copyInto(Set) by making an immutable copy with immutableCopy()&#xA;&#xA;Method union(Set, Set) intersection(Set, Set) difference(Set, Set) symmetricDifference(Set, Set)&#xA;&#xA;For example:&#xA;Set&lt;String> wordsWithPrimeLength = ImmutableSet.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;);&#xA;Set&lt;String> primes = ImmutableSet.of(&quot;two&quot;, &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;);&#xA;&#xA;SetView&lt;String> intersection = Sets.intersection(primes, wordsWithPrimeLength); // contains &quot;two&quot;, &quot;three&quot;, &quot;seven&quot;&#xA;// I can use intersection as a Set directly, but copying it can be more efficient if I use it a lot.&#xA;return intersection.immutableCopy();&#xA;Other Set Utilities&#xA;Method Description See Also cartesianProduct(List&lt;Set>) Returns every possible list that can be obtained by choosing one element from each set. cartesianProduct(Set...) powerSet(Set) Returns the set of subsets of the specified set.&#xA;&#xA;Set&lt;String> animals = ImmutableSet.of(&quot;gerbil&quot;, &quot;hamster&quot;);&#xA;Set&lt;String> fruits = ImmutableSet.of(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;);&#xA;&#xA;Set&lt;List&lt;String>> product = Sets.cartesianProduct(animals, fruits);&#xA;// {{&quot;gerbil&quot;, &quot;apple&quot;}, {&quot;gerbil&quot;, &quot;orange&quot;}, {&quot;gerbil&quot;, &quot;banana&quot;},&#xA;//  {&quot;hamster&quot;, &quot;apple&quot;}, {&quot;hamster&quot;, &quot;orange&quot;}, {&quot;hamster&quot;, &quot;banana&quot;}}&#xA;&#xA;Set&lt;Set&lt;String>> animalSets = Sets.powerSet(animals);&#xA;// {{}, {&quot;gerbil&quot;}, {&quot;hamster&quot;}, {&quot;gerbil&quot;, &quot;hamster&quot;}}&#xA;Static Factories&#xA;Sets provides the following static factory methods:&#xA;Implementation Factories HashSet basic, with elements, from Iterable, with expected size, from Iterator LinkedHashSet basic, from Iterable, with expected size TreeSet basic, with Comparator, from Iterable&#xA;&#xA;Maps&#xA;Maps has a number of cool utilities that deserve individual explanation.&#xA;uniqueIndex&#xA;Maps.uniqueIndex(Iterable, Function) addresses the common case of having a bunch of objects that each have some unique attribute, and wanting to be able to look up those objects based on that attribute.&#xA;Let's say we have a bunch of strings that we know have unique lengths, and we want to be able to look up the string with some particular length.&#xA;ImmutableMap&lt;Integer, String> stringsByIndex = Maps.uniqueIndex(strings, new Function&lt;String, Integer> () {&#xA;    public Integer apply(String string) {&#xA;      return string.length();&#xA;    }&#xA;  });&#xA;If indices are not unique, see Multimaps.index below.&#xA;difference&#xA;Maps.difference(Map, Map) allows you to compare all the differences between two maps. It returns a MapDifference object, which breaks down the Venn diagram into:&#xA;entriesInCommon() The entries which are in both maps, with both matching keys and values. entriesDiffering() The entries with the same keys, but differing values. The values in this map are of type MapDifference.ValueDifference, which lets you look at the left and right values. entriesOnlyOnLeft() Returns the entries whose keys are in the left but not in the right map. entriesOnlyOnRight() Returns the entries whose keys are in the right but not in the left map.&#xA;&#xA;Map&lt;String, Integer> left = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3);&#xA;Map&lt;String, Integer> right = ImmutableMap.of(&quot;b&quot;, 2, &quot;c&quot;, 4, &quot;d&quot;, 5);&#xA;MapDifference&lt;String, Integer> diff = Maps.difference(left, right);&#xA;&#xA;diff.entriesInCommon(); // {&quot;b&quot; => 2}&#xA;diff.entriesDiffering(); // {&quot;c&quot; => (3, 4)}&#xA;diff.entriesOnlyOnLeft(); // {&quot;a&quot; => 1}&#xA;diff.entriesOnlyOnRight(); // {&quot;d&quot; => 5}&#xA;BiMap utilities&#xA;The Guava utilities on BiMap live in the Maps class, since a BiMap is also a Map.&#xA;BiMap utility Corresponding Map utility synchronizedBiMap(BiMap) Collections.synchronizedMap(Map) unmodifiableBiMap(BiMap) Collections.unmodifiableMap(Map)&#xA;&#xA;Static Factories&#xA;Maps provides the following static factory methods.&#xA;Implementation Factories HashMap basic, from Map, with expected size LinkedHashMap basic, from Map TreeMap basic, from Comparator, from SortedMap EnumMap from Class, from Map ConcurrentMap (supporting all operations) basic IdentityHashMap basic&#xA;&#xA;Multisets&#xA;Standard Collection operations, such as containsAll, ignore the count of elements in the multiset, and only care about whether elements are in the multiset at all, or not. Multisets provides a number of operations that take into account element multiplicities in multisets.&#xA;Method Explanation Difference from Collection method containsOccurrences(Multiset sup, Multiset sub) Returns true if sub.count(o) &lt;= super.count(o) for all o. Collection.containsAll ignores counts, and only tests whether elements are contained at all. removeOccurrences(Multiset removeFrom, Multiset toRemove) Removes one occurrence in removeFrom for each occurrence of an element in toRemove. Collection.removeAll removes all occurences of any element that occurs even once in toRemove. retainOccurrences(Multiset removeFrom, Multiset toRetain) Guarantees that removeFrom.count(o) &lt;= toRetain.count(o) for all o. Collection.retainAll keeps all occurrences of elements that occur even once in toRetain. intersection(Multiset, Multiset) Returns a view of the intersection of two multisets; a nondestructive alternative to retainOccurrences. Has no analogue&#xA;&#xA;Multiset&lt;String> multiset1 = HashMultiset.create();&#xA;multiset1.add(&quot;a&quot;, 2);&#xA;&#xA;Multiset&lt;String> multiset2 = HashMultiset.create();&#xA;multiset2.add(&quot;a&quot;, 5);&#xA;&#xA;multiset1.containsAll(multiset2); // returns true: all unique elements are contained, &#xA;  // even though multiset1.count(&quot;a&quot;) == 2 &lt; multiset2.count(&quot;a&quot;) == 5&#xA;Multisets.containsOccurrences(multiset1, multiset2); // returns false&#xA;&#xA;multiset2.removeOccurrences(multiset1); // multiset2 now contains 3 occurrences of &quot;a&quot;&#xA;&#xA;multiset2.removeAll(multiset1); // removes all occurrences of &quot;a&quot; from multiset2, even though multiset1.count(&quot;a&quot;) == 2&#xA;multiset2.isEmpty(); // returns true&#xA;Other utilities in Multisets include:&#xA;copyHighestCountFirst(Multiset) Returns an immutable copy of the multiset that iterates over elements in descending frequency order. unmodifiableMultiset(Multiset) Returns an unmodifiable view of the multiset. unmodifiableSortedMultiset(SortedMultiset) Returns an unmodifiable view of the sorted multiset.&#xA;&#xA;Multiset&lt;String> multiset = HashMultiset.create();&#xA;multiset.add(&quot;a&quot;, 3);&#xA;multiset.add(&quot;b&quot;, 5);&#xA;multiset.add(&quot;c&quot;, 1);&#xA;&#xA;ImmutableMultiset&lt;String> highestCountFirst = Multisets.copyHighestCountFirst(multiset);&#xA;&#xA;// highestCountFirst, like its entrySet and elementSet, iterates over the elements in order {&quot;b&quot;, &quot;a&quot;, &quot;c&quot;}&#xA;Multimaps&#xA;Multimaps provides a number of general utility operations that deserve individual explanation.&#xA;index&#xA;The cousin to Maps.uniqueIndex, Multimaps.index(Iterable, Function) answers the case when you want to be able to look up all objects with some particular attribute in common, which is not necessarily unique.&#xA;Let's say we want to group strings based on their length.&#xA;ImmutableSet&lt;String> digits = ImmutableSet.of(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;,&#xA;  &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;);&#xA;Function&lt;String, Integer> lengthFunction = new Function&lt;String, Integer>() {&#xA;  public Integer apply(String string) {&#xA;    return string.length();&#xA;  }&#xA;};&#xA;ImmutableListMultimap&lt;Integer, String> digitsByLength = Multimaps.index(digits, lengthFunction);&#xA;/*&#xA; * digitsByLength maps:&#xA; *  3 => {&quot;one&quot;, &quot;two&quot;, &quot;six&quot;}&#xA; *  4 => {&quot;zero&quot;, &quot;four&quot;, &quot;five&quot;, &quot;nine&quot;}&#xA; *  5 => {&quot;three&quot;, &quot;seven&quot;, &quot;eight&quot;}&#xA; */&#xA;invertFrom&#xA;Since Multimap can map many keys to one value, and one key to many values, it can be useful to invert a Multimap. Guava provides invertFrom(Multimap toInvert, Multimap dest) to let you do this, without choosing an implementation for you.&#xA;NOTE: If you are using an ImmutableMultimap, consider ImmutableMultimap.inverse() instead.&#xA;ArrayListMultimap&lt;String, Integer> multimap = ArrayListMultimap.create();&#xA;multimap.putAll(&quot;b&quot;, Ints.asList(2, 4, 6));&#xA;multimap.putAll(&quot;a&quot;, Ints.asList(4, 2, 1));&#xA;multimap.putAll(&quot;c&quot;, Ints.asList(2, 5, 3));&#xA;&#xA;TreeMultimap&lt;Integer, String> inverse = Multimaps.invertFrom(multimap, TreeMultimap.&lt;String, Integer> create());&#xA;// note that we choose the implementation, so if we use a TreeMultimap, we get results in order&#xA;/*&#xA; * inverse maps:&#xA; *  1 => {&quot;a&quot;}&#xA; *  2 => {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}&#xA; *  3 => {&quot;c&quot;}&#xA; *  4 => {&quot;a&quot;, &quot;b&quot;}&#xA; *  5 => {&quot;c&quot;}&#xA; *  6 => {&quot;b&quot;}&#xA; */&#xA;forMap&#xA;Need to use a Multimap method on a Map? forMap(Map) views a Map as a SetMultimap. This is particularly useful, for example, in combination with Multimaps.invertFrom.&#xA;Map&lt;String, Integer> map = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 1, &quot;c&quot;, 2);&#xA;SetMultimap&lt;String, Integer> multimap = Multimaps.forMap(map);&#xA;// multimap maps [&quot;a&quot; => {1}, &quot;b&quot; => {1}, &quot;c&quot; => {2}]&#xA;Multimap&lt;Integer, String> inverse = Multimaps.invertFrom(multimap, HashMultimap.&lt;Integer, String> create());&#xA;// inverse maps [1 => {&quot;a&quot;, &quot;b&quot;}, 2 => {&quot;c&quot;}]&#xA;Wrappers&#xA;Multimaps provides the traditional wrapper methods, as well as tools to get custom Multimap implementations based on Map and Collection implementations of your choice.&#xA;Unmodifiable Multimap ListMultimap SetMultimap SortedSetMultimap Synchronized Multimap ListMultimap SetMultimap SortedSetMultimap Custom Implementation Multimap ListMultimap SetMultimap SortedSetMultimap&#xA;&#xA;The custom Multimap implementations let you specify a particular implementation that should be used in the returned Multimap. Caveats include:&#xA;The multimap assumes complete ownership over of map and the lists returned by factory. Those objects should not be manually updated, they should be empty when provided, and they should not use soft, weak, or phantom references. No guarantees are made on what the contents of the Map will look like after you modify the Multimap. The multimap is not threadsafe when any concurrent operations update the multimap, even if map and the instances generated by factory are. Concurrent read operations will work correctly, though. Work around this with the synchronized wrappers if necessary. The multimap is serializable if map, factory, the lists generated by factory, and the multimap contents are all serializable. The collections returned by Multimap.get(key) are not of the same type as the collections returned by your Supplier, though if you supplier returns RandomAccess lists, the lists returned by Multimap.get(key) will also be random access.&#xA;Note that the custom Multimap methods expect a Supplier argument to generate fresh new collections. Here is an example of writing a ListMultimap backed by a TreeMap mapping to LinkedList.&#xA;ListMultimap&lt;String, Integer> myMultimap = Multimaps.newListMultimap(&#xA;  Maps.&lt;String, Collection&lt;Integer>>newTreeMap(),&#xA;  new Supplier&lt;LinkedList&lt;Integer>>() {&#xA;    public LinkedList&lt;Integer> get() {&#xA;      return Lists.newLinkedList();&#xA;    }&#xA;  });&#xA;Tables&#xA;The Tables class provides a few handy utilities.&#xA;customTable&#xA;Comparable to the Multimaps.newXXXMultimap(Map, Supplier) utilities, Tables.newCustomTable(Map, Supplier&lt;Map>) allows you to specify a Table implementation using whatever row or column map you like.&#xA;// use LinkedHashMaps instead of HashMaps&#xA;Table&lt;String, Character, Integer> table = Tables.newCustomTable(&#xA;  Maps.&lt;String, Map&lt;Character, Integer>>newLinkedHashMap(),&#xA;  new Supplier&lt;Map&lt;Character, Integer>> () {&#xA;    public Map&lt;Character, Integer> get() {&#xA;      return Maps.newLinkedHashMap();&#xA;    }&#xA;  });&#xA;transpose&#xA;The transpose(Table&lt;R, C, V>) method allows you to view a Table&lt;R, C, V> as a Table&lt;C, R, V>. For example, if you're using a Table to model a weighted digraph, this will let you view the graph with all the edges reversed.&#xA;Wrappers&#xA;These are the familiar unmodifiability wrappers you know and love. Consider, however, using ImmutableTable instead in most cases.&#xA;Unmodifiable Table RowSortedTable&#xA; owner: kak@google.com&#xA; last update: Aug 5, 2014"/>
    <pages name="Release17" body="summary: Release notes for Guava Release 17.0&#xA;Guava Release 17.0: Release Notes&#xA;Release 17.0 was released on April 22, 2014. Release 17.0-rc2 was released on April 10, 2014. Release 17.0-rc1 was released on April 8, 2014.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;Guava Guava (GWT) Guava (JDK5 Backport) Maven Identifier com.google.guava:guava:17.0 com.google.guava:guava-gwt:17.0 com.google.guava:guava-jdk5:17.0 Jar guava-17.0.jar guava-gwt-17.0.jar guava-jdk5-17.0.jar Javadoc guava-17.0-javadoc.jar guava-gwt-17.0-javadoc.jar guava-jdk5-17.0-javadoc.jar Sources guava-17.0-sources.jar guava-gwt-17.0-sources.jar guava-jdk5-17.0-sources.jar&#xA;&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;Issues resolved&#xA;8 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 16.0.&#xA;To build a combined report of the API changes between release 17.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions and changes&#xA;common.base&#xA;Verify and VerifyException&#xA;Converter.from(Function&lt;A, B>, Function&lt;B, A>)&#xA;common.cache&#xA;CacheLoader.asyncReloading(CacheLoader&lt;K, V>, Executor)&#xA;common.io&#xA;ByteStreams.newDataInput(ByteArrayInputStream)&#xA;ByteStreams.newDataOutput(ByteArrayOutputStream)&#xA;Closeables.closeQuietly(InputStream)&#xA;Closeables.closeQuietly(Reader)&#xA;common.net&#xA;HostAndPort.fromHost(String)&#xA;common.util.concurrent&#xA;Futures.inCompletionOrder(Iterable&lt;ListenableFuture&lt;T>>)&#xA;MoreExecutors.shutdownAndAwaitTermination(ExecutorService, long, TimeUnit)&#xA;Service (and subclasses) - deprecated methods removed.&#xA;A note on BloomFilter&#xA;Release 17 fixes an issue (1119) with the performance of very large BloomFilters. For most users, this fix should be completely transparent. BloomFilter objects serialized with a previous version of Guava will be deserializable by and work fine in Guava 17. However, BloomFilters created by Guava 17 will not be deserializable by previous versions of Guava. This should still only affect you if both of the following are true:&#xA;You are serializing BloomFilters and sending them from one server or process to another. You can't upgrade all your servers to Guava 17 at the same time.&#xA;In this case, a server that's been upgraded to 17 could send a BloomFilter to a server that hasn't, which will then fail to deserialize it.&#xA;For this release only, we're providing the ability to use a system property to work around this issue. If the system property com.google.common.hash.BloomFilter.useMitz32 is set to true (ignoring case), Guava will create BloomFilters that are compatible with previous versions of Guava rather than using the new strategy. So while you're rolling out Guava 17, you can set this system property to keep everything working. Once it's fully rolled out, you can remove the system property to start using the new strategy. Guava 18.0 will no longer recognize the system property and will always use the new strategy for newly created BloomFilters.&#xA; owner: cgdecker@google.com&#xA; last update: Aug 25, 2014"/>
    <pages name="IdeaGraveyard" body="summary: Idea Graveyard - ideas we have rejected&#xA;The goal for this page is to flesh it out to contain a reasonably complete explanation of why we rejected each of these ideas.&#xA;Something missing? Search for an issue report, or file a new one. Let us know on the issue discussion if you think an idea belongs here.&#xA;com.google.common.base&#xA;Tuples for n >= 2&#xA;Tuple types are awful obfuscators. Tuples obfuscate what the fields actually mean (getFirst and getSecond are almost completely meaningless), and anything known about the field values. Tuples obfuscate method signatures: ListMultimap&lt;Route, Pair&lt;Double, Double>> is much less readable than ListMultimap&lt;Route, LatLong>.&#xA;StackOverflow has some explanation here, too.&#xA;Instead, we released AutoValue. This makes it easy to just create your own proper value classes.&#xA;Functions/Predicates for n >= 2 inputs&#xA;Part of the debate here is similar to the debate over tuples: When should we use generic interfaces, and when should we use specialized interfaces? The way we've leaned in Guava is toward specialized interfaces: We provide Range instead of Pair, and we provide Equivalence instead of BinaryPredicate. (If we could convince ourselves to add reduce(), we'd probably provide Reducer instead of BinaryFunction. But more likely still is that we'd provide methods like IntMath.sum.) We even have CharMatcher in addition to Predicate, CacheLoader in addition to Function, and so forth.&#xA;Another part of the debate is about widespread functional programming in Java. In a pre-Java 8 world, the language's verbosity (especially for anonymous classes and for generics) gets in our way. We've written about the downsides of functional programming in Java before. Still, there are cases in which it makes sense. We've tried to capture most of those with Function and Predicate, but if you need more complex types, have a look at other Java libraries for functional programming.&#xA;Why did we draw the line at single-input functions and predicates? It was a judgment call based on the frequency that single-input and multi-input versions are used, the growing verbosity as the number of inputs increases, and the temptations of overuse. While we can imagine code that needs to perform a SQL JOIN on two Maps, join(Map&lt;K, V1>, Map&lt;K, V2>, BiFunction&lt;V1, V2, O>) is unlikely to be a widely usable solution, for functionality, performance, and verbosity reasons. We would rather add a pseudo-database class (maybe one day...) than provide short wrappers that leave users wanting more.&#xA;Predicates.sameAs()&#xA;See  Issue 355  (thanks, lnezda).&#xA;We experimented with this internally, but we found that all of its users could be better served in other ways.&#xA;Preconditions.checkArgumentNotNull() (throws IllegalArgumentException)&#xA;We realize there are many valid arguments in favor of throwing IAE on a null argument. In fact, if we had a time machine to go back >15 years, we might even try to push things in that direction. However, we have decided to stick with the JDK and Effective Java preference of NullPointerException.&#xA;If you're steadfast in your belief that IAE is right, you still have checkArgument(arg != null), just without the convenience of it returning arg, or you can create a local utility to your project.&#xA;com.google.common.collect&#xA;Iterables.isNullOrEmpty&#xA;Prefer to return empty collections instead of null. Then a plain isEmpty check will suffice. (Thanks, xaerxess.)&#xA;counting/indexed iterator&#xA;A CountingIterator has a variety of possible uses, and I saw most of them in going through our internal Google uses. Roughly from most common to least, they are:&#xA;1) CountingIterator was used in our GXP templating system's gxp:loop element. It used to be difficult to count elements in GXP. gxp:loop has since been changed a while back to support a key attribute. It defines a variable in which the count is kept. This turns out to be much nicer:&#xA;Before:&#xA;&lt;gxp:abbr name='iter' type='CountingIterator{String}' expr='CountingIterator.from(keys)'>&#xA;    &lt;gxp:loop var='value' type='String' iterator='iter'>&#xA;      &lt;gxp:abbr name='index' type='int' expr='iter.getIndex()'>&#xA;After:&#xA;&lt;gxp:loop var='value' type='String' key='index' iterable='keys'>&#xA;2) CountingIterator was used in otherwise typical for() loops. Usually, removing CountingIterator simplified the code:&#xA;Before:&#xA;  CountingIterator&lt;Record> iterator = CountingIterator.from(records);&#xA;  while (iterator.hasNext()) {&#xA;    Record record = iterator.next();&#xA;    int i = iterator.getIndex();&#xA;After:&#xA;  for (int i = 0; i &lt; records.size(); i++) {&#xA;    Record record = records.get(i);&#xA;Or, if indexed access isn't a good idea:&#xA;Before:&#xA;  CountingIterator&lt;Map.Entry&lt;String, Class>> iter =&#xA;      CountingIterator.from(map.entrySet());&#xA;  while (iter.hasNext()) {&#xA;    doStuff(iter.next(), iter.getIndex());&#xA;After:&#xA;  Iterator&lt;Map.Entry&lt;String, Class>> iter = map.entrySet().iterator();&#xA;  for (int i = 0; iter.hasNext(); i++) {&#xA;    doStuff(iter.next(), i);&#xA;3) CountingIterator has shown a particular ability to draw users away from APIs that do what they want more directly. Some people looked for Iterables.limit there -- and found it, since our CountingIterator happened to support it. Others used to use CountingIterator to reimplement partitioning:&#xA;Before:&#xA;  CountingIterator&lt;Task> iter = CountingIterator.from(tasks);&#xA;  while (iter.hasNext()) {&#xA;    List&lt;Task> batch = Lists.newArrayList();&#xA;    do {&#xA;      batch.add(iter.next());&#xA;    } while (iter.hasNext() &amp;&amp; (iter.getCount() % TASKS_PER_BATCH) > 0);&#xA;    // Plus, the above test could have used batch.size() and not needed CountingIterator.&#xA;After:&#xA;  for (List&lt;Task> batch : partition(tasks, TASKS_PER_BATCH)) {&#xA;4) CountingIterator can be used to test that an Iterator's contents are lazily evaluated. This works well enough, though there's also some uncertainty around what to track: (a) only the number of calls to next() or (b) any call that looks ahead at a new element (i.e., the number of next() calls, plus 1 if there was a trailing hasNext() call). As an alternative, you may be able to use a ListIterator, which exposes nextIndex().&#xA;5) CountingIterator can be defined as an Iterator&lt;Counted&lt;E>> so that it can be used as input to methods like transform(), filter(), and toMap(). However, such code tends to be unusually verbose as Java functional code goes. It's a candidate for rewriting with a for() loop.&#xA;One more thing that I discovered was some weirdness in how CountingIterator's getIndex() method behaves. The method's value is incremented at each call to next(), so at any given time, getIndex() may be equal to the &quot;natural&quot; loop index (after a call to next()) or one greater (before the call to next() -- notably including after the end of the loop, at which point it's equal to size()). Statefulness is a necessary property of iterators, but it gets worse here: You need to call either next() or getIndex() first, and your choice affects the value in subtle ways. The Iterator&lt;Counted&lt;E>> approach outlined above can solve the statefulness problem, though it makes CountingIterator less suitable for the lazy-evaluation testing described in (4).&#xA;Given the usages we found, we thought it best not to include a CountingIterator. The class is straightforward to implement atop ForwardingIterator when needed.&#xA;Lazy/computing Map whose get() method returns a default value&#xA;Our main strategy for satisfying LazyMap use cases has been to add specialized collection types: LazyMap&lt;K, List&lt;V>> becomes Multimap&lt;K, V>, LazyMap&lt;K, Integer> becomes Multiset&lt;K> or AtomicLongMap&lt;K>, LazyMap&lt;K1, Map&lt;K2, V>> becomes Table&lt;K1, K2, V>, some Maps become LoadingCaches. That is in part because those abstractions are more powerful. It's also in part because LazyMap has surprising behavior in some cases. For example, lazyMap.equals(myMap) is likely to behave as expected, but myMap.equals(lazyMap) can cause entries to be inserted into lazyMap. A mutating equals() is pretty weird on its own, and it only gets weirder when it's so easy to change a non-mutating call to a mutating one (say, if someone rewrites HashMap.get to call a.equals(b) instead of b.equals(a)).&#xA;Given that, I suggest first looking at our various collection types. If that won't work, try wrapper methods with implementations containing snippets like firstNonNull(map.get(key), defaultValue) or Functions.fromMap(map, defaultValue).apply(key). Changing get() itself, though, produces strange enough behavior that we've removed the feature from Guava (which used to support it).&#xA;A method to view an iterator as an iterable&#xA;The biggest concern is that Iterable is generally assumed to be able to produce multiple independent iterators. The doc doesn't say this, but the Collection doc doesn't say this, either, and yet we assume it of its iterators. We have had breakages in Google when this assumption was violated.&#xA;The simplest workaround is ImmutableList.copyOf(Iterator), which is pretty fast, safe, and provides many other advantages besides.&#xA;Lists.filter&#xA;See  issue 505 .&#xA;The biggest concern here is that too many operations become expensive, linear-time propositions. If you want to filter a list and get a list back, and not just a Collection or an Iterable, you can use ImmutableList.copyOf(Iterables.filter(list, predicate)), which &quot;states up front&quot; what it's doing and how expensive it is.&#xA;more varargs factory methods (e.g. Lists.newLinkedList(E...))&#xA;Almost all the cases we've encountered for this in reality would really have been better off with an immutable collection; they never actually changed the collection.&#xA;For the remaining cases, using a copy factory wrapped around Arrays.asList is a perfectly good one-line workaround. Alternatively, you are building a mutable collection, so you can afford to use e.g. Collections.addAll(Collection&lt;E>, E...).&#xA;create a map from an Iterable&lt;Pair>, Iterable&lt;Map.Entry>, Object[] (alternating keys and values), or from List&lt;K> + List&lt;V>&#xA;TODO(kevinb): fill in&#xA;Note that we may still add ImmutableMap.copyOf(Iterable&lt;Entry>).&#xA;Lists.equalIgnoringOrder(list1, list2)&#xA;As Kevin stated on StackOverflow, &quot;the fact that you want to do this in the first place is a strong signal that you want one or both of these collections to be represented as Multisets in the first place. They cannot really logically be Lists if you don't care about their order. If you do represent both as Multisets, then guess what? You've got your single-method-call solution!&quot;&#xA;The single-line solution for any arbitrary pair of Iterables, by the way, is&#xA;return ImmutableMultiset.copyOf(elems1).equals(ImmutableMultiset.copyOf(elems2));&#xA;which is linear-time, linear-memory, and makes those costs obvious up front.&#xA;Iterables.countMatching(Iterable, Predicate)&#xA;A fully equivalent solution is&#xA;return Iterables.size(Iterables.filter(iterable, predicate));&#xA;Sets.transform()&#xA;See  issue 219 .&#xA;A Set with a slow contains method is a non-starter, and a Function isn't necessarily bijective. Prefer&#xA;ImmutableSet.copyOf(Collections2.transform(set, func));&#xA;Persistent mutable collections/mutation methods on immutable collections&#xA;Wikipedia defines a persistent data structure as one which &quot;always preserves the previous version of itself when it is modified.&quot; Efficient persistent data structures are a well-known area of research, and many sophisticated structures are known.&#xA;Guava's immutable collections, on the other hand, are not designed as persistent data structures. They are designed to implement -- extremely efficiently, both in terms of CPU time and memory -- collections which do not change, in any way, after being built, and they aim to be at least as efficient as the corresponding mutable collection types. Rewriting these data structures for persistence would entail significant constant-factor (or worse) overhead to the overwhelming majority of users of these types.&#xA;While it might be possible to provide a parallel API to support inefficiently modifying Guava immutable collections -- e.g. a method on ImmutableList to create a copied ImmutableList with a new element added -- we feel this is only likely to confuse users who expect those methods to have sublinear performance, and assume we have implemented efficient persistent data structures.&#xA;Alternatives include using a traditional mutable collection, explicitly creating a new immutable collection with a builder, or using another Java library specifically intended to provide persistent data structures.&#xA; owner: kevinb@google.com&#xA; last update: Jan 30, 2014"/>
    <pages name="Release16" body="summary: Release notes for Guava Release 16.0&#xA;Guava Release 16.0: Release Notes&#xA;Release 16.0.1 was released on February 3, 2014. Release 16.0 was released on January 17, 2014. Release 16.0-rc1 was released on December 19, 2013.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release is identified in the Maven Central repository as com.google.guava:guava:16.0.1 and com.google.guava:guava-gwt:16.0.1&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-16.0.1.jar guava-gwt-16.0.1.jar (for GWT users) guava-16.0.1-javadoc.jar (Javadoc) guava-16.0.1-sources.jar (Source)&#xA;Issues resolved&#xA;14 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 15.0&#xA;To build a combined report of the API changes between release 16.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions&#xA;common.base&#xA;Ascii.equalsIgnoreCase&#xA;Ascii.truncate&#xA;Converter&#xA;CaseFormat.converterTo(CaseFormat)&#xA;Enums.stringConverter&#xA;Utf8&#xA;common.collect&#xA;MultimapBuilder&#xA;Maps.asConverter(BiMap)&#xA;common.eventbus&#xA;SubscriberExceptionHandler&#xA;common.hash&#xA;HashingInputStream&#xA;HashingOutputStream&#xA;common.io&#xA;ByteSource.read(ByteProcessor)&#xA;CharSource.readLines(LineProcessor)&#xA;common.primitives&#xA;Booleans.countTrue(boolean...)&#xA;stringConverter() for Ints, Longs, Doubles, Floats and Shorts&#xA;common.reflect&#xA;ClassPath.getAllClasses()&#xA;common.util.concurrent&#xA;Runnables.doNothing()&#xA;Significant API changes&#xA;In common.io, InputSupplier and OutputSupplier and all methods that take one or the other as a parameter have been deprecated. ByteSource, CharSource, ByteSink and CharSink should be used instead. The methods will be removed in two releases (18.0) and the interfaces are scheduled to be removed after 18 months, in June 2015.&#xA; owner: cgdecker@google.com&#xA; last update: Apr 23, 2014"/>
    <pages name="UseGuavaInYourBuild" body="summary: How to use Guava from different Build systems&#xA;Developers may use several different kinds of build system to compile/package their code. Guava can be used with any of them. For any code snippet below, please substitute the version given with the version of Guava you wish to use.&#xA;Maven&#xA;Apache Maven is a system for building projects and source code into deployment binaries, executing tests, and other software assembly lifecycle actions. It supports managed dependencies from central and private repositories. Guava is deployed to the common maven repositories, so to use it, you need only add the following snippet to the &lt;dependencies /> section of the project's pom.xml file.&#xA;&lt;dependency>&#xA;    &lt;groupId>com.google.guava&lt;/groupId>&#xA;    &lt;artifactId>guava&lt;/artifactId>&#xA;    &lt;version>12.0&lt;/version>&#xA;&lt;/dependency>&#xA;JSR-305 note: If you are using JSR-305 annotations (Guava's only dependency) in your own code, you must declare that dependency directly.&#xA;Scala note: The Scala compiler, unlike the Java compiler, requires that annotations used by a library be available when compiling against that library. If you are compiling with Scala, you must declare a dependency on JSR-305.&#xA;Gradle&#xA;Gradle is a build system that uses a domain specific language to construct instructions on how to build, test, assemble, deploy software from source. It supports managed dependencies and can make use of the maven repository for software artifacts. In order to use guava from Gradle, one must ensure the maven standard repositories are available like so:&#xA;repositories {&#xA;  mavenCentral()&#xA;}&#xA;Then one can add the guava dependency in the dependencies section like so:&#xA;dependencies {&#xA;  compile group: 'com.google.guava', name: 'guava', version: '12.0'&#xA;}&#xA;JSR-305 note: If you are using JSR-305 annotations (Guava's only dependency) in your own code, you must declare that dependency directly.&#xA;Scala note: The Scala compiler, unlike the Java compiler, requires that annotations used by a library be available when compiling against that library. If you are compiling with Scala, you must declare a dependency on JSR-305.&#xA;Ivy&#xA;Ivy is a dependency management system for builds. Ivy users should add the following line to the dependencies section of the ivy.xml file for any module that depends on Guava:&#xA;&lt;dependency org=&quot;com.google.guava&quot; name=&quot;guava&quot; rev=&quot;12.0&quot; />&#xA;and make sure that the &quot;public&quot; resolver is used.&#xA;JSR-305 note: If you are using JSR-305 annotations (Guava's only dependency) in your own code, you must declare that dependency directly.&#xA;Scala note: The Scala compiler, unlike the Java compiler, requires that annotations used by a library be available when compiling against that library. If you are compiling with Scala, you must declare a dependency on JSR-305.&#xA;Buildr&#xA;With Buildr, include this:&#xA;compile.with 'com.google.guava:guava:jar:10.0.1'&#xA;JSR-305 note: If you are using JSR-305 annotations (Guava's only dependency) in your own code, you must declare that dependency directly.&#xA;Scala note: The Scala compiler, unlike the Java compiler, requires that annotations used by a library be available when compiling against that library. If you are compiling with Scala, you must declare a dependency on JSR-305.&#xA;Manual Dependencies&#xA;You can also just manually download JARs for the classes, sources and javadocs. See the appropriate release page, e.g. Release10.&#xA;What about GWT?&#xA;In all the examples above, leave &quot;com.google.guava&quot; as it is but replace the other occurrence of &quot;guava&quot; with &quot;guava-gwt&quot;.&#xA; owner: cpov...@google.com&#xA; last update: Aug 30, 2012"/>
    <pages name="Release18" body="summary: Release notes for Guava Release 18.0&#xA;Guava Release 18.0: Release Notes&#xA;18.0 was released on August 25, 2014 18.0-rc2 was released on August 18, 2014. 18.0-rc1 was released on August 5, 2014.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;Note: As of Guava 18, we will no longer be releasing JDK5 backports.&#xA;Guava Guava (GWT) Maven Identifier com.google.guava:guava:18.0 com.google.guava:guava-gwt:18.0 Jar guava-18.0.jar guava-gwt-18.0.jar Javadoc guava-18.0-javadoc.jar guava-gwt-18.0-javadoc.jar Sources guava-18.0-sources.jar guava-gwt-18.0-sources.jar&#xA;&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;Issues resolved&#xA;16 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 17.0.&#xA;To build a combined report of the API changes between release 18.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions and changes&#xA;common.base&#xA;MoreObjects Methods in Objects which do not have equivalents in java.util.Objects have been moved to MoreObjects to allow importing of both classes. Those methods have been deprecated in our Objects class. Methods which do have equivalents in java.util.Objects will remain (undeprecated) in our Objects class as long as Guava continues to support JDK 6.&#xA;Converter.andThen(Converter&lt;B, C>) Enums - removed deprecated valueOfFunction` method.&#xA;common.collect&#xA;FluentIterable.of(E[]) FluentIterable.append(E...) FluentIterable.append(Iterable&lt;? extends E>) FluentIterable.join(Joiner)&#xA;common.hash&#xA;Hashing.crc32c()&#xA;BloomFilter no longer recognizes the system property com.google.common.hash.BloomFilter.useMitz32 (see Release 17 - A note on BloomFilter for more information).&#xA;common.io&#xA;Methods which took an InputSupplier or OutputSupplier parameter or which returned an InputSupplier or OutputSupplier (all of which were deprecated in Guava 15.0) have been removed. Additionally, ByteSource, ByteSink, CharSource and CharSink no longer implement InputSupplier or OutputSupplier.&#xA;The InputSupplier and OutputSupplier interfaces, which no longer have any usages in Guava, will be deleted in December 2015.&#xA;common.net&#xA;InetAddresses.decrement(InetAddress)&#xA;common.reflect&#xA;Parameter.getAnnotationsByType(Class&lt;A>) Parameter.getDeclaredAnnotation(Class&lt;A>) Parameter.getDeclaredAnnotationsByType(Class&lt;A>)&#xA;common.util.concurrent&#xA;MoreExecutors.directExecutor() - lightweight, simple Executor that runs tasks on the thread that invokes execute. MoreExecutors.newDirectExecutorService() - heavier ListeningExecutorService implementation of the same thing; equivalent to sameThreadExecutor(), which has been deprecated.&#xA; owner: cgdecker@google.com&#xA; last update: Aug 25, 2014"/>
    <pages name="Release13" body="summary: Release notes for Guava Release 13.0&#xA;Guava Release 13.0: Release Notes&#xA;Release 13.0 was released on August 3, 2012.&#xA;Release 13.0.1 was released on August 28, 2012.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release will be identified in the Maven Central repository as com.google.guava:guava:13.0.1 and com.google.guava:guava-gwt:13.0.1&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-13.0.1.jar guava-gwt-13.0.1.jar (for GWT users) guava-13.0.1-javadoc.jar (Javadoc) guava-13.0.1-sources.jar (Source)&#xA;Note: Release 13 removes transitivity of the JSR-305 artifact (commonly used for @Nullable). Please provide your own direct dependency on this if you declare things in your own code @Nullable. More detail below.&#xA;Issues resolved&#xA;18 issues are resolved in this release.&#xA;Changes between 13.0 and 13.0.1&#xA;Fixed guava-gwt artifact.&#xA;API Changes&#xA;Full JDiff Report of changes since release 12.0&#xA;To build a combined report of the API changes between release 13.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions&#xA;Added RateLimiter.&#xA;Added Striped.&#xA;Added FluentIterable.toSortedImmutableList and transformAndConcat.&#xA;Added ContiguousSet.create(Range, DiscreteDomain).&#xA;Added Maps.synchronizedNavigableMap.&#xA;Added Sets.synchronizedNavigableSet.&#xA;Added Ordering.allEqual&#xA;Added Funnels.asOutputStream, integerFunnel and longFunnel.&#xA;Added DoubleMath.fuzzyCompare and fuzzyEquals.&#xA;Added a few more constants to MediaType.&#xA;Added UnsignedBytes.parseUnsignedByte, toString and MAX_VALUE.&#xA;Added UnsignedInts.decode.&#xA;Added UnsignedLongs.decode.&#xA;Added CycleDetectingLockFactory.&#xA;Added Service.Listener and addListener.&#xA;Added Futures.dereference.&#xA;Added ImmutableTypeToInstanceMap and MutableTypeToInstanceMap&#xA;Significant API changes&#xA;Iterators.skip was deprecated in favor of Iterators.advance&#xA;The static methods on Equivalences were deprecated in favor of instance methods on Equivalence.&#xA;Removed Files.getDigest and ByteStreams.getDigest in favor of Files.hash and ByteStreams.hash.&#xA;Promoted from @Beta&#xA;SortedMap overloads for Maps.filter{Keys,Values,Entries}&#xA;SortedSet overloads for Sets.filter&#xA;Ascii.MIN and Ascii.MAX&#xA;Equivalence, Equivalence.Wrapper&#xA;Joiner.appendTo overloads for Iterator&#xA;Optional (though or(Optional), or(Supplier), transform(Function), and presentInstances(Iterable&lt;Optional>) are still @Beta)&#xA;Strings.common{Prefix, Suffix}&#xA;Lists.newCopyOnWriteArrayList&#xA;Sets.newCopyOnWriteArraySet&#xA;Multimaps.filter{Keys, Values, Entries}&#xA;Multisets.{contains, remove, retain}Occurrences&#xA;Tables (though newCustomTable, transformValues, and unmodifiableRowSortedTable are still @Beta)&#xA;Non-API changes&#xA;Made findbugs a provided dependency to avert dep conflicts when using findbugs 2.0. The side-effect of this change is that projects which relied upon Guava to grant access to the JSR-305 annotations &quot;for free&quot; will break unless they provide their own direct dependency on that jar (or an equivalent). Projects should always have been directly depending on JSR-305 (per maven best-practice), but this change makes that should into a must.&#xA;Caliper benchmarks for much of Guava have been open-sourced.&#xA;LinkedHashMultimap has been entirely rewritten, reducing its memory consumption by ~50%. (Previously, it was one of the worst potential memory hogs in the library.)&#xA;ImmutableSortedMultiset has been rewritten, reducing its memory consumption by ~40%.&#xA;ImmutableSortedMap has been rewritten, reducing its memory usage by ~50%.&#xA;Fixed a significant performance regression in LocalCache (12.0 was affected, but 12.0.1 was not)&#xA; owner: kak@google.com&#xA; last update: Dec 14, 2012"/>
    <pages name="GuavaExplained" body="summary: Landing page for Guava explanations.&#xA;User Guide&#xA;The Guava project contains several of Google's core libraries that we rely on in our Java-based projects: collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, and so forth. Each of these tools really do get used every day by Googlers, in production services.&#xA;But trawling through Javadoc isn't always the most effective way to learn how to make best use of a library. Here, we try to provide readable and pleasant explanations of some of the most popular and most powerful features of Guava.&#xA;This wiki is a work in progress, and parts of it may still be under construction.&#xA;Basic utilities: Make using the Java language more pleasant. Using and avoiding null: null can be ambiguous, can cause confusing errors, and is sometimes just plain unpleasant. Many Guava utilities reject and fail fast on nulls, rather than accepting them blindly. Preconditions: Test preconditions for your methods more easily. Common object methods: Simplify implementing Object methods, like hashCode() and toString(). Ordering: Guava's powerful &quot;fluent Comparator&quot; class. Throwables: Simplify propagating and examining exceptions and errors.&#xA;Collections: Guava's extensions to the JDK collections ecosystem. These are some of the most mature and popular parts of Guava. Immutable collections, for defensive programming, constant collections, and improved efficiency. New collection types, for use cases that the JDK collections don't address as well as they could: multisets, multimaps, tables, bidirectional maps, and more. Powerful collection utilities, for common operations not provided in java.util.Collections. Extension utilities: writing a Collection decorator? Implementing Iterator? We can make that easier.&#xA;Caches: Local caching, done right, and supporting a wide variety of expiration behaviors. Functional idioms: Used sparingly, Guava's functional idioms can significantly simplify code. Concurrency: Powerful, simple abstractions to make it easier to write correct concurrent code. ListenableFuture: Futures, with callbacks when they are finished. Service: Things that start up and shut down, taking care of the difficult state logic for you.&#xA;Strings: A few extremely useful string utilities: splitting, joining, padding, and more. Primitives: operations on primitive types, like int and char, not provided by the JDK, including unsigned variants for some types. Ranges: Guava's powerful API for dealing with ranges on Comparable types, both continuous and discrete. I/O: Simplified I/O operations, especially on whole I/O streams and files, for Java 5 and 6. Hashing: Tools for more sophisticated hashes than what's provided by Object.hashCode(), including Bloom filters. EventBus: Publish-subscribe-style communication between components without requiring the components to explicitly register with one another. Math: Optimized, thoroughly tested math utilities not provided by the JDK. Reflection: Guava utilities for Java's reflective capabilities. Tips: Getting your application working the way you want it to with Guava. Philosophy: what Guava is and isn't, and our goals. Using Guava in your build, with build systems including Maven, Gradle, and more. Using ProGuard to avoid bundling parts of Guava you don't use with your JAR. Apache Commons equivalents, helping you translate code from using Apache Commons Collections. Compatibility, details between Guava versions. Idea Graveyard, feature requests that have been conclusively rejected. Friends, open-source projects we like and admire. HowToContribute, how to contribute to Guava.&#xA;&#xA;NOTE: To discuss the contents of this wiki, please just use the guava-discuss mailing list.&#xA; owner: kak@google.com&#xA; last update: May 6, 2014"/>
    <pages name="ImmutableCollectionsExplained" body="summary: Guava's immutable collections utilities, explained.&#xA;Example&#xA;public static final ImmutableSet&lt;String> COLOR_NAMES = ImmutableSet.of(&#xA;  &quot;red&quot;,&#xA;  &quot;orange&quot;,&#xA;  &quot;yellow&quot;,&#xA;  &quot;green&quot;,&#xA;  &quot;blue&quot;,&#xA;  &quot;purple&quot;);&#xA;&#xA;class Foo {&#xA;  final ImmutableSet&lt;Bar> bars;&#xA;  Foo(Set&lt;Bar> bars) {&#xA;    this.bars = ImmutableSet.copyOf(bars); // defensive copy!&#xA;  }&#xA;}&#xA;Why?&#xA;Immutable objects have many advantages, including:&#xA;Safe for use by untrusted libraries. Thread-safe: can be used by many threads with no risk of race conditions. Doesn't need to support mutation, and can make time and space savings with that assumption. All immutable collection implementations are more memory-efficient than their mutable siblings (analysis) Can be used as a constant, with the expectation that it will remain fixed&#xA;Making immutable copies of objects is a good defensive programming technique. Guava provides simple, easy-to-use immutable versions of each standard Collection type, including Guava's own Collection variations.&#xA;The JDK provides Collections.unmodifiableXXX methods, but in our opinion, these can be&#xA;unwieldy and verbose; unpleasant to use everywhere you want to make defensive copies unsafe: the returned collections are only truly immutable if nobody holds a reference to the original collection inefficient: the data structures still have all the overhead of mutable collections, including concurrent modification checks, extra space in hash tables, etc.&#xA;&#xA;When you don't expect to modify a collection, or expect a collection to remain constant, it's a good practice to defensively copy it into an immutable collection.&#xA;Important: Each of the Guava immutable collection implementations rejects null values. We did an exhaustive study on Google's internal code base that indicated that null elements were allowed in collections about 5% of the time, and the other 95% of cases were best served by failing fast on nulls. If you need to use null values, consider using Collections.unmodifiableList and its friends on a collection implementation that permits null. More detailed suggestions can be found here.&#xA;How?&#xA;An ImmutableXXX collection can be created in several ways:&#xA;using the copyOf method, for example, ImmutableSet.copyOf(set) using the of method, for example, ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) or ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2) using a Builder, for example,&#xA;public static final ImmutableSet&lt;Color> GOOGLE_COLORS =&#xA;       ImmutableSet.&lt;Color>builder()&#xA;           .addAll(WEBSAFE_COLORS)&#xA;           .add(new Color(0, 191, 255))&#xA;           .build();&#xA;&#xA;Except for sorted collections, order is preserved from construction time. For example,&#xA;ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;b&quot;)&#xA;will iterate over its elements in the order &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;.&#xA;copyOf is smarter than you think&#xA;It is useful to remember that ImmutableXXX.copyOf attempts to avoid copying the data when it is safe to do so -- the exact details are unspecified, but the implementation is typically &quot;smart&quot;. For example,&#xA;ImmutableSet&lt;String> foobar = ImmutableSet.of(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;);&#xA;thingamajig(foobar);&#xA;&#xA;void thingamajig(Collection&lt;String> collection) {&#xA;   ImmutableList&lt;String> defensiveCopy = ImmutableList.copyOf(collection);&#xA;   ...&#xA;}&#xA;In this code, ImmutableList.copyOf(foobar) will be smart enough to just return foobar.asList(), which is a constant-time view of the ImmutableSet.&#xA;As a general heuristic, ImmutableXXX.copyOf(ImmutableCollection) tries to avoid a linear-time copy if&#xA;it's possible using the underlying data structures in constant time. For example, ImmutableSet.copyOf(ImmutableList) can't be done in constant time. it wouldn't cause memory leaks -- for example, if you have ImmutableList&lt;String> hugeList, and you do ImmutableList.copyOf(hugeList.subList(0, 10)), an explicit copy is performed, so as to avoid accidentally holding on to references in hugeList that aren't needed. it won't change semantics -- so ImmutableSet.copyOf(myImmutableSortedSet) will perform an explicit copy, because the hashCode() and equals used by ImmutableSet have different semantics from the comparator-based behavior of ImmutableSortedSet.&#xA;This helps minimize the performance overhead of good defensive programming style.&#xA;asList&#xA;All immutable collections provide an ImmutableList view via asList(), so -- for example -- even if you have data stored as an ImmutableSortedSet, you can get the kth smallest element with sortedSet.asList().get(k).&#xA;The returned ImmutableList is frequently -- not always, but frequently -- a constant-overhead view, rather than an explicit copy. That said, it's often smarter than your average List -- for example, it'll use the efficient contains methods of the backing collection.&#xA;Details&#xA;Where?&#xA;Interface JDK or Guava? Immutable Version Collection JDK ImmutableCollection List JDK ImmutableList Set JDK ImmutableSet SortedSet/NavigableSet JDK ImmutableSortedSet Map JDK ImmutableMap SortedMap JDK ImmutableSortedMap Multiset Guava ImmutableMultiset SortedMultiset Guava ImmutableSortedMultiset Multimap Guava ImmutableMultimap ListMultimap Guava ImmutableListMultimap SetMultimap Guava ImmutableSetMultimap BiMap Guava ImmutableBiMap ClassToInstanceMap Guava ImmutableClassToInstanceMap Table Guava ImmutableTable&#xA; owner: cgdec...@gmail.com&#xA; last update: Jul 1, 2014"/>
    <pages name="Compatibility" body="summary: Can upgrading the version of Guava I use break my build?&#xA;Android&#xA;Mainline Guava has targeted Java 6 since v12.0 (to support NavigableSet and other new APIs). Guava users who target Java 5 should use the guava_jdk5 backport. This includes users who target Android Froyo and earlier.&#xA;(Android programmers concerned with Guava's large JAR size are advised to use ProGuard to get only the parts of Guava they need. Guava is one of the most common dependencies for Android applications.)&#xA;GWT&#xA;Much of Guava is compatible with Google Web Toolkit (GWT), though we do not currently optimize code specifically for GWT. Guava APIs compatible with GWT are marked with the annotation @GwtCompatible.&#xA;Basics&#xA;Our README file covers the basics: The only features we'll ever remove are @Deprecated and, occasionally, @Beta methods and classes.&#xA;&quot;Source-compatible since Guava release xx&quot;&#xA;Sometimes we will add a more specific overload of an existing method. Code compiled against the old version of Guava will still run against the new version of Guava. Additionally, any code that compiles against the new version of Guava will also compile against the old version of Guava. However, code compiled against the new version of Guava might not run against the old version because it may compile against the new overload.&#xA;An example of this is Objects.toStringHelper, which originally accepted an Object but which now has String and Class overloads, as well. Object.toStringHelper(anything) compiles under any version of Guava, but if the static type of anything is String or Class, a compile against a recent Guava version will select a new overload.&#xA;&quot;Mostly source-compatible since Guava release xx&quot;&#xA;As of this writing, there are two causes of this:&#xA;First, we sometimes change a @Beta interface to a class. Simple anonymous uses like new Foo() { ... } will continue to compile, but named classes will not. In neither case is the result binary compatible.&#xA;Second, we sometimes replace a @Beta method with a version that returns a more specific type. In this case, code compiled against a version of Guava from before the change might not run against a version of Guava from after the change, and vice versa. However, code that compiles against the old version of Guava will almost always compile against the new version of Guava. (The reverse is often true, too, when the code doesn't take advantage of the new return type.)&#xA;However, there are rare exceptions. Consider this fictional case:&#xA;Guava release n:&#xA;public static List&lt;Integer> newList() { ... }&#xA;Guava release n + 1:&#xA;public static ArrayList&lt;Integer> newList() { ... }&#xA;Most callers will compile fine against either version:&#xA;List&lt;Integer> myList = newList();&#xA;Of course, if a caller uses the new, specific type, that code won't compile against the old version:&#xA;ArrayList&lt;Integer> myList = newList();&#xA;The more interesting case, though, is code that compiles against the old version but not the new version:&#xA;Set&lt;List&lt;Integer>> myLists = ImmutableSet.of(newList());&#xA;Java's type inference isn't strong enough for ImmutableSet.of() to realize that it should treat its input as a List&lt;Integer> instead of an ArrayList&lt;Integer>, so the code must be rewritten:&#xA;Set&lt;ArrayList&lt;Integer>> myLists = ImmutableSet.of(newList());&#xA;Or, to produce code that compiles against either version of Guava:&#xA;Set&lt;List&lt;Integer>> myLists = ImmutableSet.&lt;List&lt;Integer>>of(newList());&#xA;Or, equivalently:&#xA;List&lt;Integer> myList = newList();&#xA;Set&lt;List&lt;Integer>> myLists = ImmutableSet.of(myList);&#xA; owner: lu...@google.com&#xA; last update: Jul 6, 2014"/>
    <pages name="ServiceExplained" body="summary: The Guava Service abstraction, explained.&#xA;Overview&#xA;The Guava Service interface represents an object with an operational state, with methods to start and stop. For example, webservers, RPC servers, and timers can implement the Service interface. Managing the state of services like these, which require proper startup and shutdown management, can be nontrivial, especially if multiple threads or scheduling is involved. Guava provides some skeletons to manage the state logic and synchronization details for you.&#xA;Using a Service&#xA;The normal lifecycle of a Service is&#xA;Service.State.NEW to Service.State.STARTING to Service.State.RUNNING to Service.State.STOPPING to Service.State.TERMINATED&#xA;A stopped service may not be restarted. If the service fails where starting, running, or stopping, it goes into state Service.State.FAILED.&#xA;A service can be started asynchronously using startAsync(), which returns this to enable method chaining. It is only valid to call startAsync() if the service is NEW. So you should structure your application to have a unique place where each service is started.&#xA;Stopping the service is analogous, using the asynchronous stopAsync() method. But unlike startAsync(), it is safe to call this method multiple times. This is to make it possible to handle races that may occur when shutting down services.&#xA;Service also provides several methods to wait for service transitions to complete.&#xA;asynchronously using addListener(). addListener() allows you to add a Service.Listener that will be invoked on every state transition of the service. N.B. if a service is not NEW when the listener is added, then any state transitions that have already occurred will not be replayed on the listener. synchronously using awaitRunning(). This is uninterruptible, throws no checked exceptions, and returns once the service has finished starting. If the service fails to start, this throws an IllegalStateException. Similarly, awaitTerminated() waits for the service to reach a terminal state (TERMINATED or FAILED). Both methods also have overloads that allow timeouts to be specified.&#xA;&#xA;The Service interface is subtle and complicated. We do not recommend implementing it directly. Instead please use one of the abstract base classes in guava as the base for your implementation. Each base class supports a specific threading model.&#xA;Implementations&#xA;AbstractIdleService&#xA;The AbstractIdleService skeleton implements a Service which does not need to perform any action while in the &quot;running&quot; state -- and therefore does not need a thread while running -- but has startup and shutdown actions to perform. Implementing such a service is as easy as extending AbstractIdleService and implementing the startUp() and shutDown() methods.&#xA;protected void startUp() {&#xA;  servlets.add(new GcStatsServlet());&#xA;}&#xA;protected void shutDown() {}&#xA;Note that any queries to the GcStatsServlet already have a thread to run in. We don't need this service to perform any operations on its own while the service is running.&#xA;AbstractExecutionThreadService&#xA;An AbstractExecutionThreadService performs startup, running, and shutdown actions in a single thread. You must override the run() method, and it must respond to stop requests. For example, you might perform actions in a work loop:&#xA;public void run() {&#xA;  while (isRunning()) {&#xA;    // perform a unit of work&#xA;  }&#xA;}&#xA;Alternately, you may override triggerShutdown() in any way that causes run() to return.&#xA;Overriding startUp() and shutDown() is optional, but the service state will be managed for you.&#xA;protected void startUp() {&#xA;  dispatcher.listenForConnections(port, queue);&#xA;}&#xA;protected void run() {&#xA;  Connection connection;&#xA;  while ((connection = queue.take() != POISON)) {&#xA;    process(connection);&#xA;  }&#xA;}&#xA;protected void triggerShutdown() {&#xA;  dispatcher.stopListeningForConnections(queue);&#xA;  queue.put(POISON);&#xA;}&#xA;Note that start() calls your startUp() method, creates a thread for you, and invokes run() in that thread. stop() calls triggerShutdown() and waits for the thread to die.&#xA;AbstractScheduledService&#xA;An AbstractScheduledService performs some periodic task while running. Subclasses implement runOneIteration() to specify one iteration of the task, as well as the familiar startUp and shutDown() methods.&#xA;To describe the execution schedule, you must implement the scheduler() method. Typically, you will use one of the provided schedules from AbstractScheduledService.Scheduler, either newFixedRateSchedule(initialDelay, delay, TimeUnit) or newFixedDelaySchedule(initialDelay, delay, TimeUnit), corresponding to the familiar methods in ScheduledExecutorService. Custom schedules can be implemented using CustomScheduler; see the Javadoc for details.&#xA;AbstractService&#xA;When you need to do your own manual thread management, override AbstractService directly. Typically, you should be well served by one of the above implementations, but implementing AbstractService is recommended when, for example, you are modeling something that provides its own threading semantics as a Service, you have your own specific threading requirements.&#xA;To implement AbstractService you must implement 2 methods.&#xA;doStart(): doStart() is called directly by the first call to startAsync(), your doStart() method should perform all initialization and then eventually call notifyStarted() if start up succeeded or notifyFailed() if start up failed. doStop(): doStop() is called directly by the first call to stopAsync(), your doStop() method should shut down your service and then eventually call notifyStopped() if shutdown succeeded or notifyFailed() if shutdown failed.&#xA;&#xA;Your doStart and doStop, methods should be fast. If you need to do expensive initialization, such as reading files, opening network connections, or any operation that might block, you should consider moving that work to another thread.&#xA;Using ServiceManager&#xA;In addition to the Service skeleton implementations, Guava provides a ServiceManager class that makes certain operations involving multiple Service implementations easier. Create a new ServiceManager with a collection of Services. Then you can manage them:&#xA;startAsync() will start all the services under management. Much like Service#startAsync() you can only call this method once, if all services are NEW. stopAsync() will stop all the services under management. addListener will add a ServiceManager.Listener that will be called on major state transitions. awaitHealthy() will wait for all services to reach the RUNNING state. awaitStopped() will wait for all services to reach a terminal state.&#xA;Or inspect them:&#xA;isHealthy() returns true if all services are RUNNING. servicesByState() returns a consistent snapshot of all the services indexed by their state. startupTimes() returns a map from Service under management to how long it took for that service to start in milliseconds. The returned map is guaranteed to be ordered by startup time.&#xA;&#xA;While it is recommended that service lifecycles be managed via ServiceManager, state transitions initiated via other mechanisms do not impact the correctness of its methods. For example, if the services are started by some mechanism besides startAsync(), the listeners will be invoked when appropriate and awaitHealthy() will still work as expected. The only requirement that ServiceManager enforces is that all Services must be NEW when `ServiceManager is constructed.&#xA; owner: cgdecker@google.com&#xA; last update: Aug 26, 2014"/>
    <pages name="Release12" body="summary: Release notes for Guava Release 12.0&#xA;Guava Release 12.0: Release Notes&#xA;Release 12.0 was released on April 30, 2012. Release 12.0.1 was released on July 10, 2012. (See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release will be identified in the Maven Central repository as com.google.guava:guava:12.0.1 and com.google.guava:guava-gwt:12.0.1&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-12.0.1.jar guava-gwt-12.0.1.jar (for GWT users) guava-12.0.1-javadoc.jar (Javadoc) guava-12.0.1-sources.jar (Source)&#xA;Issues resolved&#xA;43 issues are resolved in this release (a record, among somewhat on-time releases).&#xA;Notably, FinalizableReferenceQueue no longer keeps unused ClassLoader alive, an OGSi bundle is included, and CacheBuilder users must opt in to stats collection.&#xA;Changes between 12.0 and 12.0.1&#xA;Resolved a major performance regression in LoadingCache.&#xA;API Changes&#xA;Full JDiff Report of changes since release 11.0.2&#xA;To build a combined report of the API changes between release 12.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;CacheBuilder Cache stats&#xA;CacheBuilder users who use the Cache stats() method must now opt in by calling recordStats() (as of 12.0-rc2).&#xA;JDK6 APIs&#xA;Guava 12.0 is the first release to require JDK6. Users requiring JDK5 compatibility may continue to use Guava 11.0.2 -- or contact us about maintaining a backport.&#xA;Here are the new APIs introduced along with our JDK6 dependency:&#xA;ImmutableSortedSet implements NavigableSet; ImmutableSortedMap implements NavigableMap.&#xA;Added forwarding classes for Deque, NavigableMap, NavigableSet.&#xA;Added type-inferring factory methods: newArrayDeque, newLinkedBlockingDeque, newCopyOnWriteArrayList, newCopyOnWriteArraySet.&#xA;Added Maps.unmodifiableNavigableMap, Sets.unmodifiableNavigableSet.&#xA;Other significant API additions&#xA;Introducing common.reflect, especially TypeToken, a better java.lang.Class.&#xA;Introducing MediaType (which may be split into MediaType+MediaRange someday).&#xA;Introducing FluentIterable.&#xA;Introducing CacheBuilderSpec; see CacheBuilder.from(CacheBuilderSpec) and CacheBuilder.from(String) to make use of it.&#xA;Introducing ImmutableSortedMultiset.&#xA;Added Enums.getField, getIfPresent.&#xA;Added HashCodes.&#xA;Added BloomFilter.copy, equals, hashCode; plus, put now returns boolean.&#xA;Added Optional.transform.&#xA;Added ToStringHelper.omitNullValues.&#xA;Added Collections2.permutations, orderedPermutations.&#xA;Added FowardingSet.standardRemoveAll.&#xA;Added Cache.putAll.&#xA;Added JdkFutureAdapters.listenInPoolThread with custom executor.&#xA;Other significant API changes&#xA;Sink is renamed to PrimitiveSink. Implementations of Funnel will need to be updated.&#xA;AbstractLinkedIterator has been deprecated in favor of the identical AbstractSequentialIterator.&#xA;ByteStreams and Files getDigest methods have been deprecated in favor of new hash methods.&#xA;ComparisonChain.compare(boolean, boolean) has been deprecated in favor new compareFalseFirst/compareTrueFirst methods.&#xA;OSGi support&#xA;As of 12.0-rc2, Guava contains OSGi metadata.&#xA; owner: cpov...@google.com&#xA; last update: Sep 26, 2012"/>
    <pages name="ThrowablesExplained" body="summary: Guava's utilities on throwables, explained.&#xA;TODO: rewrite with more examples&#xA;Guava's Throwables utility can frequently simplify dealing with exceptions.&#xA;Propagation&#xA;Sometimes, when you catch an exception, you want to throw it back up to the next try/catch block. This is frequently the case for RuntimeException or Error instances, which do not require try/catch blocks, but can be caught by try/catch blocks when you don't mean them to.&#xA;Guava provides several utilities to simplify propagating exceptions. For example:&#xA;   try {&#xA;     someMethodThatCouldThrowAnything();&#xA;   } catch (IKnowWhatToDoWithThisException e) {&#xA;     handle(e);&#xA;   } catch (Throwable t) {&#xA;     Throwables.propagateIfInstanceOf(t, IOException.class);&#xA;     Throwables.propagateIfInstanceOf(t, SQLException.class);&#xA;     throw Throwables.propagate(t);&#xA;   }&#xA;Each of these methods throw the exception themselves, but throwing the result -- e.g. throw Throwables.propagate(t) -- can be useful to prove to the compiler that an exception will be thrown.&#xA;Here are quick summaries of the propagation methods provided by Guava:&#xA;Signature Explanation RuntimeException propagate(Throwable) Propagates the throwable as-is if it is a RuntimeException or an Error, or wraps it in a RuntimeException and throws it otherwise. Guaranteed to throw. The return type is a RuntimeException so you can write throw Throwables.propagate(t) as above, and Java will realize that that line is guaranteed to throw an exception. void propagateIfInstanceOf(Throwable, Class&lt;X extends Exception>) throws X Propagates the throwable as-is, if and only if it is an instance of X. void propagateIfPossible(Throwable) Throws throwable as-is only if it is a RuntimeException or an Error. void propagateIfPossible(Throwable, Class&lt;X extends Throwable>) throws X Throws throwable as-is only if it is a RuntimeException, an Error, or an X.&#xA;&#xA;Uses for Throwables.propagate&#xA;Emulating Java 7 multi-catch and rethrow&#xA;Typically, if a caller wants to let an exception propagate up the stack, he doesn't need a catch block at all. Since he's not going to recover from the exception, he probably shouldn't be logging it or taking other action. He may want to perform some cleanup, but usually that cleanup needs to happen regardless of whether the operation succeeded, so it ends up in a finally block. However, a catch block with a rethrow is sometimes useful: Maybe the caller must update a failure count before propagating an exception, or maybe he will propagate the exception only conditionally,&#xA;Catching and rethrowing an exception is straightforward when dealing with only one kind of exception. Where it gets messy is when dealing with multiple kinds of exceptions:&#xA;@Override public void run() {&#xA;  try {&#xA;    delegate.run();&#xA;  } catch (RuntimeException e) {&#xA;    failures.increment();&#xA;    throw e;&#xA;  } catch (Error e) {&#xA;    failures.increment();&#xA;    throw e;&#xA;  }&#xA;}&#xA;Java 7 solves this problem with multicatch:&#xA;  } catch (RuntimeException | Error e) {&#xA;    failures.increment();&#xA;    throw e;&#xA;  }&#xA;Non-Java 7 users are stuck. They'd like to write code like the following, but the compiler won't permit them to throw a variable of type Throwable:&#xA;  } catch (Throwable t) {&#xA;    failures.increment();&#xA;    throw t;&#xA;  }&#xA;The solution is to replace throw t with throw Throwables.propagate(t). In this limited circumstance, Throwables.propagate behaves identically to the original code. However, it's easy to write code with Throwables.propagate that has other, hidden behavior. In particular, note that the above pattern works only with RuntimeException and Error. If the catch block may catch checked exceptions, you'll also need some calls to propagateIfInstanceOf in order to preserve behavior, as Throwables.propagate can't directly propagate a checked exception.&#xA;Overall, this use of propagate is so-so. It's unnecessary under Java 7. Under other versions, it saves a small amount of duplication, but so could a simple Extract Method refactoring. Additionally, use of propagate makes it easy to accidentally wrap checked exceptions.&#xA;Unnecessary: Converting from throws Throwable to throws Exception&#xA;A few APIs, notably the Java reflection API and (as a result) JUnit, declare methods that throw Throwable. Interacting with these APIs can be a pain, as even the most general-purpose APIs typically only declare throws Exception. Throwables.propagate is used by some callers who know they have a non-Exception, non-Error Throwable. Here's an example of declaring a Callable that executes a JUnit test:&#xA;public Void call() throws Exception {&#xA;  try {&#xA;    FooTest.super.runTest();&#xA;  } catch (Throwable t) {&#xA;    Throwables.propagateIfPossible(t, Exception.class);&#xA;    Throwables.propagate(t);&#xA;  }&#xA;&#xA;  return null;&#xA;}&#xA;There's no need for propagate() here, as the second line is equivalent to throw new RuntimeException(t). (Digression: This example also reminds me that propagateIfPossible is potentially confusing, since it propagates not just arguments of the given type but also Errors and RuntimeExceptions.)&#xA;This pattern (or similar variants like throw new RuntimeException(t)) shows up ~30 times in Google's codebase. (Search for 'propagateIfPossible[^;]* Exception.class[)];'.) A slight majority of them take the explicit throw new RuntimeException(t) approach. It's possible that we would want a throwWrappingWeirdThrowable method for Throwable-to-Exception conversions, but given the two-line alternative, there's probably not much need unless we were to also deprecate propagateIfPossible.&#xA;Controversial uses for Throwables.propagate&#xA;Controversial: Converting checked exceptions to unchecked exceptions&#xA;In principle, unchecked exceptions indicate bugs, and checked exceptions indicate problems outside your control. In practice, even the JDK sometimes gets it wrong (or at least, for some methods, no answer is right for everyone).&#xA;As a result, callers occasionally have to translate between exception types:&#xA;try {&#xA;  return Integer.parseInt(userInput);&#xA;} catch (NumberFormatException e) {&#xA;  throw new InvalidInputException(e);&#xA;}&#xA;try {&#xA;  return publicInterfaceMethod.invoke();&#xA;} catch (IllegalAccessException e) {&#xA;  throw new AssertionError(e);&#xA;}&#xA;Sometimes, those callers use Throwables.propagate. What are the disadvantages? The main one is that the meaning of the code is less obvious. What does throw Throwables.propagate(ioException) do? What does throw new RuntimeException(ioException) do? The two do the same thing, but the latter is more straightforward. The former raises questions: &quot;What does this do? It isn't just wrapping in RuntimeException, is it? If it were, why would they write a method wrapper?&quot; Part of the problem here, admittedly, is that &quot;propagate&quot; is a vague name. (Is it a way of throwing undeclared exceptions?) Perhaps &quot;wrapIfChecked&quot; would have worked better. Even if the method were called that, though, there would be no advantage to calling it on a known checked exception. There may even be additional downsides: Perhaps there's a more suitable type than a plain RuntimeException for you to throw -- say, IllegalArgumentException.&#xA;We sometimes also see propagate used when the exception only might be a checked exception. The result is slightly smaller and slightly less straightforward than the alternative:&#xA;} catch (RuntimeException e) {&#xA;  throw e;&#xA;} catch (Exception e) {&#xA;  throw new RuntimeException(e);&#xA;}&#xA;} catch (Exception e) {&#xA;  throw Throwables.propagate(e);&#xA;}&#xA;However, the elephant in the room here is the general practice of converting checked exceptions to unchecked exceptions. It is unquestionably the right thing in some cases, but more frequently it's used to avoid dealing with a legitimate checked exception. This leads us to the debate over whether checked exceptions are bad idea in general. I don't wish to go into all that here. Suffice it to say that Throwables.propagate does not exist for the purpose of encouraging Java users to ignore IOException and the like.&#xA;Controversial: Exception tunneling&#xA;But what about when you're implementing a method that isn't allowed to throw exceptions? Sometimes you need to wrap your exception in an unchecked exception. This is fine, but again, propagate is unnecessary for simple wrapping. In fact, manual wrapping may be preferable: If you wrap every exception (instead of just checked exceptions), then you can unwrap every exception on the other end, making for fewer special cases. Additionally, you may wish to use a custom exception type for the wrapping.&#xA;Controversial: Rethrowing exceptions from other threads&#xA;try {&#xA;  return future.get();&#xA;} catch (ExecutionException e) {&#xA;  throw Throwables.propagate(e.getCause());&#xA;}&#xA;There are multiple things to consider here:&#xA;The cause may be a checked exception. See &quot;Converting checked exceptions to unchecked exceptions&quot; above. But what if the task is known not to throw a checked exception? (Maybe it's the result of a Runnable.) As discussed above, you can catch the exception and throw AssertionError; propagate has little more to offer. For Future in particular, also consider Futures.get. (TODO: say something about its additional InterruptedException behavior) The cause may be a non-Exception, non-Error Throwable. (Well, it's unlikely to actually be one, but the compiler would force you to consider the possibility if you tried to rethrow it directly.) See &quot;Converting from throws Throwable to throws Exception&quot; above. The cause may be an unchecked exception or error. If so, it will be rethrown directly. Unfortunately, its stack trace will reflect the thread in which the exception was originally created, not the thread in which it is currently propagating. It's typically best to have include both threads' stack traces available in the exception chain, as in the ExecutionException thrown by get. (This problem isn't really about propagate; it's about any code that rethrows an exception in a different thread.)&#xA;Causal Chain&#xA;Guava makes it somewhat simpler to study the causal chain of an exception, providing three useful methods whose signatures are self-explanatory:&#xA;Throwable getRootCause(Throwable) List&lt;Throwable> getCausalChain(Throwable) String getStackTraceAsString(Throwable)&#xA; owner: cpov...@google.com&#xA; last update: Mar 13, 2014"/>
    <pages name="Release15" body="summary: Release notes for Guava Release 15.0&#xA;Guava Release 15.0: Release Notes&#xA;Release 15.0 was release on September 06, 2013. Release 15.0-rc1 was released on August 26, 2013.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release will be identified in the Maven Central repository as com.google.guava:guava:15.0 and com.google.guava:guava-gwt:15.0&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-15.0.jar guava-gwt-15.0.jar (for GWT users) guava-15.0-javadoc.jar (Javadoc) guava-15.0-sources.jar (Source)&#xA;A note on JEE6 / CDI 1.0&#xA;A workaround added in Guava 15.0 to make it compatible with CDI 1.1 (used in JEE7 containers) caused problems for Guava with CDI 1.0 (used in JEE6 containers).&#xA;If you're using Guava in a CDI 1.0 environment, you should use guava-15.0-cdi1.0.jar instead of the normal Guava jar. In Maven, the dependency can be specified as:&#xA;&lt;dependency>&#xA;  &lt;groupId>com.google.guava&lt;/groupId>&#xA;  &lt;artifactId>guava&lt;/artifactId>&#xA;  &lt;version>15.0&lt;/version>&#xA;  &lt;classifier>cdi1.0&lt;/classifier>&#xA;&lt;/dependency>&#xA;Issues resolved&#xA;38 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 14.0.1&#xA;To build a combined report of the API changes between release 15.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions&#xA;common.escape (new)&#xA;Escaper, Escapers, various simple Escaper implementations.&#xA;common.html (new)&#xA;HtmlEscapers&#xA;common.xml (new)&#xA;XmlEscapers&#xA;common.base&#xA;StandardSystemProperty&#xA;Splitter.splitToList&#xA;common.collect&#xA;TreeTraverser, BinaryTreeTraverser&#xA;EvictingQueue&#xA;Multimaps.asMap&#xA;Queues.synchronizedDeque&#xA;Sets.newConcurrentHashSet&#xA;common.hash&#xA;Funnels.sequentialFunnel&#xA;common.io&#xA;ByteSource.concat, empty, isEmpty&#xA;CharSource.concat, empty, isEmpty&#xA;CharStreams.nullWriter&#xA;Files.fileTreeTraverser, isDirectory, isFile&#xA;common.math&#xA;DoubleMath.mean&#xA;common.net&#xA;UrlEscapers&#xA;common.reflect&#xA;TypeResolver&#xA;common.util.concurrent&#xA;ListenableScheduledFuture&#xA;Significant API changes&#xA;The Stopwatch constructors have been deprecated in favor of static createStarted() and createUnstarted() methods.&#xA;The Constraint interface and methods in Constraints have been deprecated.&#xA;The static methods in HashCodes have been moved to HashCode.&#xA;HashFunction.hashString, Hasher.putString and Funnels.stringFunnel overloads that do not take a Charset have been renamed to hashUnencodedChars, putUnencodedChars and unencodedCharsFunnel, respectively.&#xA;ByteSource, ByteSink, CharSource and CharSink have temporarily been changed to implement InputSupplier and OutputSupplier. Additionally, ByteStreams.asByteSource(InputSupplier), ByteStreams.asByteSink(OutputSupplier), CharStreams.asCharSource(InputSupplier) and CharStreams.asCharSink(OutputSupplier) methods have been added to adapt existing Suppliers to Sources and Sinks. These changes are all intended to help make migration easier and will be reverted in a future release.&#xA;ByteStreams.asByteSource(byte[]) has been moved to ByteSource.wrap(byte[]). CharStreams.asCharSource(String) has been moved to CharSource.wrap(CharSequence).&#xA;Some changes have been made to the Service interface. start(), startAndWait(), stop() and stopAndWait() have been deprecated in favor of new startAsync(), stopAsync(), awaitRunning() and awaitTerminated() methods.&#xA;Other notable changes&#xA;Ordering.natural now always delegates directly to compareTo without checking for identical inputs first. This should affect only broken classes whose compareTo implementations treat an object as unequal to itself (that is, that are non-reflexive).&#xA; owner: cgdecker@google.com&#xA; last update: Jan 17, 2014"/>
    <pages name="FunctionalExplained" body="summary: Functional idioms in Guava, explained.&#xA;Caveats&#xA;As of Java 7, functional programming in Java can only be approximated through awkward and verbose use of anonymous classes. This is expected to change in Java 8, but Guava is currently aimed at users of Java 5 and above.&#xA;Excessive use of Guava's functional programming idioms can lead to verbose, confusing, unreadable, and inefficient code. These are by far the most easily (and most commonly) abused parts of Guava, and when you go to preposterous lengths to make your code &quot;a one-liner,&quot; the Guava team weeps.&#xA;Compare the following code:&#xA;Function&lt;String, Integer> lengthFunction = new Function&lt;String, Integer>() {&#xA;  public Integer apply(String string) {&#xA;    return string.length();&#xA;  }&#xA;};&#xA;Predicate&lt;String> allCaps = new Predicate&lt;String>() {&#xA;  public boolean apply(String string) {&#xA;    return CharMatcher.JAVA_UPPER_CASE.matchesAllOf(string);&#xA;  }&#xA;};&#xA;Multiset&lt;Integer> lengths = HashMultiset.create(&#xA;  Iterables.transform(Iterables.filter(strings, allCaps), lengthFunction));&#xA;or the FluentIterable version&#xA;Multiset&lt;Integer> lengths = HashMultiset.create(&#xA;  FluentIterable.from(strings)&#xA;    .filter(new Predicate&lt;String>() {&#xA;       public boolean apply(String string) {&#xA;         return CharMatcher.JAVA_UPPER_CASE.matchesAllOf(string);&#xA;       }&#xA;     })&#xA;    .transform(new Function&lt;String, Integer>() {&#xA;       public Integer apply(String string) {&#xA;         return string.length();&#xA;       }&#xA;     }));&#xA;with:&#xA;Multiset&lt;Integer> lengths = HashMultiset.create();&#xA;for (String string : strings) {&#xA;  if (CharMatcher.JAVA_UPPER_CASE.matchesAllOf(string)) {&#xA;    lengths.add(string.length());&#xA;  }&#xA;}&#xA;Even using static imports, even if the Function and the Predicate declarations are moved to a different file, the first implementation is less concise, less readable, and less efficient.&#xA;Imperative code should be your default, your first choice as of Java 7. You should not use functional idioms unless you are absolutely sure of one of the following:&#xA;Use of functional idioms will result in net savings of lines of code for your entire project. In the example above, the &quot;functional&quot; version used 11 lines, the imperative version 6. Moving the definition of a function to another file, or a constant, does not help. For efficiency, you need a lazily computed view of the transformed collection and cannot settle for an explicitly computed collection. Additionally, you have read and reread Effective Java, item 55, and besides following those instructions, you have actually done benchmarking to prove that this version is faster, and can cite numbers to prove it.&#xA;Please be sure, when using Guava's functional utilities, that the traditional imperative way of doing things isn't more readable. Try writing it out. Was that so bad? Was that more readable than the preposterously awkward functional approach you were about to try?&#xA;Functions and Predicates&#xA;This article discusses only those Guava features dealing directly with Function and Predicate. Some other utilities are associated with the &quot;functional style,&quot; such as concatenation and other methods which return views in constant time. Try looking in the collection utilities article.&#xA;Guava provides two basic &quot;functional&quot; interfaces:&#xA;Function&lt;A, B>, which has the single method B apply(A input). Instances of Function are generally expected to be referentially transparent -- no side effects -- and to be consistent with equals, that is, a.equals(b) implies that function.apply(a).equals(function.apply(b)). Predicate&lt;T>, which has the single method boolean apply(T input). Instances of Predicate are generally expected to be side-effect-free and consistent with equals.&#xA;&#xA;Special predicates&#xA;Characters get their own specialized version of Predicate, CharMatcher, which is typically more efficient and more useful for those needs. CharMatcher already implements Predicate&lt;Character>, and can be used correspondingly, while conversion from a Predicate to a CharMatcher can be done using CharMatcher.forPredicate. Consult the CharMatcher article for details.&#xA;Additionally, for comparable types and comparison-based predicates, most needs can be fulfilled using the Range type, which implements an immutable interval. The Range type implements Predicate, testing containment in the range. For example, Ranges.atMost(2) is a perfectly valid Predicate&lt;Integer>. More details on using ranges can be found in the corresponding article.&#xA;Manipulating Functions and Predicates&#xA;Simple Function construction and manipulation methods are provided in Functions, including&#xA;forMap(Map&lt;A, B>) compose(Function&lt;B, C>, Function&lt;A, B>) constant(T) identity() toStringFunction()&#xA;&#xA;Consult the Javadoc for details.&#xA;There are considerably more construction and manipulation methods available in Predicates, but a sample includes:&#xA;instanceOf(Class) assignableFrom(Class) contains(Pattern) in(Collection) isNull() alwaysFalse() alwaysTrue() equalTo(Object) compose(Predicate, Function) and(Predicate...) or(Predicate...) not(Predicate)&#xA;&#xA;Consult the Javadoc for details.&#xA;Using&#xA;Guava provides many tools to manipulate collections using functions and predicates. These can typically be found in the collection utility classes Iterables, Lists, Sets, Maps, Multimaps, and the like.&#xA;Predicates&#xA;The most basic use of predicates is to filter collections. All Guava filter methods return views.&#xA;Collection type Filter method Iterable Iterables.filter(Iterable, Predicate) FluentIterable.filter(Predicate) Iterator Iterators.filter(Iterator, Predicate) Collection Collections2.filter(Collection, Predicate) Set Sets.filter(Set, Predicate) SortedSet Sets.filter(SortedSet, Predicate) Map Maps.filterKeys(Map, Predicate) Maps.filterValues(Map, Predicate) Maps.filterEntries(Map, Predicate) SortedMap Maps.filterKeys(SortedMap, Predicate) Maps.filterValues(SortedMap, Predicate) Maps.filterEntries(SortedMap, Predicate) Multimap Multimaps.filterKeys(Multimap, Predicate) Multimaps.filterValues(Multimap, Predicate) Multimaps.filterEntries(Multimap, Predicate)&#xA;&#xA;* A filtered List view is omitted, because operations such as get(int) could not be supported efficiently. Instead, use Lists.newArrayList(Collections2.filter(list, predicate)) to make a copy.&#xA;Other than simple filtering, Guava provides a number of additional utilities to manipulate iterables with predicates -- typically in the Iterables utility class, and as &quot;fluent&quot; methods on a FluentIterable.&#xA;Iterables Signature Explanation See also boolean all(Iterable, Predicate) Do all the elements satisfy the predicate? Lazy: if it finds an element failing the predicate, doesn't iterate further. Iterators.all(Iterator, Predicate)&#xA;FluentIterable.allMatch(Predicate) boolean any(Iterable, Predicate) Do any of the elements satisfy the predicate? Lazy: only iterates until it finds an element satisfying the predicate. Iterators.any(Iterator, Predicate)&#xA;FluentIterable.anyMatch(Predicate) T find(Iterable, Predicate) Finds and returns an element satisfying the predicate, or throws a NoSuchElementException. Iterators.find(Iterator, Predicate)&#xA;Iterables.find(Iterable, Predicate, T default)&#xA;Iterators.find(Iterator, Predicate, T default) Optional&lt;T> tryFind(Iterable, Predicate) Returns an element satisfying the predicate, or Optional.absent(). Iterators.tryFind(Iterator, Predicate)&#xA;FluentIterable.firstMatch(Predicate)&#xA;Optional indexOf(Iterable, Predicate) Returns the index of the first element of the iterable satisfying the predicate, or -1 if no such element could be found. Iterators.indexOf(Iterator, Predicate) removeIf(Iterable, Predicate) Removes all elements satisfying the predicate, using the Iterator.remove() method. Iterators.removeIf(Iterator, Predicate)&#xA;&#xA;Functions&#xA;By far the most common use of functions is transforming collections. All Guava transform methods return views of the original collection.&#xA;Collection type Transform method Iterable Iterables.transform(Iterable, Function) FluentIterable.transform(Function) Iterator Iterators.transform(Iterator, Function) Collection Collections2.transform(Collection, Function) List Lists.transform(List, Function) Map* Maps.transformValues(Map, Function) Maps.transformEntries(Map, EntryTransformer) SortedMap* Maps.transformValues(SortedMap, Function) Maps.transformEntries(SortedMap, EntryTransformer) Multimap* Multimaps.transformValues(Multimap, Function) Multimaps.transformEntries(Multimap, EntryTransformer) ListMultimap* Multimaps.transformValues(ListMultimap, Function) Multimaps.transformEntries(ListMultimap, EntryTransformer) Table Tables.transformValues(Table, Function)&#xA;&#xA;* Map and Multimap have special methods that accept an EntryTransformer&lt;K, V1, V2>, which associates keys with a new value computed from both the original value and the key, instead of just the value.&#xA;** A transform operation for Set is omitted, since an efficient contains(Object) operation could not be supported. Instead, use Sets.newHashSet(Collections2.transform(set, function)) to create a copy of a transformed set.&#xA;List&lt;String> names;&#xA;Map&lt;String, Person> personWithName;&#xA;List&lt;Person> people = Lists.transform(names, Functions.forMap(personWithName));&#xA;ListMultimap&lt;String, String> firstNameToLastNames;&#xA;// maps first names to all last names of people with that first name&#xA;&#xA;ListMultimap&lt;String, String> firstNameToName = Multimaps.transformEntries(firstNameToLastNames,&#xA;  new EntryTransformer&lt;String, String, String> () {&#xA;    public String transformEntry(String firstName, String lastName) {&#xA;      return firstName + &quot; &quot; + lastName;&#xA;    }&#xA;  });&#xA;Types that can be &quot;composed&quot; with functions include:&#xA;Ordering Ordering.onResultOf(Function) Predicate Predicates.compose(Predicate, Function) Equivalence Equivalence.onResultOf(Function) Supplier Suppliers.compose(Function, Supplier) Function Functions.compose(Function, Function)&#xA;&#xA;Additionally, the ListenableFuture API supports transforming listenable futures. Futures also provides methods accepting an AsyncFunction, a variation on Function that allows values to be computed asynchronously.&#xA;Futures.transform(ListenableFuture, Function) Futures.transform(ListenableFuture, Function, Executor) Futures.transform(ListenableFuture, AsyncFunction) Futures.transform(ListenableFuture, AsyncFunction, Executor)&#xA; owner: lowas...@google.com&#xA; last update: Apr 10, 2013"/>
    <pages name="Release14" body="summary: Release notes for Guava Release 14.0&#xA;Guava Release 14.0: Release Notes&#xA;Release 14.0.1 was released on March 15, 2013 (it is identical to rc3). Release 14.0 was released on February 25, 2013 (it was incorrectly cut from rc2 instead of rc3). Release 14.0-rc3 was released on February 13, 2013. Release 14.0-rc2 was released on January 17, 2013. Release 14.0-rc1 was released on December 14, 2012.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release will be identified in the Maven Central repository as com.google.guava:guava:14.0.1 and com.google.guava:guava-gwt:14.0.1&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-14.0.1.jar guava-gwt-14.0.1.jar (for GWT users) guava-14.0.1-javadoc.jar (Javadoc) guava-14.0.1-sources.jar (Source)&#xA;Issues resolved&#xA;32 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 13.0.1&#xA;To build a combined report of the API changes between release 14.0.1 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions&#xA;common.collect&#xA;ForwardingBlockingDeque&#xA;RangeMap, ImmutableRangeMap, TreeRangeMap&#xA;RangeSet, ImmutableRangeSet, TreeRangeSet&#xA;common.io&#xA;BaseEncoding&#xA;ByteSink &amp; ByteSource&#xA;CharSink &amp; CharSource&#xA;FileWriteMode&#xA;common.reflect&#xA;ClassPath &amp; ClassInfo&#xA;Invokable&#xA;Parameter&#xA;common.util.concurrent&#xA;AbstractListeningExecutorService&#xA;FutureFallback&#xA;ServiceManager &amp; !Listener&#xA;Significant API changes&#xA;The static methods in Equivalences have been moved into Equivalence.&#xA;The static methods in DiscreteDomains have been moved into DiscreteDomain.&#xA;Stopwatch#elapsedMillis and #elapsedTime have been deprecated in favor of #elapsed&#xA;Sets.cartesianProduct now guarantees iteration in lexicographical order, instead of leaving order unspecified.&#xA;Promoted from @Beta&#xA;common.base&#xA;Ticker&#xA;ToStringHelper#omitNullValues&#xA;Optional#or #transform&#xA;common.collect&#xA;BoundType&#xA;Range&#xA;FluentIterable&#xA;ForwardingDeque, ForwardingNavigableMap, ForwardingNavigableSet&#xA;SortedMapDifference&#xA;Ordering.{lea,greate}stOf(Itera{ble,tor})&#xA;Ordering.max/min(Iterator)&#xA;Immutable{Set,List,}Multimap.inverse()&#xA;ImmutableMultimap.Builder.order{Value,Key}sBy&#xA;Sets.synchronizedNavigableSet&#xA;Maps.filter{Values,Keys,Entries}&#xA;Maps.synchronizedNavigableMap&#xA;Maps.transform{Values,Keys,Entries}&#xA;common.math&#xA;IntMath &amp; LongMath&#xA;common.net&#xA;HttpHeaders&#xA;common.primitives&#xA;Unsigned{Long,Int}s&#xA;common.util.concurrent&#xA;FutureCallback&#xA;Futures (many methods)&#xA;AsyncFunction&#xA;Atomics&#xA;AtomicDouble&#xA;AtomicDoubleArray &amp; AtomicLongMap&#xA;ExecutionError &amp; UncheckedExecutionException&#xA;Non-API changes&#xA;RateLimiter getRate/setRate are no longer synchronized on the current instance&#xA;Sets.cartesianProduct&#xA;Optimizations&#xA;LongMath.binomial is significantly faster.&#xA;LongMath.sqrt is significantly faster.&#xA;ImmutableBiMap takes ~35% less memory.&#xA;HashBiMap takes ~40% less memory.&#xA;Ordering.{lea,greate}stOf(elements, k) still run in /O(n)/ time, but they perform only one pass and use only /O(k)/ extra memory. (Accordingly, they now have Iterator overloads.)&#xA;ImmutableSet now uses an improved murmur-based rehashing function to improve dispersion.&#xA; owner: cgdecker@google.com&#xA; last update: Sep 6, 2013"/>
    <pages name="FriendsOfGuava" body="summary: Some open-source projects we like&#xA;Friends of Guava&#xA;Error-Prone - break your build! Glazed Lists - observable collections GSON - read and write JSON Google Web Toolkit - we support it ICU4J - unless all your users live in the same place Joda-Time - do not use JDK date/time libraries! JUNG - graphs done right MOE - this is how we keep our internal and external codebases in sync Mockito - Googlers' favorite mocking framework ProGuard - shrinker/bundler/obfuscator/optimizer&#xA;Other projects we work on&#xA;Auto - generated value type classes, factories and more Caliper - we use it to benchmark our code Dagger - a high-performance dependency injector using code generation Guice - a mature dependency injector that uses reflection Jimfs - an on-heap java.nio.file file system (primarily for testing)&#xA; owner: kevinb@google.com&#xA; last update: Feb 19, 2014"/>
    <pages name="Release11" body="summary: Release notes for Guava Release 11.0.2&#xA;Guava Release 11.0.2: Release Notes&#xA;Release 11.0 was released on December 18, 2011. Release 11.0.1 was released on January 9, 2012. Release 11.0.2 was released on February 22, 2012. (See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release will be identified in the Maven Central repository as com.google.guava:guava:11.0.2 and com.google.guava:guava-gwt:11.0.2&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-11.0.2.jar guava-gwt-11.0.2.jar (for GWT users) guava-11.0.2-javadoc.jar (Javadoc) guava-11.0.2-sources.jar (Source)&#xA;API Changes&#xA;Full JDiff Report of changes since release 10.0.1&#xA;To build a combined report of the API changes between release 11.0.2 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Changes between 11.0.1 and 11.0.2&#xA;Fix BloomFilter performance bug, breaking backwards compatibility in the process. Fix GWT compilation of CacheBuilder.&#xA;Changes between 11.0 and 11.0.1&#xA;Fix bug in Optional#presentInstances. Make MessageDigestHashFunction thread-safe. Fix Cache clear in the absence of a removal listener. Cache documentation improvements.&#xA;LoadingCache split out of Cache&#xA;The Cache methods related to automatic cache loading have been split out into the LoadingCache interface. CacheBuilder.build(CacheLoader) now returns a LoadingCache, and CacheBuilder.build() was introduced, which returns a Cache.&#xA;When upgrading to version 11.0.2, all Cache references should be changed to LoadingCache.&#xA;Issues resolved&#xA;Issues fixed&#xA;Additions&#xA;New packages&#xA;common.hash common.math&#xA;New classes&#xA;common.cache&#xA;LoadingCache AbstractLoadingCache ForwardingLoadingCache Weigher&#xA;common.collect&#xA;ImmutableTable Queues SortedMultiset&#xA;common.net&#xA;HttpHeaders&#xA;common.primitives&#xA;UnsignedInteger UnsignedInts UnsignedLong&#xA;common.util.concurrent&#xA;AbstractScheduledService AsyncFunction AtomicDouble AtomicDoubleArray AtomicLongMap&#xA;New members&#xA;common.base&#xA;Objects.ToStringHelper.add/addValue primitive overloads Optional.asSet, presentInstances Strings.commonPrefix, commonSuffix&#xA;common.cache&#xA;Cache.get, getIfPresent, getAllPresent, invalidateAll, put CacheBuilder.build, maximumWeight, refreshAfterWrite, weigher CacheLoader.loadAll, reload CacheStats.plus&#xA;common.collect&#xA;ImmutableMultimap.inverse Iterables.mergeSorted, tryFind Iterators.mergeSorted, tryFind Maps.difference, filterEntries, filterKeys, filterValues, transformEntries, transformValues Multimaps.filterEntries, filterKeys, filterValues Multisets.copyHighestCountFirst, unmodifiableSortedMultiset Ordering.max, min (Iterator overload) Sets.filter (SortedSet overload), newLinkedHashSetWithExpectedSize Tables.unmodifiableRowSortedTable, unmodifiableTable&#xA;common.io&#xA;Files.getFileExtension, simplifyPath&#xA;common.primitives&#xA;Ints.tryParse&#xA;common.util.concurrent&#xA;Futures.transform(..., AsyncFunction) (to replace Futures.chain)&#xA; owner: cpov...@google.com&#xA; last update: Apr 30, 2012"/>
    <pages name="Release10" body="summary: Release notes for Guava Release 10.0.1&#xA;Guava Release 10.0.1: Release Notes&#xA;Release 10.0 was released on September 28, 2011. Release 10.0.1 was released on October 10, 2011. (See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;This release will be identified in the Maven Central repository as com.google.guava:guava:10.0.1 and com.google.guava:guava-gwt:10.0.1&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;If you don't use managed dependencies, you can also just manually download JARs of the classes, sources and documentation from:&#xA;guava-10.0.1.jar guava-gwt-10.0.1.jar (for GWT users) guava-10.0.1-javadoc.jar (Javadoc) guava-10.0.1-sources.jar (Source)&#xA;API Changes&#xA;Full JDiff Report of changes since release 9.0&#xA;To build a combined report of the API changes between release 10.0.1 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Changes between 10.0 and 10.0.1&#xA;Fixed serialization of MapMaker eviction listeners ( issue 712 ) Allow write operations on Cache.asMap view of CacheBuilder-generated Caches Don't deprecate FinalizableReferenceQueue and associated classes&#xA;Issues resolved&#xA;Issues fixed&#xA;Additions&#xA;Runnable tests!&#xA;New packages&#xA;common.cache common.eventbus&#xA;New classes&#xA;Ranges&#xA;Range Ranges ContiguousSet DiscreteDomain DiscreteDomains BoundType&#xA;Forwarding Helpers&#xA;ForwardingExecutorService ForwardingListeningExecutorService ForwardingMap.StandardEntrySet ForwardingMap.StandardKeySet ForwardingMap.StandardValues ForwardingMultiset.StandardElementSet&#xA;Other Collections&#xA;ArrayTable ImmutableCollection.Builder&#xA;Futures&#xA;ListeningExecutorService ListeningScheduledExecutorService FutureCallback UncheckedExecutionException ExecutionError&#xA;Other Concurrency&#xA;Atomics Monitor Uninterruptibles&#xA;Miscellaneous&#xA;Stopwatch UnsignedLongs Optional HostAndPort Splitter.MapSplitter Equivalence.Wrapper&#xA;New members&#xA;Futures.addCallback Futures.allAsList Futures.get Futures.getUnchecked Futures.successfulAsList&#xA;Predicates.assignableFrom&#xA;Multisets.containsOccurrences Multisets.removeOccurrences Multisets.retainOccurrences&#xA;ByteStreams.copy(InputStream, OutputSupplier)&#xA;Maps.difference using an Equivalence Maps.uniqueIndex for an Iterator Multimaps.index for an Iterator MapJoiner.join for an Iterable&lt;Entry>&#xA;Functions.forSupplier&#xA;AbstractExecutionThreadService.getServiceName&#xA;InetAddresses.increment InetAddresses.isMappedIPv4Address InetAddresses.isMaximum InetAddresses.toAddrString&#xA;AbstractFuture.interruptTask&#xA;Doubles.isFinite Floats.isFinite&#xA;MoreExecutors.listeningDecorator&#xA;Tables.newCustomTable Tables.transformValues&#xA;Ticker.systemTicker&#xA;Splitter.withKeyValueSeparator&#xA;BYTES (Doubles, Floats) MAX_POWER_OF_TWO (Int, Longs, Shorts, SignedBytes, UnsignedBytes)&#xA; owner: fry@google.com&#xA; last update: Mar 20, 2012"/>
    <pages name="NewCollectionTypesExplained" body="summary: Guava's new collection types, explained.&#xA;TODO: More examples&#xA;Guava introduces a number of new collection types that are not in the JDK, but that we have found to be broadly useful. These are all designed to coexist happily with the JDK collections framework, without shoehorning things into the JDK collection abstractions.&#xA;As a general rule, the Guava collection implementations follow JDK interface contracts very precisely.&#xA;Multiset&#xA;The traditional Java idiom for e.g. counting how many times a word occurs in a document is something like:&#xA;Map&lt;String, Integer> counts = new HashMap&lt;String, Integer>();&#xA;for (String word : words) {&#xA;  Integer count = counts.get(word);&#xA;  if (count == null) {&#xA;    counts.put(word, 1);&#xA;  } else {&#xA;    counts.put(word, count + 1);&#xA;  }&#xA;}&#xA;This is awkward, prone to mistakes, and doesn't support collecting a variety of useful statistics, like the total number of words. We can do better.&#xA;Guava provides a new collection type, Multiset, which supports adding multiples of elements. Wikipedia defines a multiset, in mathematics, as &#x201c;a generalization of the notion of set in which members are allowed to appear more than once...In multisets, as in sets and in contrast to tuples, the order of elements is irrelevant: The multisets {a, a, b} and {a, b, a} are equal.&#x201d;&#xA;There are two main ways of looking at this:&#xA;This is like an ArrayList&lt;E> without an ordering constraint: ordering does not matter. This is like a Map&lt;E, Integer>, with elements and counts.&#xA;Guava&#x2019;s Multiset API combines both ways of thinking about a Multiset, as follows:&#xA;When treated as a normal Collection, Multiset behaves much like an unordered ArrayList: Calling add(E) adds a single occurrence of the given element. The iterator() of a Multiset iterates over every occurrence of every element. The size() of a Multiset is the total number of all occurrences of all elements.&#xA;The additional query operations, as well as the performance characteristics, are like what you&#x2019;d expect from a Map&lt;E, Integer>. count(Object) returns the count associated with that element. For a HashMultiset, count is O(1), for a TreeMultiset, count is O(log n), etc. entrySet() returns a Set&lt;Multiset.Entry&lt;E>> which works analogously to the entrySet of a Map. elementSet() returns a Set&lt;E> of the distinct elements of the multiset, like keySet() would for a Map. The memory consumption of Multiset implementations is linear in the number of distinct elements.&#xA;&#xA;&#xA;Notably, Multiset is fully consistent with the contract of the Collection interface, save in rare cases with precedent in the JDK itself -- specifically, TreeMultiset, like TreeSet, uses comparison for equality instead of Object.equals. In particular, Multiset.addAll(Collection) adds one occurrence of each element in the Collection for each time it appears, which is much more convenient than the for loop required by the Map approach above.&#xA;Method Description count(E) Count the number of occurrences of an element that have been added to this multiset. elementSet() View the distinct elements of a Multiset&lt;E> as a Set&lt;E>. entrySet() Similar to Map.entrySet(), returns a Set&lt;Multiset.Entry&lt;E>>, containing entries supporting getElement() and getCount(). add(E, int) Adds the specified number of occurrences of the specified element. remove(E, int) Removes the specified number of occurrences of the specified element. setCount(E, int) Sets the occurrence count of the specified element to the specified nonnegative value. size() Returns the total number of occurrences of all elements in the Multiset.&#xA;&#xA;Multiset Is Not A Map&#xA;Note that Multiset&lt;E> is not a Map&lt;E, Integer>, though that might be part of a Multiset implementation. Multiset is a true Collection type, and satisfies all of the associated contractual obligations. Other notable differences include:&#xA;A Multiset&lt;E> has elements with positive counts only. No element can have negative counts, and values with count 0 are considered to not be in the multiset. They do not appear in the elementSet() or entrySet() view. multiset.size() returns the size of the collection, which is equal to the sum of the counts of all elements. For the number of distinct elements, use elementSet().size(). (So, for example, add(E) increases multiset.size() by one.) multiset.iterator() iterates over each occurrence of each element, so the length of the iteration is equal to multiset.size(). Multiset&lt;E> supports adding elements, removing elements, or setting the count of elements directly. setCount(elem, 0) is equivalent to removing all occurrences of the element. multiset.count(elem) for an element not in the multiset always returns 0.&#xA;Implementations&#xA;Guava provides many implementations of Multiset, which roughly correspond to JDK map implementations.&#xA;Map Corresponding Multiset Supports null elements HashMap HashMultiset Yes TreeMap TreeMultiset Yes (if the comparator does) LinkedHashMap LinkedHashMultiset Yes ConcurrentHashMap ConcurrentHashMultiset No ImmutableMap ImmutableMultiset No&#xA;&#xA;SortedMultiset&#xA;SortedMultiset is a new variation on the Multiset interface that supports efficiently taking sub-multisets on specified ranges. For example, you could use latencies.subMultiset(0, BoundType.CLOSED, 100, BoundType.OPEN).size() to determine how many hits to your site had under 100ms latency, and then compare that to latencies.size() to determine the overall proportion.&#xA;TreeMultiset implements the SortedMultiset interface. At the time of writing, ImmutableSortedMultiset is still being tested for GWT compatibility.&#xA;Multimap&#xA;Every experienced Java programmer has, at one point or another, implemented a Map&lt;K, List&lt;V>> or Map&lt;K, Set&lt;V>>, and dealt with the awkwardness of that structure. For example, Map&lt;K, Set&lt;V>> is a typical way to represent an unlabeled directed graph. Guava's Multimap framework makes it easy to handle a mapping from keys to multiple values. A Multimap is a general way to associate keys with arbitrarily many values.&#xA;There are two ways to think of a Multimap conceptually: as a collection of mappings from single keys to single values:&#xA;a -> 1 a -> 2 a -> 4 b -> 3 c -> 5&#xA;or as a mapping from unique keys to collections of values:&#xA;a -> [1, 2, 4] b -> 3 c -> 5&#xA;In general, the Multimap interface is best thought of in terms of the first view, but allows you to view it in either way with the asMap() view, which returns a Map&lt;K, Collection&lt;V>>. Most importantly, there is no such thing as a key which maps to an empty collection: a key either maps to at least one value, or it is simply not present in the Multimap.&#xA;You rarely use the Multimap interface directly, however; more often you'll use ListMultimap or SetMultimap, which map keys to a List or a Set respectively.&#xA;Modifying&#xA;Multimap.get(key) returns a view of the values associated with the specified key, even if there are none currently. For a ListMultimap, it returns a List, for a SetMultimap, it returns a Set.&#xA;Modifications write through to the underlying Multimap. For example,&#xA;Set&lt;Person> aliceChildren = childrenMultimap.get(alice);&#xA;aliceChildren.clear();&#xA;aliceChildren.add(bob);&#xA;aliceChildren.add(carol);&#xA;writes through to the underlying multimap.&#xA;Other ways of modifying the multimap (more directly) include:&#xA;Signature Description Equivalent put(K, V) Adds an association from the key to the value multimap.get(key).add(value) putAll(K, Iterable&lt;V>) Adds associations from the key to each of the values in turn Iterables.addAll(multimap.get(key), values) remove(K, V) Removes one association from key to value and returns true if the multimap changed. multimap.get(key).remove(value) removeAll(K) Removes and returns all the values associated with the specified key. The returned collection may or may not be modifiable, but modifying it will not affect the multimap. (Returns the appropriate collection type.) multimap.get(key).clear() replaceValues(K, Iterable&lt;V>) Clears all the values associated with key and sets key to be associated with each of values. Returns the values that were previously associated with the key. multimap.get(key).clear(); Iterables.addAll(multimap.get(key), values)&#xA;&#xA;Views&#xA;Multimap also supports a number of powerful views.&#xA;asMap views any Multimap&lt;K, V> as a Map&lt;K, Collection&lt;V>>. The returned map supports remove, and changes to the returned collections write through, but the map does not support put or putAll. Critically, you can use asMap().get(key) when you want null on absent keys rather than a fresh, writable empty collection. (You can and should cast asMap.get(key) to the appropriate collection type -- a Set for a SetMultimap, a List for a ListMultimap -- but the type system does not allow ListMultimap to return Map&lt;K, List&lt;V>> here.) entries views the Collection&lt;Map.Entry&lt;K, V>> of all entries in the Multimap. (For a SetMultimap, this is a Set.) keySet views the distinct keys in the Multimap as a Set. keys views the keys of the Multimap as a Multiset, with multiplicity equal to the number of values associated to that key. Elements can be removed from the Multiset, but not added; changes will write through. values() views the all the values in the Multimap as a &quot;flattened&quot; Collection&lt;V>, all as one collection. This is similar to Iterables.concat(multimap.asMap().values()), but returns a full Collection instead.&#xA;&#xA;Multimap Is Not A Map&#xA;A Multimap&lt;K, V> is not a Map&lt;K, Collection&lt;V>>, though such a map might be used in a Multimap implementation. Notable differences include:&#xA;Multimap.get(key) always returns a non-null, possibly empty collection. This doesn't imply that the multimap spends any memory associated with the key, but instead, the returned collection is a view that allows you to add associations with the key if you like. If you prefer the more Map-like behavior of returning null for keys that aren't in the multimap, use the asMap() view to get a Map&lt;K, Collection&lt;V>>. (Or, to get a Map&lt;K, List&lt;V>> from a ListMultimap, use the static Multimaps.asMap() method. Similar methods exist for SetMultimap and SortedSetMultimap.) Multimap.containsKey(key) is true if and only if there are any elements associated with the specified key. In particular, if a key k was previously associated with one or more values which have since been removed from the multimap, Multimap.containsKey(k) will return false. Multimap.entries() returns all entries for all keys in the Multimap. If you want all key-collection entries, use asMap().entrySet(). Multimap.size() returns the number of entries in the entire multimap, not the number of distinct keys. Use Multimap.keySet().size() instead to get the number of distinct keys.&#xA;Implementations&#xA;Multimap provides a wide variety of implementations. You can use it in most places you would have used a Map&lt;K, Collection&lt;V>>.&#xA;Implementation Keys behave like... Values behave like.. ArrayListMultimap HashMap ArrayList HashMultimap HashMap HashSet LinkedListMultimap* LinkedHashMap* LinkedList* LinkedHashMultimap** LinkedHashMap LinkedHashSet TreeMultimap TreeMap TreeSet ImmutableListMultimap ImmutableMap ImmutableList ImmutableSetMultimap ImmutableMap ImmutableSet&#xA;&#xA;Each of these implementations, except the immutable ones, support null keys and values.&#xA;* LinkedListMultimap.entries() preserves iteration order across non-distinct key values. See the link for details.&#xA;** LinkedHashMultimap preserves insertion order of entries, as well as the insertion order of keys, and the set of values associated with any one key.&#xA;Be aware that not all implementations are actually implemented as a Map&lt;K, Collection&lt;V>> with the listed implementations! (In particular, several Multimap implementations use custom hash tables to minimize overhead.)&#xA;If you need more customization, use Multimaps.newMultimap(Map, Supplier&lt;Collection>) or the list and set versions to use a custom collection, list, or set implementation to back your multimap.&#xA;BiMap&#xA;The traditional way to map values back to keys is to maintain two separate maps and keep them both in sync, but this is bug-prone and can get extremely confusing when a value is already present in the map. For example:&#xA;Map&lt;String, Integer> nameToId = Maps.newHashMap();&#xA;Map&lt;Integer, String> idToName = Maps.newHashMap();&#xA;&#xA;nameToId.put(&quot;Bob&quot;, 42);&#xA;idToName.put(42, &quot;Bob&quot;);&#xA;// what happens if &quot;Bob&quot; or 42 are already present?&#xA;// weird bugs can arise if we forget to keep these in sync...&#xA;A BiMap&lt;K, V> is a Map&lt;K, V> that&#xA;allows you to view the &quot;inverse&quot; BiMap&lt;V, K> with inverse() ensures that values are unique, making values() a Set&#xA;BiMap.put(key, value) will throw an IllegalArgumentException if you attempt to map a key to an already-present value. If you wish to delete any preexisting entry with the specified value, use BiMap.forcePut(key, value) instead.&#xA;BiMap&lt;String, Integer> userId = HashBiMap.create();&#xA;...&#xA;&#xA;String userForId = userId.inverse().get(id);&#xA;Implementations&#xA;Key-Value Map Impl Value-Key Map Impl Corresponding BiMap HashMap HashMap HashBiMap ImmutableMap ImmutableMap ImmutableBiMap EnumMap EnumMap EnumBiMap EnumMap HashMap EnumHashBiMap&#xA;&#xA;Note: BiMap utilities like synchronizedBiMap live in `Maps`.&#xA;Table&#xA;Table&lt;Vertex, Vertex, Double> weightedGraph = HashBasedTable.create();&#xA;weightedGraph.put(v1, v2, 4);&#xA;weightedGraph.put(v1, v3, 20);&#xA;weightedGraph.put(v2, v3, 5);&#xA;&#xA;weightedGraph.row(v1); // returns a Map mapping v2 to 4, v3 to 20&#xA;weightedGraph.column(v3); // returns a Map mapping v1 to 20, v2 to 5&#xA;Typically, when you are trying to index on more than one key at a time, you will wind up with something like Map&lt;FirstName, Map&lt;LastName, Person>>, which is ugly and awkward to use. Guava provides a new collection type, Table, which supports this use case for any &quot;row&quot; type and &quot;column&quot; type. Table supports a number of views to let you use the data from any angle, including&#xA;rowMap(), which views a Table&lt;R, C, V> as a Map&lt;R, Map&lt;C, V>>. Similarly, rowKeySet() returns a Set&lt;R>. row(r) returns a non-null Map&lt;C, V>. Writes to the Map will write through to the underlying Table. Analogous column methods are provided: columnMap(), columnKeySet(), and column(c). (Column-based access is somewhat less efficient than row-based access.) cellSet() returns a view of the Table as a set of Table.Cell&lt;R, C, V>. Cell is much like Map.Entry, but distinguishes the row and column keys.&#xA;&#xA;Several Table implementations are provided, including:&#xA;HashBasedTable, which is essentially backed by a HashMap&lt;R, HashMap&lt;C, V>>. TreeBasedTable, which is essentially backed by a TreeMap&lt;R, TreeMap&lt;C, V>>. ImmutableTable, which is essentially backed by an ImmutableMap&lt;R, ImmutableMap&lt;C, V>>. (Note: ImmutableTable has optimized implementations for sparser and denser data sets.) ArrayTable, which requires that the complete universe of rows and columns be specified at construction time, but is backed by a two-dimensional array to improve speed and memory efficiency when the table is dense. ArrayTable works somewhat differently from other implementations; consult the Javadoc for details.&#xA;&#xA;ClassToInstanceMap&#xA;Sometimes, your map keys aren't all of the same type: they are types, and you want to map them to values of that type. Guava provides ClassToInstanceMap for this purpose.&#xA;In addition to extending the Map interface, ClassToInstanceMap provides the methods T getInstance(Class&lt;T>) and T putInstance(Class&lt;T>, T), which eliminate the need for unpleasant casting while enforcing type safety.&#xA;ClassToInstanceMap has a single type parameter, typically named B, representing the upper bound on the types managed by the map. For example:&#xA;ClassToInstanceMap&lt;Number> numberDefaults = MutableClassToInstanceMap.create();&#xA;numberDefaults.putInstance(Integer.class, Integer.valueOf(0));&#xA;Technically, ClassToInstanceMap&lt;B> implements Map&lt;Class&lt;? extends B>, B> -- or in other words, a map from subclasses of B to instances of B. This can make the generic types involved in ClassToInstanceMap mildly confusing, but just remember that B is always the upper bound on the types in the map -- usually, B is just Object.&#xA;Guava provides implementations helpfully named MutableClassToInstanceMap and ImmutableClassToInstanceMap.&#xA;Important: Like any other Map&lt;Class, Object>, a ClassToInstanceMap may contain entries for primitive types, and a primitive type and its corresponding wrapper type may map to different values.&#xA;RangeSet&#xA;A RangeSet describes a set of disconnected, nonempty ranges. When adding a range to a mutable RangeSet, any connected ranges are merged together, and empty ranges are ignored. For example:&#xA;   RangeSet&lt;Integer> rangeSet = TreeRangeSet.create();&#xA;   rangeSet.add(Range.closed(1, 10)); // {[1, 10]}&#xA;   rangeSet.add(Range.closedOpen(11, 15)); // disconnected range: {[1, 10], [11, 15)} &#xA;   rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)}&#xA;   rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}&#xA;   rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}&#xA;Note that to merge ranges like Range.closed(1, 10) and Range.closedOpen(11, 15), you must first preprocess ranges with Range.canonical(DiscreteDomain), e.g. with DiscreteDomain.integers().&#xA;NOTE: RangeSet is not supported under GWT, nor in the JDK 1.5 backport; RangeSet requires full use of the NavigableMap features in JDK 1.6.&#xA;Views&#xA;RangeSet implementations support an extremely wide range of views, including:&#xA;complement(): views the complement of the RangeSet. complement is also a RangeSet, as it contains disconnected, nonempty ranges. subRangeSet(Range&lt;C>): returns a view of the intersection of the RangeSet with the specified Range. This generalizes the headSet, subSet, and tailSet views of traditional sorted collections. asRanges(): views the RangeSet as a Set&lt;Range&lt;C>> which can be iterated over. asSet(DiscreteDomain&lt;C>) (ImmutableRangeSet only): Views the RangeSet&lt;C> as an ImmutableSortedSet&lt;C>, viewing the elements in the ranges instead of the ranges themselves. (This operation is unsupported if the DiscreteDomain and the RangeSet are both unbounded above or both unbounded below.)&#xA;Queries&#xA;In addition to operations on its views, RangeSet supports several query operations directly, the most prominent of which are:&#xA;contains(C): the most fundamental operation on a RangeSet, querying if any range in the RangeSet contains the specified element. rangeContaining(C): returns the Range which encloses the specified element, or null if there is none. encloses(Range&lt;C>): straightforwardly enough, tests if any Range in the RangeSet encloses the specified range. span(): returns the minimal Range that encloses every range in this RangeSet.&#xA;RangeMap&#xA;RangeMap is a collection type describing a mapping from disjoint, nonempty ranges to values. Unlike RangeSet, RangeMap never &quot;coalesces&quot; adjacent mappings, even if adjacent ranges are mapped to the same values. For example:&#xA;RangeMap&lt;Integer, String> rangeMap = TreeRangeMap.create();&#xA;rangeMap.put(Range.closed(1, 10), &quot;foo&quot;); // {[1, 10] => &quot;foo&quot;}&#xA;rangeMap.put(Range.open(3, 6), &quot;bar&quot;); // {[1, 3] => &quot;foo&quot;, (3, 6) => &quot;bar&quot;, [6, 10] => &quot;foo&quot;}&#xA;rangeMap.put(Range.open(10, 20), &quot;foo&quot;); // {[1, 3] => &quot;foo&quot;, (3, 6) => &quot;bar&quot;, [6, 10] => &quot;foo&quot;, (10, 20) => &quot;foo&quot;}&#xA;rangeMap.remove(Range.closed(5, 11)); // {[1, 3] => &quot;foo&quot;, (3, 5) => &quot;bar&quot;, (11, 20) => &quot;foo&quot;}&#xA;Views&#xA;RangeMap provides two views:&#xA;asMapOfRanges(): views the RangeMap as a Map&lt;Range&lt;K>, V>. This can be used, for example, to iterate over the RangeMap. subRangeMap(Range&lt;K>) views the intersection of the RangeMap with the specified Range as a RangeMap. This generalizes the traditional headMap, subMap, and tailMap operations.&#xA; owner: cpov...@google.com&#xA; last update: Aug 16, 2013"/>
    <pages name="ConditionalFailuresExplained" body="summary: org.eclipse.m2m.atl.engine.emfvm.lib.OclUndefined@4334aebf&#xA;A conditional failure, or runtime check, is any code that throws an exception if and only if a boolean condition holds. Of course, such code is prevalent in well-designed software. This page provides an overview of the common kinds of such checks.&#xA;Kinds of conditional failures&#xA;One could easily handle every conditional failure the same way: if (!condition) throw new RuntimeException();. But if you spend a moment to consider the nature of the check you're performing and handle it in the most appropriate way, you'll make your code more understandable, and errors easier to diagnose.&#xA;Here are the major kinds of runtime checks.&#xA;A precondition check ensures that the caller of a public method has obeyed the requirements of the method's specification. For example, a sqrt function may accept only nonnegative arguments.&#xA;A conventional assertion is a check that should only fail if the class itself (that contains the check) is broken in some way. (In some cases this can extend to the package.) These can take various forms including postconditions, class invariants, and internal preconditions (on non-public methods).&#xA;A verification check is used when you lack high confidence that an API you consume will meet its (real or implied) specification. It's easiest to understand this type of check as &quot;like an assertion in almost every way, but must remain enabled in production.&quot;&#xA;A test assertion is found in test code only, and ensures that the code under test has obeyed the requirements of its own specification. Note that this kind of &quot;assertion&quot; has almost nothing in common with true assertions in production code.&#xA;An impossible-condition check is one that cannot possibly fail, unless surrounding code is later modified, or our deepest assumptions about platform behavior are grossly violated. These should be unnecessary, but are often forced because the compiler can't recognize that a statement is unreachable.&#xA;Finally, an exceptional result means that the method can't provide the expected result, through no fault of its own, nor necessarily the fault of any other code involved. This may be similar to a precondition check, except that in this case the caller isn't expected to have known better. It's similar to a verification check, but failure of the dependency is not unexpected. For example, trying to read a line from a file when end-of-file has already been reached is no one's fault; simply an exceptional result. Use a checked or unchecked exception according to the advice in Effective Java, Second Edition, page 244.&#xA;Summary&#xA;Kind of check The throwing method is saying... Precondition &quot;You messed up (caller).&quot; Assertion &quot;I messed up.&quot; Verification &quot;Someone I depend on messed up.&quot; Test assertion &quot;The code I'm testing messed up.&quot; Impossible condition &quot;What the? the world is messed up!&quot; Exceptional result &quot;No one messed up, exactly (at least in this VM).&quot;&#xA;&#xA;How to handle them&#xA;TODO&#xA; owner: kevinb@google.com&#xA; last update: Dec 11, 2013"/>
    <pages name="ListenableFutureExplained" body="summary: Guava's listenable future API, explained.&#xA;Concurrency is a hard problem, but it is significantly simplified by working with powerful and simple abstractions. To simplify matters, Guava extends the Future interface of the JDK with ListenableFuture.&#xA;We strongly advise that you always use ListenableFuture instead of Future in all of your code, because:&#xA;Most Futures methods require it. It's easier than changing to ListenableFuture later. Providers of utility methods won't need to provide Future and ListenableFuture variants of their methods.&#xA;&#xA;Interface&#xA;A traditional Future represents the result of an asynchronous computation: a computation that may or may not have finished producing a result yet. A Future can be a handle to an in-progress computation, a promise from a service to supply us with a result.&#xA;A ListenableFuture allows you to register callbacks to be executed once the computation is complete, or if the computation is already complete, immediately. This simple addition makes it possible to efficiently support many operations that the basic Future interface cannot support.&#xA;The basic operation added by ListenableFuture is addListener(Runnable, Executor), which specifies that when the computation represented by this Future is done, the specified Runnable will be run on the specified Executor.&#xA;Adding Callbacks&#xA;Most users will prefer to use Futures.addCallback(ListenableFuture&lt;V>, FutureCallback&lt;V>, Executor), or the version which defaults to using MoreExecutors.sameThreadExecutor(), for use when the callback is fast and lightweight. A FutureCallback&lt;V> implements two methods:&#xA;onSuccess(V), the action to perform if the future succeeds, based on its result onFailure(Throwable), the action to perform if the future fails, based on the failure&#xA;&#xA;Creation&#xA;Corresponding to the JDK ExecutorService.submit(Callable) approach to initiating an asynchronous computation, Guava provides the ListeningExecutorService interface, which returns a ListenableFuture wherever ExecutorService would return a normal Future. To convert an ExecutorService to a ListeningExecutorService, just use MoreExecutors.listeningDecorator(ExecutorService).&#xA;ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));&#xA;ListenableFuture&lt;Explosion> explosion = service.submit(new Callable&lt;Explosion>() {&#xA;  public Explosion call() {&#xA;    return pushBigRedButton();&#xA;  }&#xA;});&#xA;Futures.addCallback(explosion, new FutureCallback&lt;Explosion>() {&#xA;  // we want this handler to run immediately after we push the big red button!&#xA;  public void onSuccess(Explosion explosion) {&#xA;    walkAwayFrom(explosion);&#xA;  }&#xA;  public void onFailure(Throwable thrown) {&#xA;    battleArchNemesis(); // escaped the explosion!&#xA;  }&#xA;});&#xA;Alternatively, if you're converting from an API based on FutureTask, Guava offers ListenableFutureTask.create(Callable&lt;V>) and ListenableFutureTask.create(Runnable, V). Unlike the JDK, ListenableFutureTask is not meant to be extended directly.&#xA;If you prefer an abstraction in which you set the value of the future rather than implementing a method to compute the value, consider extending AbstractFuture&lt;V> or using SettableFuture directly.&#xA;If you must convert a Future provided by another API to an ListenableFuture, you may have no choice but to use the heavyweight JdkFutureAdapters.listenInPoolThread(Future) to convert a Future to a ListenableFuture. Whenever possible, it is preferred to modify the original code to return a ListenableFuture.&#xA;Application&#xA;The most important reason to use ListenableFuture is that it becomes possible to have complex chains of asynchronous operations.&#xA;ListenableFuture&lt;RowKey> rowKeyFuture = indexService.lookUp(query);&#xA;AsyncFunction&lt;RowKey, QueryResult> queryFunction =&#xA;  new AsyncFunction&lt;RowKey, QueryResult>() {&#xA;    public ListenableFuture&lt;QueryResult> apply(RowKey rowKey) {&#xA;      return dataService.read(rowKey);&#xA;    }&#xA;  };&#xA;ListenableFuture&lt;QueryResult> queryFuture = Futures.transform(rowKeyFuture, queryFunction, queryExecutor);&#xA;Many other operations can be supported efficiently with a ListenableFuture that cannot be supported with a Future alone. Different operations may be executed by different executors, and a single ListenableFuture can have multiple actions waiting upon it.&#xA;When several operations should begin as soon as another operation starts -- &quot;fan-out&quot; -- ListenableFuture just works: it triggers all of the requested callbacks. With slightly more work, we can &quot;fan-in,&quot; or trigger a ListenableFuture to get computed as soon as several other futures have all finished: see the implementation of Futures.allAsList for an example.&#xA;Method Description See also transform(ListenableFuture&lt;A>, AsyncFunction&lt;A, B>, Executor)* Returns a new ListenableFuture whose result is the product of applying the given AsyncFunction to the result of the given ListenableFuture. transform(ListenableFuture&lt;A>, AsyncFunction&lt;A, B>) transform(ListenableFuture&lt;A>, Function&lt;A, B>, Executor) Returns a new ListenableFuture whose result is the product of applying the given Function to the result of the given ListenableFuture. transform(ListenableFuture&lt;A>, Function&lt;A, B>) allAsList(Iterable&lt;ListenableFuture&lt;V>>) Returns a ListenableFuture whose value is a list containing the values of each of the input futures, in order. If any of the input futures fails or is cancelled, this future fails or is cancelled. allAsList(ListenableFuture&lt;V>...) successfulAsList(Iterable&lt;ListenableFuture&lt;V>>) Returns a ListenableFuture whose value is a list containing the values of each of the successful input futures, in order. The values corresponding to failed or cancelled futures are replaced with null. successfulAsList(ListenableFuture&lt;V>...)&#xA;&#xA;* An AsyncFunction&lt;A, B> provides one method, ListenableFuture&lt;B> apply(A input). It can be used to asynchronously transform a value.&#xA;List&lt;ListenableFuture&lt;QueryResult>> queries;&#xA;// The queries go to all different data centers, but we want to wait until they're all done or failed.&#xA;&#xA;ListenableFuture&lt;List&lt;QueryResult>> successfulQueries = Futures.successfulAsList(queries);&#xA;&#xA;Futures.addCallback(successfulQueries, callbackOnSuccessfulQueries);&#xA;CheckedFuture&#xA;Guava also provides a CheckedFuture&lt;V, X extends Exception> interface. A CheckedFuture is a ListenableFuture that includes versions of the get methods that can throw a checked exception. This makes it easier to create a future that executes logic which can throw an exception. To convert a ListenableFuture to a CheckedFuture, use Futures.makeChecked(ListenableFuture&lt;V>, Function&lt;Exception, X>).&#xA; owner: wasserman.louis&#xA; last update: Apr 23, 2012"/>
    <pages name="RangesExplained" body="summary: Guava's powerful Range API, explained.&#xA;TODO: lots more examples&#xA;Example&#xA;List&lt;Double> scores;&#xA;Iterable&lt;Double> belowMedianScores = Iterables.filter(scores, Range.lessThan(median));&#xA;...&#xA;Range&lt;Integer> validGrades = Range.closed(1, 12);&#xA;for(int grade : ContiguousSet.create(validGrades, DiscreteDomain.integers())) {&#xA;  ...&#xA;}&#xA;Introduction&#xA;A range, sometimes known as an interval, is a convex (informally, &quot;contiguous&quot; or &quot;unbroken&quot;) portion of a particular domain. Formally, convexity means that for any a &lt;= b &lt;= c, range.contains(a) &amp;&amp; range.contains(c) implies that range.contains(b).&#xA;Ranges may &quot;extend to infinity&quot; -- for example, the range &quot;x > 3&quot; contains arbitrarily large values -- or may be finitely constrained, for example &quot;2 &lt;= x &lt; 5&quot;. We will use the more compact notation, familiar to programmers with a math background:&#xA;(a..b) = {x | a &lt; x &lt; b} [a..b] = {x | a &lt;= x &lt;= b} [a..b) = {x | a &lt;= x &lt; b} (a..b] = {x | a &lt; x &lt;= b} (a..+&#x221e;) = {x | x > a} [a..+&#x221e;) = {x | x >= a} (-&#x221e;..b) = {x | x &lt; b} (-&#x221e;..b] = {x | x &lt;= b} (-&#x221e;..+&#x221e;) = all values&#xA;The values a and b used above are called endpoints. To improve consistency, Guava's notion of Range requires that the upper endpoint may not be less than the lower endpoint. The endpoints may be equal only if at least one of the bounds is closed:&#xA;[a..a] : singleton range [a..a); (a..a] : empty, but valid (a..a) : invalid&#xA;A range in Guava has the type Range&lt;C>. All ranges are immutable.&#xA;Building Ranges&#xA;Ranges can be obtained from the static methods on Range:&#xA;(a..b) open(C, C) [a..b] closed(C, C) [a..b) closedOpen(C, C) (a..b] openClosed(C, C) (a..+&#x221e;) greaterThan(C) [a..+&#x221e;) atLeast(C) (-&#x221e;..b) lessThan(C) (-&#x221e;..b] atMost(C) (-&#x221e;..+&#x221e;) all()&#xA;&#xA;Range.closed(&quot;left&quot;, &quot;right&quot;); // all strings lexographically between &quot;left&quot; and &quot;right&quot; inclusive&#xA;Range.lessThan(4.0); // double values strictly less than 4&#xA;Additionally, Range instances can be constructed by passing the bound types explicitly:&#xA;Bounded on both ends range(C, BoundType, C, BoundType) Unbounded on top ((a..+&#x221e;) or [a..+&#x221e;)) downTo(C, BoundType) Unbounded on bottom ((-&#x221e;..b) or (-&#x221e;..b]) upTo(C, BoundType)&#xA;&#xA;Here, BoundType is an enum containing the values CLOSED and OPEN.&#xA;Range.downTo(4, boundType); // allows you to decide whether or not you want to include 4&#xA;Range.range(1, CLOSED, 4, OPEN); // another way of writing Range.closedOpen(1, 4)&#xA;Operations&#xA;The fundamental operation of a Range is its contains(C) methods, which behaves exactly as you might expect. Additionally, a Range may be used as a Predicate, and used in functional idioms. Any Range also supports containsAll(Iterable&lt;? extends C>).&#xA;Range.closed(1, 3).contains(2); // returns true&#xA;Range.closed(1, 3).contains(4); // returns false&#xA;Range.lessThan(5).contains(5); // returns false&#xA;Range.closed(1, 4).containsAll(Ints.asList(1, 2, 3)); // returns true&#xA;Query Operations&#xA;To look at the endpoints of a range, Range exposes the following methods:&#xA;hasLowerBound() and hasUpperBound(), which check if the range has the specified endpoints, or goes on &quot;through infinity.&quot; lowerBoundType() and upperBoundType() return the BoundType for the corresponding endpoint, which can be either CLOSED or OPEN. If this range does not have the specified endpoint, the method throws an IllegalStateException. lowerEndpoint() and upperEndpoint() return the endpoints on the specified end, or throw an IllegalStateException if the range does not have the specified endpoint. isEmpty() tests if the range is empty, that is, it has the form [a,a) or (a,a].&#xA;&#xA;Range.closedOpen(4, 4).isEmpty(); // returns true&#xA;Range.openClosed(4, 4).isEmpty(); // returns true&#xA;Range.closed(4, 4).isEmpty(); // returns false&#xA;Range.open(4, 4).isEmpty(); // Range.open throws IllegalArgumentException&#xA;&#xA;Range.closed(3, 10).lowerEndpoint(); // returns 3&#xA;Range.open(3, 10).lowerEndpoint(); // returns 3&#xA;Range.closed(3, 10).lowerBoundType(); // returns CLOSED&#xA;Range.open(3, 10).upperBoundType(); // returns OPEN&#xA;Interval Operations&#xA;encloses&#xA;The most basic relation on ranges is encloses(Range), which is true if the bounds of the inner range do not extend outside the bounds of the outer range. This is solely dependent on comparisons between the endpoints!&#xA;[3..6] encloses [4..5] (3..6) encloses (3..6) [3..6] encloses [4..4) (even though the latter is empty) (3..6] does not enclose [3..6] [4..5] does not enclose (3..6) even though it contains every value contained by the latter range, although use of discrete domains can address this (see below) [3..6] does not enclose (1..1] even though it contains every value contained by the latter range&#xA;encloses is a partial ordering.&#xA;Given this, Range provides the following operations:&#xA;isConnected&#xA;Range.isConnected(Range), which tests if these ranges are connected. Specifically, isConnected tests if there is some range enclosed by both of these ranges, but this is equivalent to the mathematical definition that the union of the ranges must form a connected set (except in the special case of empty ranges).&#xA;isConnected is a reflexive, symmetric relation.&#xA;Range.closed(3, 5).isConnected(Range.open(5, 10)); // returns true&#xA;Range.closed(0, 9).isConnected(Range.closed(3, 4)); // returns true&#xA;Range.closed(0, 5).isConnected(Range.closed(3, 9)); // returns true&#xA;Range.open(3, 5).isConnected(Range.open(5, 10)); // returns false&#xA;Range.closed(1, 5).isConnected(Range.closed(6, 10)); // returns false&#xA;intersection&#xA;Range.intersection(Range) returns the maximal range enclosed by both this range and other (which exists iff these ranges are connected), or if no such range exists, throws an IllegalArgumentException.&#xA;intersection is a commutative, associative operation.&#xA;Range.closed(3, 5).intersection(Range.open(5, 10)); // returns (5, 5]&#xA;Range.closed(0, 9).intersection(Range.closed(3, 4)); // returns [3, 4]&#xA;Range.closed(0, 5).intersection(Range.closed(3, 9)); // returns [3, 5]&#xA;Range.open(3, 5).intersection(Range.open(5, 10)); // throws IAE&#xA;Range.closed(1, 5).intersection(Range.closed(6, 10)); // throws IAE&#xA;span&#xA;Range.span(Range) returns the minimal range that encloses both this range and other. If the ranges are both connected, this is their union.&#xA;span is a commutative, associative, and closed operation.&#xA;Range.closed(3, 5).span(Range.open(5, 10)); // returns [3, 10)&#xA;Range.closed(0, 9).span(Range.closed(3, 4)); // returns [0, 9]&#xA;Range.closed(0, 5).span(Range.closed(3, 9)); // returns [0, 9]&#xA;Range.open(3, 5).span(Range.open(5, 10)); // returns (3, 10)&#xA;Range.closed(1, 5).span(Range.closed(6, 10)); // returns [1, 10]&#xA;Discrete Domains&#xA;Some types, but not all Comparable types, are discrete, meaning that ranges bounded on both sides can be enumerated.&#xA;In Guava, a DiscreteDomain&lt;C> implements discrete operations for type C. A discrete domain always represents the entire set of values of its type; it cannot represent partial domains such as &quot;prime integers&quot;, &quot;strings of length 5,&quot; or &quot;timestamps at midnight.&quot;&#xA;The DiscreteDomain class provides DiscreteDomain instances:&#xA;Type DiscreteDomain Integer integers() Long longs()&#xA;&#xA;Once you have a DiscreteDomain, you can use the following Range operations:&#xA;ContiguousSet.create(range, domain): view a Range&lt;C> as an ImmutableSortedSet&lt;C>, with a few extra operations thrown in. (Does not work for unbounded ranges, unless the type itself is bounded.) canonical(domain): put ranges in a &quot;canonical form.&quot; If ContiguousSet.create(a, domain).equals(ContiguousSet.create(b, domain)) and !a.isEmpty(), then a.canonical(domain).equals(b.canonical(domain)). (This does not, however, imply a.equals(b).)&#xA;&#xA;ImmutableSortedSet&lt;Integer> set = ContiguousSet.create(Range.open(1, 5), DiscreteDomain.integers());&#xA;// set contains [2, 3, 4]&#xA;&#xA;ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers());&#xA;// set contains [1, 2, ..., Integer.MAX_VALUE]&#xA;Note that ContiguousSet.create does not actually construct the entire range, but instead returns a view of the range as a set.&#xA;Your Own DiscreteDomains&#xA;You can make your own DiscreteDomain objects, but there are several important aspects of the DiscreteDomain contract that you must remember.&#xA;A discrete domain always represents the entire set of values of its type; it cannot represent partial domains such as &quot;prime integers&quot; or &quot;strings of length 5.&quot; So you cannot, for example, construct a DiscreteDomain to view a set of days in a range, with a JODA DateTime that includes times up to the second: because this would not contain all elements of the type. A DiscreteDomain may be infinite -- a BigInteger DiscreteDomain, for example. In this case, you should use the default implementation of minValue() and maxValue(), which throw a NoSuchElementException. This forbids you from using the ContiguousSet.create method on an infinite range, however!&#xA;What if I need a Comparator?&#xA;We wanted to strike a very specific balance in Range between power and API complexity, and part of that involved not providing a Comparator-based interface: we don't need to worry about how ranges based on different comparators interact; the API signatures are all significantly simplified; things are just nicer.&#xA;On the other hand, if you think you want an arbitrary Comparator, you can do one of the following:&#xA;Use a general Predicate and not Range. (Since Range implements the Predicate interface, you can use Predicates.compose(range, function) to get a Predicate.) Use a wrapper class around your objects that defines the desired ordering.&#xA; owner: cpov...@google.com&#xA; last update: May 28, 2014"/>
    <pages name="ReflectionExplained" body="summary: Guava's new reflection utilities, explained.&#xA;TypeToken&#xA;Due to type erasure, you can't pass around generic Class objects at runtime -- you might be able to cast them and pretend they're generic, but they really aren't.&#xA;For example:&#xA;ArrayList&lt;String> stringList = Lists.newArrayList();&#xA;ArrayList&lt;Integer> intList = Lists.newArrayList();&#xA;System.out.println(stringList.getClass().isAssignableFrom(intList.getClass()));&#xA;  // returns true, even though ArrayList&lt;String> is not assignable from ArrayList&lt;Integer>&#xA;Guava provides TypeToken, which uses reflection-based tricks to allow you to manipulate and query generic types, even at runtime. Think of a TypeToken as a way of creating, manipulating, and querying Type (and, implicitly Class) objects in a way that respects generics.&#xA;Note to Guice users: TypeToken is similar to Guice's TypeLiteral class, but with one important difference: it supports non-reified types such as T, List&lt;T> or even List&lt;? extends Number>; while TypeLiteral does not. TypeToken is also serializable and offers numerous additional utility methods.&#xA;Background: Type Erasure and Reflection&#xA;Java doesn't retain generic type information for objects at runtime. If you have an ArrayList&lt;String> object at runtime, you cannot determine that it had the generic type ArrayList&lt;String> -- and you can, with unsafe raw types, cast it to ArrayList&lt;Object>.&#xA;However, reflection allows you to detect the generic types of methods and classes. If you implement a method that returns a List&lt;String>, and you use reflection to obtain the return type of that method, you get back a ParameterizedType representing List&lt;String>.&#xA;The TypeToken class uses this workaround to allow the manipulation of generic types with a minimum of syntactic overhead.&#xA;Introduction&#xA;Obtaining a TypeToken for a basic, raw class is as simple as&#xA;TypeToken&lt;String> stringTok = TypeToken.of(String.class);&#xA;TypeToken&lt;Integer> intTok = TypeToken.of(Integer.class);&#xA;To obtain a TypeToken for a type with generics -- when you know the generic type arguments at compile time -- you use an empty anonymous inner class:&#xA;TypeToken&lt;List&lt;String>> stringListTok = new TypeToken&lt;List&lt;String>>() {};&#xA;Or if you want to deliberately refer to a wildcard type:&#xA;TypeToken&lt;Map&lt;?, ?>> wildMapTok = new TypeToken&lt;Map&lt;?, ?>>() {};&#xA;TypeToken provides a way to dynamically resolve generic type arguments, like this:&#xA;static &lt;K, V> TypeToken&lt;Map&lt;K, V>> mapToken(TypeToken&lt;K> keyToken, TypeToken&lt;V> valueToken) {&#xA;  return new TypeToken&lt;Map&lt;K, V>>() {}&#xA;    .where(new TypeParameter&lt;K>() {}, keyToken)&#xA;    .where(new TypeParameter&lt;V>() {}, valueToken);&#xA;}&#xA;...&#xA;TypeToken&lt;Map&lt;String, BigInteger>> mapToken = mapToken(&#xA;   TypeToken.of(String.class),&#xA;   TypeToken.of(BigInteger.class));&#xA;TypeToken&lt;Map&lt;Integer, Queue&lt;String>>> complexToken = mapToken(&#xA;   TypeToken.of(Integer.class),&#xA;   new TypeToken&lt;Queue&lt;String>>() {});&#xA;Note that if mapToken just returned new TypeToken&lt;Map&lt;K, V>>(), it could not actually reify the types assigned to K and V, so for example&#xA;class Util {&#xA;  static &lt;K, V> TypeToken&lt;Map&lt;K, V>> incorrectMapToken() {&#xA;    return new TypeToken&lt;Map&lt;K, V>>() {};&#xA;  }&#xA;}&#xA;&#xA;System.out.println(Util.&lt;String, BigInteger>incorrectMapToken());&#xA;// just prints out &quot;java.util.Map&lt;K, V>&quot;&#xA;Alternately, you can capture a generic type with a (usually anonymous) subclass and resolve it against a context class that knows what the type parameters are.&#xA;abstract class IKnowMyType&lt;T> {&#xA;  TypeToken&lt;T> type = new TypeToken&lt;T>(getClass()) {};&#xA;}&#xA;...&#xA;new IKnowMyType&lt;String>() {}.type; // returns a correct TypeToken&lt;String>&#xA;With this technique, you can, for example, get classes that know their element types.&#xA;Queries&#xA;TypeToken supports many of the queries supported by Class, but with generic constraints properly taken into account.&#xA;Supported query operations include:&#xA;Method Description getType() Returns the wrapped java.lang.reflect.Type. getRawType() Returns the most-known runtime class. getSubtype(Class&lt;?>) Returns some subtype of this that has the specified raw class. For example, if this is Iterable&lt;String> and the argument is List.class, the result will be List&lt;String>. getSupertype(Class&lt;?>) Generifies the specified raw class to be a supertype of this type. For example, if this is Set&lt;String> and the argument is Iterable.class, the result will be Iterable&lt;String>. isAssignableFrom(type) Returns true if this type is assignable from the given type, taking into account generic parameters. List&lt;? extends Number> is assignable from List&lt;Integer>, but List&lt;String> is not. getTypes() Returns the set of all classes and interfaces that this type is or is a subtype of. The returned Set also provides methods classes() and interfaces() to let you view only the superclasses and superinterfaces. isArray() Checks if this type is known to be an array, such as int[] or even &lt;? extends A[]>. getComponentType() Returns the array component type.&#xA;&#xA;resolveType&#xA;resolveType is a powerful but complex query operation that can be used to &quot;substitute&quot; type arguments from the context token. For example,&#xA;TypeToken&lt;Function&lt;Integer, String>> funToken = new TypeToken&lt;Function&lt;Integer, String>>() {};&#xA;&#xA;TypeToken&lt;?> funResultToken = funToken.resolveType(Function.class.getTypeParameters()[1]));&#xA;  // returns a TypeToken&lt;String>&#xA;TypeToken unifies the TypeVariables provided by Java with the values of those type variables from the &quot;context&quot; token. This can be used to generically deduce the return types of methods on a type:&#xA;TypeToken&lt;Map&lt;String, Integer>> mapToken = new TypeToken&lt;Map&lt;String, Integer>>() {};&#xA;TypeToken&lt;?> entrySetToken = mapToken.resolveType(Map.class.getMethod(&quot;entrySet&quot;).getGenericReturnType());&#xA;  // returns a TypeToken&lt;Set&lt;Map.Entry&lt;String, Integer>>>&#xA;Invokable&#xA;Guava Invokable is a fluent wrapper of java.lang.reflect.Method and java.lang.reflect.Constructor. It simplifies common reflective code using either. Some usage examples follow:&#xA;Is the method public?&#xA;JDK:&#xA;Modifier.isPublic(method.getModifiers())&#xA;Invokable:&#xA;invokable.isPublic()&#xA;Is the method package private?&#xA;JDK:&#xA;!(Modifier.isPrivate(method.getModifiers()) || Modifier.isPublic(method.getModifiers()))&#xA;Invokable:&#xA;invokable.isPackagePrivate()&#xA;Can the method be overridden by subclasses?&#xA;JDK:&#xA;!(Modifier.isFinal(method.getModifiers())&#xA;    || Modifiers.isPrivate(method.getModifiers())&#xA;    || Modifiers.isStatic(method.getModifiers())&#xA;    || Modifiers.isFinal(method.getDeclaringClass().getModifiers()))&#xA;Invokable:&#xA;invokable.isOverridable()&#xA;Is the first parameter of the method annotated with @Nullable?&#xA;JDK:&#xA;for (Annotation annotation : method.getParameterAnnotations[0]) {&#xA;  if (annotation instanceof Nullable) {&#xA;    return true;&#xA;  }&#xA;}&#xA;return false;&#xA;Invokable:&#xA;invokable.getParameters().get(0).isAnnotationPresent(Nullable.class)&#xA;How to share the same code for both constructors and factory methods?&#xA;Are you tempted to repeat yourself because your reflective code needs to work for both constructors and factory methods in the same way?&#xA;Invokable offers an abstraction. The following code works with either Method or Constructor:&#xA;invokable.isPublic();&#xA;invokable.getParameters();&#xA;invokable.invoke(object, args);&#xA;What's the return type of List.get(int) for List&lt;String>?&#xA;Invokable provides type resolution out of the box:&#xA;Invokable&lt;List&lt;String>, ?> invokable = new TypeToken&lt;List&lt;String>>() {}.method(getMethod);&#xA;invokable.getReturnType(); // String.class&#xA;Dynamic Proxies&#xA;newProxy()&#xA;Utility method Reflection.newProxy(Class, InvocationHandler) is a type safer and more convenient API to create Java dynamic proxies when only a single interface type is to be proxied.&#xA;JDK:&#xA;Foo foo = (Foo) Proxy.newProxyInstance(&#xA;    Foo.class.getClassLoader(),&#xA;    new Class&lt;?>[] {Foo.class},&#xA;    invocationHandler);&#xA;Guava:&#xA;Foo foo = Reflection.newProxy(Foo.class, invocationHandler);&#xA;AbstractInvocationHandler&#xA;Sometimes you may want your dynamic proxy to support equals(), hashCode() and toString() in the intuitive way, that is:&#xA;A proxy instance is equal to another proxy instance if they are for the same interface types and have equal invocation handlers. A proxy's toString() delegates to the invocation handler's toString() for easier customization.&#xA;&#xA;AbstractInvocationHandler implements this logic.&#xA;In addition, AbstractInvocationHandler ensures that the argument array passed to handleInvocation(Object, Method, Object[]) is never null, thus less chance of NullPointerException.&#xA;ClassPath&#xA;Strictly speaking, Java has no platform-independent way to browse through classes or class path resources. It is however sometimes desirable to be able to go through all classes under a certain package or project, for example, to check that certain project convention or constraint is being followed.&#xA;ClassPath is a utility that offers best-effort class path scanning. Usage is simple:&#xA;ClassPath classpath = ClassPath.from(classloader); // scans the class path used by classloader&#xA;for (ClassPath.ClassInfo classInfo : classpath.getTopLevelClasses(&quot;com.mycomp.mypackage&quot;)) {&#xA;  ...&#xA;}&#xA;In the above example, ClassInfo is a handle to the class to be loaded. It allows programmers to check the class name or package name and only load the class until necessary.&#xA;It's worth noting that ClassPath is a best-effort utility. It only scans classes in jar files or under a file system directory. Neither can it scan classes managed by custom class loaders that aren't URLClassLoader. So don't use it for mission critical production tasks.&#xA;Class Loading&#xA;The utility method Reflection.initialize(Class...) ensures that the specified classes are initialized -- for example, any static initialization is performed.&#xA;The use of this method is a code smell, because static state hurts system maintainability and testability. In cases when you have no choice while inter-operating with a legacy framework, this method helps to keep the code less ugly.&#xA; owner: be...@google.com&#xA; last update: Apr 13, 2013"/>
    <pages name="CachesExplained" body="summary: Explanation for how to use Guava caches.&#xA;Example&#xA;LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()&#xA;       .maximumSize(1000)&#xA;       .expireAfterWrite(10, TimeUnit.MINUTES)&#xA;       .removalListener(MY_LISTENER)&#xA;       .build(&#xA;           new CacheLoader&lt;Key, Graph>() {&#xA;             public Graph load(Key key) throws AnyException {&#xA;               return createExpensiveGraph(key);&#xA;             }&#xA;           });&#xA;Applicability&#xA;Caches are tremendously useful in a wide variety of use cases. For example, you should consider using caches when a value is expensive to compute or retrieve, and you will need its value on a certain input more than once.&#xA;A Cache is similar to ConcurrentMap, but not quite the same. The most fundamental difference is that a ConcurrentMap persists all elements that are added to it until they are explicitly removed. A Cache on the other hand is generally configured to evict entries automatically, in order to constrain its memory footprint. In some cases a LoadingCache can be useful even if it doesn't evict entries, due to its automatic cache loading.&#xA;Generally, the Guava caching utilities are applicable whenever:&#xA;You are willing to spend some memory to improve speed. You expect that keys will sometimes get queried more than once. Your cache will not need to store more data than what would fit in RAM. (Guava caches are local to a single run of your application. They do not store data in files, or on outside servers. If this does not fit your needs, consider a tool like Memcached.)&#xA;If each of these apply to your use case, then the Guava caching utilities could be right for you!&#xA;Obtaining a Cache is done using the CacheBuilder builder pattern as demonstrated by the example code above, but customizing your cache is the interesting part.&#xA;Note: If you do not need the features of a Cache, ConcurrentHashMap is more memory-efficient -- but it is extremely difficult or impossible to duplicate most Cache features with any old ConcurrentMap.&#xA;Population&#xA;The first question to ask yourself about your cache is: is there some sensible default function to load or compute a value associated with a key? If so, you should use a CacheLoader. If not, or if you need to override the default, but you still want atomic &quot;get-if-absent-compute&quot; semantics, you should pass a Callable into a get call. Elements can be inserted directly, using Cache.put, but automatic cache loading is preferred as it makes it easier to reason about consistency across all cached content.&#xA;From a CacheLoader&#xA;A LoadingCache is a Cache built with an attached CacheLoader. Creating a CacheLoader is typically as easy as implementing the method V load(K key) throws Exception. So, for example, you could create a LoadingCache with the following code:&#xA;LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()&#xA;       .maximumSize(1000)&#xA;       .build(&#xA;           new CacheLoader&lt;Key, Graph>() {&#xA;             public Graph load(Key key) throws AnyException {&#xA;               return createExpensiveGraph(key);&#xA;             }&#xA;           });&#xA;&#xA;...&#xA;try {&#xA;  return graphs.get(key);&#xA;} catch (ExecutionException e) {&#xA;  throw new OtherException(e.getCause());&#xA;}&#xA;The canonical way to query a LoadingCache is with the method get(K). This will either return an already cached value, or else use the cache's CacheLoader to atomically load a new value into the cache. Because CacheLoader might throw an Exception, LoadingCache.get(K) throws ExecutionException. If you have defined a CacheLoader that does not declare any checked exceptions then you can perform cache lookups using getUnchecked(K); however care must be taken not to call getUnchecked on caches whose CacheLoaders declare checked exceptions.&#xA;LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()&#xA;       .expireAfterAccess(10, TimeUnit.MINUTES)&#xA;       .build(&#xA;           new CacheLoader&lt;Key, Graph>() {&#xA;             public Graph load(Key key) { // no checked exception&#xA;               return createExpensiveGraph(key);&#xA;             }&#xA;           });&#xA;&#xA;...&#xA;return graphs.getUnchecked(key);&#xA;Bulk lookups can be performed with the method getAll(Iterable&lt;? extends K>). By default, getAll will issue a a separate call to CacheLoader.load for each key which is absent from the cache. When bulk retrieval is more efficient than many individual lookups, you can override CacheLoader.loadAll to exploit this. The performance of getAll(Iterable) will improve accordingly.&#xA;Note that you can write a CacheLoader.loadAll implementation that loads values for keys that were not specifically requested. For example, if computing the value of any key from some group gives you the value for all keys in the group, loadAll might load the rest of the group at the same time.&#xA;From a Callable&#xA;All Guava caches, loading or not, support the method get(K, Callable&lt;V>). This method returns the value associated with the key in the cache, or computes it from the specified Callable and adds it to the cache. No observable state associated with this cache is modified until loading completes. This method provides a simple substitute for the conventional &quot;if cached, return; otherwise create, cache and return&quot; pattern.&#xA;Cache&lt;Key, Value> cache = CacheBuilder.newBuilder()&#xA;    .maximumSize(1000)&#xA;    .build(); // look Ma, no CacheLoader&#xA;...&#xA;try {&#xA;  // If the key wasn't in the &quot;easy to compute&quot; group, we need to&#xA;  // do things the hard way.&#xA;  cache.get(key, new Callable&lt;Value>() {&#xA;    @Override&#xA;    public Value call() throws AnyException {&#xA;      return doThingsTheHardWay(key);&#xA;    }&#xA;  });&#xA;} catch (ExecutionException e) {&#xA;  throw new OtherException(e.getCause());&#xA;}&#xA;Inserted Directly&#xA;Values may be inserted into the cache directly with cache.put(key, value). This overwrites any previous entry in the cache for the specified key. Changes can also be made to a cache using any of the ConcurrentMap methods exposed by the Cache.asMap() view. Note that no method on the asMap view will ever cause entries to be automatically loaded into the cache. Further, the atomic operations on that view operate outside the scope of automatic cache loading, so Cache.get(K, Callable&lt;V>) should always be preferred over Cache.asMap().putIfAbsent in caches which load values using either CacheLoader or Callable.&#xA;Eviction&#xA;The cold hard reality is that we almost certainly don't have enough memory to cache everything we could cache. You must decide: when is it not worth keeping a cache entry? Guava provides three basic types of eviction: size-based eviction, time-based eviction, and reference-based eviction.&#xA;Size-based Eviction&#xA;If your cache should not grow beyond a certain size, just use CacheBuilder.maximumSize(long). The cache will try to evict entries that haven't been used recently or very often. Warning: the cache may evict entries before this limit is exceeded -- typically when the cache size is approaching the limit.&#xA;Alternately, if different cache entries have different &quot;weights&quot; -- for example, if your cache values have radically different memory footprints -- you may specify a weight function with CacheBuilder.weigher(Weigher) and a maximum cache weight with CacheBuilder.maximumWeight(long). In addition to the same caveats as maximumSize requires, be aware that weights are computed at entry creation time, and are static thereafter.&#xA;LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()&#xA;       .maximumWeight(100000)&#xA;       .weigher(new Weigher&lt;Key, Graph>() {&#xA;          public int weigh(Key k, Graph g) {&#xA;            return g.vertices().size();&#xA;          }&#xA;        })&#xA;       .build(&#xA;           new CacheLoader&lt;Key, Graph>() {&#xA;             public Graph load(Key key) { // no checked exception&#xA;               return createExpensiveGraph(key);&#xA;             }&#xA;           });&#xA;Timed Eviction&#xA;CacheBuilder provides two approaches to timed eviction:&#xA;expireAfterAccess(long, TimeUnit) Only expire entries after the specified duration has passed since the entry was last accessed by a read or a write. Note that the order in which entries are evicted will be similar to that of size-based eviction. expireAfterWrite(long, TimeUnit) Expire entries after the specified duration has passed since the entry was created, or the most recent replacement of the value. This could be desirable if cached data grows stale after a certain amount of time.&#xA;Timed expiration is performed with periodic maintenance during writes and occasionally during reads, as discussed below.&#xA;Testing Timed Eviction&#xA;Testing timed eviction doesn't have to be painful...and doesn't actually have to take you two seconds to test a two-second expiration. Use the Ticker interface and the CacheBuilder.ticker(Ticker) method to specify a time source in your cache builder, rather than having to wait for the system clock.&#xA;Reference-based Eviction&#xA;Guava allows you to set up your cache to allow the garbage collection of entries, by using weak references for keys or values, and by using soft references for values.&#xA;CacheBuilder.weakKeys() stores keys using weak references. This allows entries to be garbage-collected if there are no other (strong or soft) references to the keys. Since garbage collection depends only on identity equality, this causes the whole cache to use identity (==) equality to compare keys, instead of equals(). CacheBuilder.weakValues() stores values using weak references. This allows entries to be garbage-collected if there are no other (strong or soft) references to the values. Since garbage collection depends only on identity equality, this causes the whole cache to use identity (==) equality to compare values, instead of equals(). CacheBuilder.softValues() wraps values in soft references. Softly referenced objects are garbage-collected in a globally least-recently-used manner, in response to memory demand. Because of the performance implications of using soft references, we generally recommend using the more predictable maximum cache size instead. Use of softValues() will cause values to be compared using identity (==) equality instead of equals().&#xA;Explicit Removals&#xA;At any time, you may explicitly invalidate cache entries rather than waiting for entries to be evicted. This can be done:&#xA;individually, using Cache.invalidate(key) in bulk, using Cache.invalidateAll(keys) to all entries, using Cache.invalidateAll()&#xA;Removal Listeners&#xA;You may specify a removal listener for your cache to perform some operation when an entry is removed, via CacheBuilder.removalListener(RemovalListener). The RemovalListener gets passed a RemovalNotification, which specifies the RemovalCause, key, and value.&#xA;Note that any exceptions thrown by the RemovalListener are logged (using Logger) and swallowed.&#xA;CacheLoader&lt;Key, DatabaseConnection> loader = new CacheLoader&lt;Key, DatabaseConnection> () {&#xA;  public DatabaseConnection load(Key key) throws Exception {&#xA;    return openConnection(key);&#xA;  }&#xA;};&#xA;RemovalListener&lt;Key, DatabaseConnection> removalListener = new RemovalListener&lt;Key, DatabaseConnection>() {&#xA;  public void onRemoval(RemovalNotification&lt;Key, DatabaseConnection> removal) {&#xA;    DatabaseConnection conn = removal.getValue();&#xA;    conn.close(); // tear down properly&#xA;  }&#xA;};&#xA;&#xA;return CacheBuilder.newBuilder()&#xA;  .expireAfterWrite(2, TimeUnit.MINUTES)&#xA;  .removalListener(removalListener)&#xA;  .build(loader);&#xA;Warning: removal listener operations are executed synchronously by default, and since cache maintenance is normally performed during normal cache operations, expensive removal listeners can slow down normal cache function! If you have an expensive removal listener, use RemovalListeners.asynchronous(RemovalListener, Executor) to decorate a RemovalListener to operate asynchronously.&#xA;When Does Cleanup Happen?&#xA;Caches built with CacheBuilder do not perform cleanup and evict values &quot;automatically,&quot; or instantly after a value expires, or anything of the sort. Instead, it performs small amounts of maintenance during write operations, or during occasional read operations if writes are rare.&#xA;The reason for this is as follows: if we wanted to perform Cache maintenance continuously, we would need to create a thread, and its operations would be competing with user operations for shared locks. Additionally, some environments restrict the creation of threads, which would make CacheBuilder unusable in that environment.&#xA;Instead, we put the choice in your hands. If your cache is high-throughput, then you don't have to worry about performing cache maintenance to clean up expired entries and the like. If your cache does writes only rarely and you don't want cleanup to block cache reads, you may wish to create your own maintenance thread that calls Cache.cleanUp() at regular intervals.&#xA;If you want to schedule regular cache maintenance for a cache which only rarely has writes, just schedule the maintenance using ScheduledExecutorService.&#xA;Refresh&#xA;Refreshing is not quite the same as eviction. As specified in LoadingCache.refresh(K), refreshing a key loads a new value for the key, possibly asynchronously. The old value (if any) is still returned while the key is being refreshed, in contrast to eviction, which forces retrievals to wait until the value is loaded anew.&#xA;If an exception is thrown while refreshing, the old value is kept, and the exception is logged and swallowed.&#xA;A CacheLoader may specify smart behavior to use on a refresh by overriding CacheLoader.reload(K, V), which allows you to use the old value in computing the new value.&#xA;// Some keys don't need refreshing, and we want refreshes to be done asynchronously.&#xA;LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()&#xA;       .maximumSize(1000)&#xA;       .refreshAfterWrite(1, TimeUnit.MINUTES)&#xA;       .build(&#xA;           new CacheLoader&lt;Key, Graph>() {&#xA;             public Graph load(Key key) { // no checked exception&#xA;               return getGraphFromDatabase(key);&#xA;             }&#xA;&#xA;             public ListenableFuture&lt;Graph> reload(final Key key, Graph prevGraph) {&#xA;               if (neverNeedsRefresh(key)) {&#xA;                 return Futures.immediateFuture(prevGraph);&#xA;               } else {&#xA;                 // asynchronous!&#xA;                 ListenableFutureTask&lt;Graph> task = ListenableFutureTask.create(new Callable&lt;Graph>() {&#xA;                   public Graph call() {&#xA;                     return getGraphFromDatabase(key);&#xA;                   }&#xA;                 });&#xA;                 executor.execute(task);&#xA;                 return task;&#xA;               }&#xA;             }&#xA;           });&#xA;Automatically timed refreshing can be added to a cache using CacheBuilder.refreshAfterWrite(long, TimeUnit). In contrast to expireAfterWrite, refreshAfterWrite will make a key eligible for refresh after the specified duration, but a refresh will only be actually initiated when the entry is queried. (If CacheLoader.reload is implemented to be asynchronous, then the query will not be slowed down by the refresh.) So, for example, you can specify both refreshAfterWrite and expireAfterWrite on the same cache, so that the expiration timer on an entry isn't blindly reset whenever an entry becomes eligible for a refresh, so if an entry isn't queried after it comes eligible for refreshing, it is allowed to expire.&#xA;Features&#xA;Statistics&#xA;By using CacheBuilder.recordStats(), you can turn on statistics collection for Guava caches. The Cache.stats() method returns a CacheStats object, which provides statistics such as&#xA;hitRate(), which returns the ratio of hits to requests averageLoadPenalty(), the average time spent loading new values, in nanoseconds evictionCount(), the number of cache evictions&#xA;and many more statistics besides. These statistics are critical in cache tuning, and we advise keeping an eye on these statistics in performance-critical applications.&#xA;asMap&#xA;You can view any Cache as a ConcurrentMap using its asMap view, but how the asMap view interacts with the Cache requires some explanation.&#xA;cache.asMap() contains all entries that are currently loaded in the cache. So, for example, cache.asMap().keySet() contains all the currently loaded keys. asMap().get(key) is essentially equivalent to cache.getIfPresent(key), and never causes values to be loaded. This is consistent with the Map contract. Access time is reset by all cache read and write operations (including Cache.asMap().get(Object) and Cache.asMap().put(K, V)), but not by containsKey(Object), nor by operations on the collection-views of Cache.asMap(). So, for example, iterating through cache.entrySet() does not reset access time for the entries you retrieve.&#xA;Interruption&#xA;Loading methods (like get) never throw InterruptedException. We could have designed these methods to support InterruptedException, but our support would have been incomplete, forcing its costs on all users but its benefits on only some. For details, read on.&#xA;get calls that request uncached values fall into two broad categories: those that load the value and those that await another thread's in-progress load. The two differ in our ability to support interruption. The easy case is waiting for another thread's in-progress load: Here we could enter an interruptible wait. The hard case is loading the value ourselves. Here we're at the mercy of the user-supplied CacheLoader. If it happens to support interruption, we can support interruption; if not, we can't.&#xA;So why not support interruption when the supplied CacheLoader does? In a sense, we do (but see below): If the CacheLoader throws InterruptedException, all get calls for the key will return promptly (just as with any other exception). Plus, get will restore the interrupt bit in the loading thread. The surprising part is that the InterruptedException is wrapped in an ExecutionException.&#xA;In principle, we could unwrap this exception for you. However, this forces all LoadingCache users to handle InterruptedException, even though the majority of CacheLoader implementations never throw it. Maybe that's still worthwhile when you consider that all non-loading threads' waits could still be interrupted. But many caches are used only in a single thread. Their users must still catch the impossible InterruptedException. And even those users who share their caches across threads will be able to interrupt their get calls only sometimes, based on which thread happens to make a request first.&#xA;Our guiding principle in this decision is for the cache to behave as though all values are loaded in the calling thread. This principle makes it easy to introduce caching into code that previously recomputed its values on each call. And if the old code wasn't interruptible, then it's probably OK for the new code not to be, either.&#xA;I said that we support interruption &quot;in a sense.&quot; There's another sense in which we don't, making LoadingCache a leaky abstraction. If the loading thread is interrupted, we treat this much like any other exception. That's fine in many cases, but it's not the right thing when multiple get calls are waiting for the value. Although the operation that happened to be computing the value was interrupted, the other operations that need the value might not have been. Yet all of these callers receive the InterruptedException (wrapped in an ExceptionException), even though the load didn't so much &quot;fail&quot; as &quot;abort.&quot; The right behavior would be for one of the remaining threads to retry the load. We have a bug filed for this. However, a fix could be risky. Instead of fixing the problem, we may put additional effort into a proposed AsyncLoadingCache, which would return Future objects with correct interruption behavior.&#xA; owner: cgdecker@google.com&#xA; last update: Mar 24, 2014"/>
    <pages name="MapMakerMigration" body="summary: How to migrate away from deprecated MapMaker functionality&#xA;Introduction&#xA;All caching related methods on MapMaker have been deprecated in favor of similar methods in CacheBuilder, and are scheduled for upcoming deletion. Release 11.0.0 already removed evictionListener, expireAfterWrite, and expireAfterAccess. Future releases will remove makeComputingMap and expiration.&#xA;Most MapMaker use cases should be migrated to either CacheBuilder or AtomicLongMap. Specifically, cases when MapMaker is used to construct maps with AtomicLong values should generally be migrated to AtomicLongMap. Other cases where MapMaker caching functionality is used (including all uses of MapMaker.makeComputingMap(Function)) should be migrated to CacheBuilder.&#xA;Migrating from MapMaker.makeMap() to CacheBuilder.build() is trivial, but migrating from MapMaker.makeComputingMap(Function) to CacheBuilder.build(CacheLoader) involves some subtle behavioral changes. Specifically, MapMaker.makeComputingMap(Function) returns a ConcurrentMap, while CacheBuilder.build(CacheLoader) returns a LoadingCache. While LoadingCache has an asMap() method, the map returned by that map is much different from the map created by MapMaker.&#xA;MapMaker and ConcurrentMap&#xA;MapMaker.makeComputingMap(Function) returned a magical (and ill-behaved) ConcurrentMap. Specifically, calls to Map.get(Object) on the returned map would automatically compute values for absent keys using the specified Function. These computations would be shared by all concurrent computations on the same key. Such maps were, in effect, autovivification maps.&#xA;At first glance this behavior is tremendously useful, but the specific implementation of this functionality behind a plain ConcurrentMap was riddled with issues.&#xA;Having a Map that auto-creates entries on get was simply a big mistake. It breaks type-safety (you can use it to store a key in the map that isn't of the map's key type!). Bad things will happen if that Map accidentally gets passed to another Map's equals() method. Common idioms for Map usage (in the absence of null values) are based on the assumption of interchangeability of containsKey(k) and (get(k) != null), and those coding patterns will break. Etc.&#xA;We studied this issue very closely, and concluded that our library will be easier to use when collections are just collections, iterators are just iterators, and things that are fancier than those have public types that convey their behavior sufficiently.&#xA;CacheBuilder and LoadingCache&#xA;And thus we introduced the LoadingCache interface. The primary intent of this new interface was to encapsulate a get(K) method which auto-created entries, while still exposing an asMap() view which allowed traditional map-style access to the cache internals. In other words, the magical get from MapMaker.makeComputingMap(Function) was semantically separated from the other ConcurrentMap methods. Note that LoadingCache.get(K) will automatically load absent entries, however LoadingCache.asMap.get(Object) will not.&#xA;The new LoadingCache interface came with a new builder, CacheBuilder, patterned after MapMaker but with an explicit focus on caching, and only capable of producing LoadingCache (and Cache) instances, instead of ConcurrentMaps.&#xA;Migrating from MapMaker to CacheBuilder&#xA;Now that we understand the key distinction between MapMaker and LoadingCache we turn to the subject of migrating old code from MapMaker to CacheBuilder.&#xA;Computing caches&#xA;The biggest difference is the change from using a plain Function to compute values to a more sophisticated CacheLoader type.&#xA;CacheLoader has a few major differences from Function:&#xA;Its load(K key) method is permitted to throw exceptions. It provides a loadAll(Iterable&lt;? extends K>) method to load multiple keys at once -- possibly concurrently. (By default, loadAll just sequentially loads each key individually with the load method.) It provides a reload(K key, V oldValue) method for use in refreshing cached values asynchronously, for caches configured with refreshAfterWrite. By default, this synchronously calls load.&#xA;The simplest way to migrate a Function-based computing map to a CacheLoader is the CacheLoader.from(Function) adapter, which views a Function as a CacheLoader, no special effort required. That said, it's silly to call CacheLoader.from(new Function&lt;K, V>() {...}) when you can just write&#xA;new CacheLoader&lt;K, V>() {&#xA;  public V load(K key) {&#xA;    // copy/paste code from Function.apply&#xA;  }&#xA;};&#xA;asMap view&#xA;The biggest difference between the computing maps generated by MapMaker.makeComputingMap and the ConcurrentMap asMap() view of a Cache is that the asMap() view will never compute new values on a call to asMap().get(key). This is specifically deliberate to avoid the &quot;magical&quot; unpredictable behavior of computing maps.&#xA; owner: fry@google.com&#xA; last update: Mar 27, 2012"/>
    <pages name="AsymptoticsExplained" body="summary: One-sentence summary of this page.&#xA;The asymptotics of Guava's utilities are entirely predictable, but are listed here for completeness.&#xA;List&#xA;Implementation add add(i, elem) remove(i) contains Iteration size ArrayList (JDK) O(1) O(n) O(n) O(n) O(n) O(1) LinkedList (JDK) O(1) O(n) O(n) O(n) O(n) O(1) CopyOnWriteArrayList (JDK) O(n) O(n) O(n) O(n) O(n) O(1) ImmutableList N/A N/A N/A O(n) O(n) O(1) ImmutableSet.asList() N/A N/A N/A O(1) O(n) O(1)&#xA;&#xA;Set&#xA;Implementation add remove contains Iteration size HashSet (JDK) O(1) O(1) O(1) O(max n) * O(1) LinkedHashSet (JDK) O(1) O(1) O(1) O(n) O(1) TreeSet (JDK) O(log n) O(log n) O(log n) O(n) O(1) ** CopyOnWriteArraySet (JDK) O(n) O(n) O(n) O(n) O(1) ImmutableSet N/A N/A O(1) O(n) O(1) ImmutableSortedSet N/A N/A O(log n) O(n) O(1)&#xA;&#xA;* HashSet iteration takes time proportional to the maximum number of elements the HashSet has ever had, not proportional to the current number of elements.&#xA;** TreeSet.subSet(...).size() takes time proportional to the size of the subset.&#xA;Multiset&#xA;Note: n is the number of distinct elements in the multiset.&#xA;Implementation Performs like a... size() count(E) add(E, int) remove(E, int) setCount(E, int) Iterate through entrySet() or elementSet() HashMultiset HashMap&lt;E, Integer> O(1) O(1) O(1) O(1) O(1) O(max n) * LinkedHashMultiset LinkedHashMap&lt;E, Integer> O(1) O(1) O(1) O(1) O(1) O(n) TreeMultiset TreeMap&lt;E, Integer> O(1) ** O(log n) O(log n) O(log n) O(log n) O(n) ConcurrentHashMultiset ConcurrentHashMap&lt;E, AtomicInteger> O(n) O(1) O(1) O(1) O(1) O(n) ImmutableMultiset ImmutableMap&lt;E, Integer> O(1) O(1) O(1) O(1) O(1) O(n) ImmutableSortedMultiset ImmutableSortedMap&lt;E, Integer> O(1) O(log n) O(log n) O(log n) O(log n) O(n)&#xA;&#xA;* Like HashMap, the iteration cost through the entrySet is linear in the maximum number of elements the HashMultiset has ever had, not the number it has now.&#xA;** TreeMultiset.subMultiset().size() takes time O(log n).&#xA;Multimap&#xA;k is the number of distinct keys; n is the number of distinct entries; #(key) is the number of entries associated with key. Where not specified, the asymptotics are equivalent to the &quot;obvious&quot; implementation based on the &quot;Performs like a...&quot; column.&#xA;Implementation Performs like a... size() get(K) put(K, V) containsEntry(K, V) Iterate through entries() Iterate through asMap().entrySet() ArrayListMultimap HashMap&lt;K, ArrayList&lt;V>> O(1) O(1) O(1) O(#(key)) O(max k + n) O(max k) LinkedListMultimap LinkedHashMap&lt;K, LinkedList&lt;V>> O(1) O(1) O(1) O(#(key)) O(n) O(k) HashMultimap HashMap&lt;K, HashSet&lt;V>> O(1) O(1) O(1) O(1) O(max n) O(max k) LinkedHashMultimap LinkedHashMap&lt;K, LinkedHashSet&lt;V>> O(1) O(1) O(1) O(1) O(n) O(k) TreeMultimap TreeMap&lt;K, TreeSet&lt;V>> O(1) O(log k) O(log k + log #(key)) O(log k + log #(key)) O(n) O(k) ImmutableListMultimap ImmutableMap&lt;K, ImmutableList&lt;V>> O(1) O(1) N/A O(#(key)) O(n) O(k) ImmutableSetMultimap ImmutableMap&lt;K, ImmutableSet&lt;V>> O(1) O(1) N/A O(1) O(n) O(k)&#xA; owner: wasserman.louis&#xA; last update: Jun 22, 2012"/>
  </wiki>
  <users login="dborowitz@google.com"/>
  <users login="rob.maxw...@gmail.com"/>
  <users login="jens.neh...@gmail.com"/>
  <users login="qi.c...@ocado.com"/>
  <users login="kofem...@gmail.com"/>
  <users login="wasserman.louis"/>
  <users login="thecoop1...@googlemail.com"/>
  <users login="kurt.kluever"/>
  <users login="cgdecker@google.com"/>
  <users login="fry@google.com"/>
  <users login="dharkn...@gmail.com"/>
  <users login="greg.mar...@elasticsearch.com"/>
  <users login="tomas.za...@gmail.com"/>
  <users login="gak@google.com"/>
  <users login="legrand....@gmail.com"/>
  <users login="jens.ran...@tink.se"/>
  <users login="stefan.l...@gmail.com"/>
  <users login="jroes...@gmail.com"/>
  <users login="andrew.m...@threewide.com"/>
  <users login="bedla.cz...@gmail.com"/>
  <users login="daniil.g...@gmail.com"/>
  <users login="lu...@google.com"/>
  <users login="dpletc...@google.com"/>
  <users login="cl...@magicalspirits.net"/>
  <users login="tavianator@gmail.com"/>
  <users login="christia...@gmail.com"/>
  <users login="bardur.a...@gmail.com"/>
  <users login="paolo.fu...@gmail.com"/>
  <users login="archie.c...@gmail.com"/>
  <users login="cgruber@google.com"/>
  <users login="sebastia...@gmail.com"/>
  <users login="venkates...@gmail.com"/>
  <users login="b...@cwconsult.dk"/>
  <users login="j...@nwsnet.de"/>
  <users login="adam.h...@gmail.com"/>
  <users login="anderson...@gmail.com"/>
  <users login="fabian.z...@gmail.com"/>
  <users login="crai...@microsoft.com"/>
  <users login="arg...@gmail.com"/>
  <users login="luke.ush...@gmail.com"/>
  <users login="be...@google.com"/>
  <users login="smrtprj...@gmail.com"/>
  <users login="cbe...@google.com"/>
  <users login="tadam...@gmail.com"/>
  <users login="heue...@gmail.com"/>
  <users login="kevinb@google.com"/>
  <users login="phwend...@gmail.com"/>
  <users login="cpov...@google.com"/>
  <users login="cgdec...@gmail.com"/>
  <users login="ogregoire"/>
  <users login="consiliu...@gmail.com"/>
  <users login="Maaarti...@gmail.com"/>
  <users login="henn...@schmiedehausen.org"/>
  <users login="cristian...@gmail.com"/>
  <users login="ozzy...@gmail.com"/>
  <users login="lowas...@google.com"/>
  <users login="SeanPFl...@googlemail.com"/>
  <users login="hillge...@gmail.com"/>
  <users login="cairomas...@gmail.com"/>
  <users login="jbj...@gmail.com"/>
  <users login="----"/>
  <users login="kak@google.com"/>
  <users login="NatalyaD...@gmail.com"/>
  <users login="leventov...@gmail.com"/>
</atlanmod.github.org:Repository>
