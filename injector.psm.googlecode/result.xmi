<?xml version="1.0" encoding="ASCII"?>
<gc:GoogleCodeProject xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:gc="http://atlanmod/googlecode" name="guava-libraries" license="Apache License 2.0" labels="//@projectLabels.9 //@projectLabels.3 //@projectLabels.6 //@projectLabels.2 //@projectLabels.5 //@projectLabels.7 //@projectLabels.10 //@projectLabels.4 //@projectLabels.8 //@projectLabels.1 //@projectLabels.0" members="//@users.5 //@users.8 //@users.7 //@users.6 //@users.10 //@users.0 //@users.11 //@users.4 //@users.2 //@users.9" description="The Guava project contains several of Google's core libraries that we rely on in our Java-based projects: collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, and so forth.&#xA;The latest release is 18.0, released August 25, 2014.&#xA;Start using Guava&#xA;You can download a JAR at:&#xA;guava-18.0.jar guava-gwt-18.0.jar (for GWT users)&#xA;Guava is also available in Maven Central under the following identifiers:&#xA;com.google.guava:guava com.google.guava:guava-gwt (for GWT users)&#xA;Learn more about how to UseGuavaInYourBuild.&#xA;Please see the 18.0 release notes for more details about this release.&#xA;Learn about Guava&#xA;Our users' guide, GuavaExplained Browse API docs for the most recent release Browse API diffs for the most recent release Presentation slides focusing on base, primitives, and io Presentation slides focusing on cache Presentation slides focusing on util.concurrent A nice collection of other helpful links&#xA;How to communicate with us (and each other)&#xA;To stay informed and get &quot;tip of the week&quot;-style posts, follow +Google Guava on Google+.&#xA;To just stay informed, period, about important news that every Guava user needs to know, subscribe to guava-announce. It is very low-traffic.&#xA;To report a defect or request a feature, click the Issues tab above and enter a new issue.&#xA;To get help on a specific question or problem, post a question to Stack Overflow with the tag &quot;guava&quot;. We monitor these questions using this RSS feed.)&#xA;Keep an eye on project updates using any of these Project Feeds. (The &quot;Updates&quot; feed is an aggregation of all the others.) You can view our code changes as they happen, and comment on them using the code-review tool.&#xA;We have a read-only mailing list consisting of email notifications of issue tracker activity, which can be easier to follow in a threaded manner than the project feed.&#xA;For general discussion that doesn't fit neatly into any of these categories, join our discussion group guava-discuss.&#xA;Important Warnings&#xA;Guava contains a strictly compatible superset of the old, deprecated Google Collections Library. You should not use that library anymore.&#xA;APIs marked with the @Beta annotation at the class or method level are subject to change. They can be modified in any way, or even removed, in any major release. If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your own control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard). Here is a current list of all the beta APIs.&#xA;Serialized forms of ALL objects are subject to change. Do not persist these and assume they can be read by a future version of the library.&#xA;Deprecated non-beta APIs will be removed eighteen months after the release in which they are first deprecated. You must fix your usages before this time. If you don't, any manner of breakage might result (you are not guaranteed a compilation error)." summary="Guava: Google Core Libraries for Java 1.6+">
  <issueTracker url="https://code.google.com/p/guava-libraries/issues">
    <issues id="1871" date="Today (13 hours ago)" summary="AbstractLoadingCache missing get(Object, Callable)" description="&#xA;AbstractLoadingCache says:&#xA;&quot;To implement a cache, the programmer needs only to extend this class and provide an implementation for the #get(Object) and #getIfPresent methods. #getUnchecked, #get(Object, Callable), and #getAll are implemented in terms of get&quot;&#xA;&#xA;But this is simply not true; get(Object, Callable) is not defined in AbstractLoadingCache, and in AbstractCache it throws UnsupportedOperationException.&#xA;" reporter="//@users.1" status="New" owner="//@users.3" stars="1"/>
  </issueTracker>
  <wiki>
    <pages name="ServiceExplained" content="Overview&#xA;The Guava Service interface represents an object with an operational state, with methods to start and stop. For example, webservers, RPC servers, and timers can implement the Service interface. Managing the state of services like these, which require proper startup and shutdown management, can be nontrivial, especially if multiple threads or scheduling is involved. Guava provides some skeletons to manage the state logic and synchronization details for you.&#xA;Using a Service&#xA;The normal lifecycle of a Service is&#xA;Service.State.NEW to Service.State.STARTING to Service.State.RUNNING to Service.State.STOPPING to Service.State.TERMINATED&#xA;A stopped service may not be restarted. If the service fails where starting, running, or stopping, it goes into state Service.State.FAILED.&#xA;A service can be started asynchronously using startAsync(), which returns this to enable method chaining. It is only valid to call startAsync() if the service is NEW. So you should structure your application to have a unique place where each service is started.&#xA;Stopping the service is analogous, using the asynchronous stopAsync() method. But unlike startAsync(), it is safe to call this method multiple times. This is to make it possible to handle races that may occur when shutting down services.&#xA;Service also provides several methods to wait for service transitions to complete.&#xA;asynchronously using addListener(). addListener() allows you to add a Service.Listener that will be invoked on every state transition of the service. N.B. if a service is not NEW when the listener is added, then any state transitions that have already occurred will not be replayed on the listener. synchronously using awaitRunning(). This is uninterruptible, throws no checked exceptions, and returns once the service has finished starting. If the service fails to start, this throws an IllegalStateException. Similarly, awaitTerminated() waits for the service to reach a terminal state (TERMINATED or FAILED). Both methods also have overloads that allow timeouts to be specified.&#xA;&#xA;The Service interface is subtle and complicated. We do not recommend implementing it directly. Instead please use one of the abstract base classes in guava as the base for your implementation. Each base class supports a specific threading model.&#xA;Implementations&#xA;AbstractIdleService&#xA;The AbstractIdleService skeleton implements a Service which does not need to perform any action while in the &quot;running&quot; state -- and therefore does not need a thread while running -- but has startup and shutdown actions to perform. Implementing such a service is as easy as extending AbstractIdleService and implementing the startUp() and shutDown() methods.&#xA;protected void startUp() {&#xA;  servlets.add(new GcStatsServlet());&#xA;}&#xA;protected void shutDown() {}&#xA;Note that any queries to the GcStatsServlet already have a thread to run in. We don't need this service to perform any operations on its own while the service is running.&#xA;AbstractExecutionThreadService&#xA;An AbstractExecutionThreadService performs startup, running, and shutdown actions in a single thread. You must override the run() method, and it must respond to stop requests. For example, you might perform actions in a work loop:&#xA;public void run() {&#xA;  while (isRunning()) {&#xA;    // perform a unit of work&#xA;  }&#xA;}&#xA;Alternately, you may override triggerShutdown() in any way that causes run() to return.&#xA;Overriding startUp() and shutDown() is optional, but the service state will be managed for you.&#xA;protected void startUp() {&#xA;  dispatcher.listenForConnections(port, queue);&#xA;}&#xA;protected void run() {&#xA;  Connection connection;&#xA;  while ((connection = queue.take() != POISON)) {&#xA;    process(connection);&#xA;  }&#xA;}&#xA;protected void triggerShutdown() {&#xA;  dispatcher.stopListeningForConnections(queue);&#xA;  queue.put(POISON);&#xA;}&#xA;Note that start() calls your startUp() method, creates a thread for you, and invokes run() in that thread. stop() calls triggerShutdown() and waits for the thread to die.&#xA;AbstractScheduledService&#xA;An AbstractScheduledService performs some periodic task while running. Subclasses implement runOneIteration() to specify one iteration of the task, as well as the familiar startUp and shutDown() methods.&#xA;To describe the execution schedule, you must implement the scheduler() method. Typically, you will use one of the provided schedules from AbstractScheduledService.Scheduler, either newFixedRateSchedule(initialDelay, delay, TimeUnit) or newFixedDelaySchedule(initialDelay, delay, TimeUnit), corresponding to the familiar methods in ScheduledExecutorService. Custom schedules can be implemented using CustomScheduler; see the Javadoc for details.&#xA;AbstractService&#xA;When you need to do your own manual thread management, override AbstractService directly. Typically, you should be well served by one of the above implementations, but implementing AbstractService is recommended when, for example, you are modeling something that provides its own threading semantics as a Service, you have your own specific threading requirements.&#xA;To implement AbstractService you must implement 2 methods.&#xA;doStart(): doStart() is called directly by the first call to startAsync(), your doStart() method should perform all initialization and then eventually call notifyStarted() if start up succeeded or notifyFailed() if start up failed. doStop(): doStop() is called directly by the first call to stopAsync(), your doStop() method should shut down your service and then eventually call notifyStopped() if shutdown succeeded or notifyFailed() if shutdown failed.&#xA;&#xA;Your doStart and doStop, methods should be fast. If you need to do expensive initialization, such as reading files, opening network connections, or any operation that might block, you should consider moving that work to another thread.&#xA;Using ServiceManager&#xA;In addition to the Service skeleton implementations, Guava provides a ServiceManager class that makes certain operations involving multiple Service implementations easier. Create a new ServiceManager with a collection of Services. Then you can manage them:&#xA;startAsync() will start all the services under management. Much like Service#startAsync() you can only call this method once, if all services are NEW. stopAsync() will stop all the services under management. addListener will add a ServiceManager.Listener that will be called on major state transitions. awaitHealthy() will wait for all services to reach the RUNNING state. awaitStopped() will wait for all services to reach a terminal state.&#xA;Or inspect them:&#xA;isHealthy() returns true if all services are RUNNING. servicesByState() returns a consistent snapshot of all the services indexed by their state. startupTimes() returns a map from Service under management to how long it took for that service to start in milliseconds. The returned map is guaranteed to be ordered by startup time.&#xA;&#xA;While it is recommended that service lifecycles be managed via ServiceManager, state transitions initiated via other mechanisms do not impact the correctness of its methods. For example, if the services are started by some mechanism besides startAsync(), the listeners will be invoked when appropriate and awaitHealthy() will still work as expected. The only requirement that ServiceManager enforces is that all Services must be NEW when `ServiceManager is constructed." owner="//@users.4" labels="//@wikiLabels.0" updated_at="Aug 26, 2014" summary="The Guava Service abstraction, explained."/>
  </wiki>
  <projectLabels name="eventbus"/>
  <projectLabels name="Helpers"/>
  <projectLabels name="Collections"/>
  <projectLabels name="Libraries"/>
  <projectLabels name="IO"/>
  <projectLabels name="Caching"/>
  <projectLabels name="Google"/>
  <projectLabels name="Concurrency"/>
  <projectLabels name="Utilities"/>
  <projectLabels name="Java"/>
  <projectLabels name="Primitives"/>
  <wikiLabels name="explained"/>
  <users email="gak@google.com" id="gak@google.com"/>
  <users email="dborowitz@google.com" id="dborowitz@google.com"/>
  <users email="cgruber@google.com" id="cgruber@google.com"/>
  <users email="----" id="----"/>
  <users email="cgdecker@google.com" id="cgdecker@google.com"/>
  <users email="kevinb@google.com" id="kevinb@google.com"/>
  <users email="kak@google.com" id="kak@google.com"/>
  <users email="fry@google.com" id="fry@google.com"/>
  <users email="cpov...@google.com" id="cpov...@google.com"/>
  <users email="lowas...@google.com" id="lowas...@google.com"/>
  <users email="wasserman.louis" id="wasserman.louis"/>
  <users email="kurt.kluever" id="kurt.kluever"/>
</gc:GoogleCodeProject>
