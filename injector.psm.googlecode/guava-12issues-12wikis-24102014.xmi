<?xml version="1.0" encoding="ASCII"?>
<gc:GoogleCodeProject xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:gc="http://atlanmod/googlecode" name="guava-libraries" license="Apache License 2.0">
  <issueTracker url="https://code.google.com/p/guava-libraries/issues">
    <issues id="1859" date="Sep 30, 2014" summary="Guava testlib doesn't test support of equal, but not identical (==) map/set keys at all" description="&#xA;Which is a very important case.&#xA;" reporter="//@users.19" status="Accepted" owner="//@users.12" labels="//@issueLabels.1 //@issueLabels.6" stars="2">
      <comments text="&#xA;Oh, in the test-suite builders? I had never thought about that. We should do something about it.&#xA;" date="Sep 30, 2014" owner="//@users.17"/>
      <comments text="&#xA;The thing is everywhere in the framework we just use the given SimpleElements, same object for each &quot;equivalence class&quot; all the time. We don't try to, say, put a value for one key object, and get the value back querying equal, but not identical key.&#xA;" date="Sep 30, 2014" owner="//@users.19"/>
      <comments text="&#xA;*SampleElements&#xA;" date="Sep 30, 2014" owner="//@users.19"/>
    </issues>
    <issues id="1868" date="Oct 20 (3 days ago)" summary="Document that Predicates.in uses the contains() method of the collection" description="&#xA;Hi,&#xA;There seems to be a performance bug in the &quot;in&quot; method from the Predicates class.&#xA;&#xA;The problem is that we can generate an In Predicate that has an underlying collection with a slow containment implementation, for example an ArrayList.&#xA;&#xA;The following code exposes the problem:&#xA;&#xA;_________________________________________&#xA;public static void testPredicateIn() {&#xA;&#xA;        ArrayList&lt;Integer> predicateCollection=new ArrayList&lt;Integer>();&#xA;&#xA;        for(int i=0;i&lt;500000;++i)&#xA;            predicateCollection.add(new Integer(i));&#xA;                                                          &#xA;        Predicate&lt;Integer> inPred=Predicates.in(predicateCollection);&#xA;&#xA;        for(int i=0;i&lt;500000;++i) {&#xA;            inPred.apply(new Integer(i));&#xA;        }&#xA;&#xA;    }&#xA;&#xA;__________________________________________-&#xA;Notice that we're creating an in Predicate over an ArrayList of 500000 integers. &#xA;Applying that predicate to the integers between 1 and 500000 takes a few minutes.&#xA;&#xA;I could think of a couple of ways of fixing it:&#xA;&#xA;1) Put a disclaimer in the documentation that the user is advised to pass collections with fast containment methods.&#xA;&#xA;2) Convert slow collections into HashSets, as in the following snippet:&#xA;_______________________________________________________&#xA;    private static &lt;T> Predicate&lt;T> optimizedIn(Collection&lt;? extends T> target) {&#xA;&#xA;        if(target instanceof Set)&#xA;            return Predicates.in(target);&#xA;        else&#xA;            return Predicates.in(new HashSet&lt;T>(target));&#xA;&#xA;    }&#xA;____________________________________________________&#xA;&#xA;&#xA;Here are some experimental results with different sizes for the collection predicate for the original implementation and optimizedIn:&#xA;&#xA;&#xA;      Size      Original     Optimized                                                                                                       &#xA;        10      0m0.972s     0m0.996s                                                                                                        &#xA;       100      0m1.068s     0m1.004s                                                                                                        &#xA;      1000      0m1.572s     0m0.980s                                                                                                        &#xA;     10000      0m8.065s     0m1.016s                                                                                                        &#xA;    100000      1m5.596s     0m1.052s                                                                                                        &#xA;    500000      4m56.423s    0m1.200s               &#xA;&#xA;&#xA;Regards,&#xA; Oswaldo.&#xA;" reporter="//@users.3" status="New" owner="//@users.12" labels="//@issueLabels.7 //@issueLabels.5" stars="1">
      <comments text="&#xA;Actually, I posted the root cause, rather than an actual performance bug in the library code.&#xA;&#xA;Here's a less artificial example, where creating Filtered Collections exposes the performance issue in the slow predicate:&#xA;&#xA;______________________________________________&#xA; public static void testCollections2Filter() {&#xA;&#xA;        ArrayList&lt;Integer> filterCollection=new ArrayList&lt;Integer>();&#xA;        ArrayList&lt;Integer> toAddCollection=new ArrayList&lt;Integer>();&#xA;        for(int i=0;i&lt;500000;++i) {&#xA;            filterCollection.add(new Integer(i));&#xA;            toAddCollection.add(new Integer(i));&#xA;        }&#xA;&#xA;        //      Predicate&lt;Integer> inPred=optimizedIn(filterCollection);                                                                        &#xA;             Predicate&lt;Integer> inPred=Predicates.in(filterCollection);&#xA;&#xA;            Collection&lt;Integer> filteredCollection=Collections2.filter(new ArrayList&lt;Integer>(),inPred);&#xA;&#xA;                filteredCollection.addAll(toAddCollection);&#xA;&#xA;    }&#xA;_______________&#xA;&#xA;Here are the results I'm getting with the original and optimized versions of the &quot;in&quot; predicate:&#xA;&#xA; // Size    Original  Optimized                                                                                                              &#xA;&#xA;       Size  Original  Optimized&#xA;         10  0m1.124s  0m1.096s                                                                                                               &#xA;        100  0m1.112s  0m1.088s                                                                                                               &#xA;       1000  0m1.164s  0m1.152s                                                                                                               &#xA;      10000  0m1.216s  0m1.160s                                                                                                               &#xA;     100000  0m9.421s  0m1.228s                                                                                                               &#xA;     200000  0m50.611s 0m1.252s                                                                                                               &#xA;     500000  > 10 min  0m1.324s    &#xA;&#xA;&#xA;Regards,&#xA; Oswaldo.&#xA;" date="Oct 21 (2 days ago)" owner="//@users.3"/>
      <comments text="&#xA;There's a couple points here:&#xA;&#xA;  - The documentation of Predicates.in specifies, &quot;It does not defensively copy the collection passed in, so future changes to it will alter the behavior of the predicate.&quot;  That's a non-@Beta method contract that we would almost certainly not change, and there's not really any way to satisfy that contract and do anything like what you're proposing.&#xA;  - We could document better than the collection's own contains() method is used, and that the performance of the predicate will be equivalent to the performance of the collection's contains() method.&#xA;  - For very short lists, it is not always the case that converting to a HashSet will help performance.&#xA;  - It's possible that it might make sense as a warning or an error in error-prone (http://errorprone.info/) to pass a List to Predicates.in, but we'd have to investigate this -- and that'd be more appropriate as a bug filed against error-prone, rather than Guava.&#xA;" date="Oct 21 (2 days ago)" owner="//@users.4"/>
    </issues>
    <issues id="1858" date="Sep 28, 2014" summary="Converter - FindBugs problem" description="&#xA;FindBugs reports &quot;inherits equals and uses Object.hashCode()&quot; for Converter-subclasses.&#xA;&#xA;http://findbugs.sourceforge.net/bugDescriptions.html#HE_INHERITS_EQUALS_USE_HASHCODE&#xA;&#xA;@ test/Test.java @&#xA;&#xA;package test;&#xA;&#xA;import com.google.common.base.Converter;&#xA;&#xA;import java.io.Serializable;&#xA;&#xA;public final class Test {&#xA;&#xA;  private static final class TestConverter&#xA;      extends Converter&lt;String, String> implements Serializable {&#xA;&#xA;    /*package*/ static final TestConverter INSTANCE = new TestConverter();&#xA;&#xA;    private static final long serialVersionUID = 1;&#xA;&#xA;    @Override&#xA;    public String toString() {&#xA;      return &quot;TestConverter.testConverter()&quot;;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected String doForward(String string) {&#xA;      return string;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected String doBackward(String string) {&#xA;      return string;&#xA;    }&#xA;&#xA;    private Object readResolve() {&#xA;      return INSTANCE;&#xA;    }&#xA;  }&#xA;&#xA;  public static Converter&lt;String, String> testConverter() {&#xA;    return TestConverter.INSTANCE;&#xA;  }&#xA;&#xA;  private Test() {&#xA;  }&#xA;}&#xA;&#xA;@ pom.xml @&#xA;&#xA;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#xA;&#x9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;>&#xA;&#x9;&lt;modelVersion>4.0.0&lt;/modelVersion>&#xA;&#x9;&lt;groupId>test&lt;/groupId>&#xA;&#x9;&lt;artifactId>test&lt;/artifactId>&#xA;&#x9;&lt;version>1.0.0-SNAPSHOT&lt;/version>&#xA;&#x9;&lt;dependencies>&#xA;&#x9;&#x9;&lt;dependency>&#xA;&#x9;&#x9;&#x9;&lt;groupId>com.google.guava&lt;/groupId>&#xA;&#x9;&#x9;&#x9;&lt;artifactId>guava&lt;/artifactId>&#xA;&#x9;&#x9;&#x9;&lt;version>18.0&lt;/version>&#xA;&#x9;&#x9;&lt;/dependency>&#xA;&#x9;&lt;/dependencies>&#xA;&#x9;&lt;build>&#xA;&#x9;&#x9;&lt;plugins>&#xA;&#x9;&#x9;&#x9;&lt;plugin>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;groupId>org.codehaus.mojo&lt;/groupId>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;artifactId>findbugs-maven-plugin&lt;/artifactId>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;version>3.0.0&lt;/version>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;executions>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;execution>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;goals>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;goal>check&lt;/goal>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/goals>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/execution>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;/executions>&#xA;&#x9;&#x9;&#x9;&lt;/plugin>&#xA;&#x9;&#x9;&lt;/plugins>&#xA;&#x9;&lt;/build>&#xA;&lt;/project>&#xA;&#xA;@@&#xA;&#xA;mvn clean install&#xA;&#xA;...&#xA;[INFO] --- findbugs-maven-plugin:3.0.0:check (default) @ test ---&#xA;[INFO] BugInstance size is 1&#xA;[INFO] Error size is 0&#xA;[INFO] Total bugs: 1&#xA;[INFO] test.Test$TestConverter inherits equals and uses Object.hashCode() [&quot;test.Test$TestConverter&quot;] At Test.java:[lines 9-32]&#xA;[INFO] ------------------------------------------------------------------------&#xA;[INFO] BUILD FAILURE&#xA;[INFO] ------------------------------------------------------------------------&#xA;[INFO] Total time: 6.516 s&#xA;[INFO] Finished at: 2014-09-29T00:00:54+01:00&#xA;[INFO] Final Memory: 23M/118M&#xA;[INFO] ------------------------------------------------------------------------&#xA;[ERROR] Failed to execute goal org.codehaus.mojo:findbugs-maven-plugin:3.0.0:check (default) on project test: failed with 1 bugs and 0 errors -> [Help 1]&#xA;...&#xA;&#xA;@@&#xA;&#xA;The &quot;problem&quot; is the override in Converter:&#xA;&#xA;  @Override&#xA;  public boolean equals(@Nullable Object object) {&#xA;    return super.equals(object);&#xA;  }&#xA;&#xA;But there is no corresponding override for hashCode:&#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    return super.hashCode();&#xA;  }&#xA;&#xA;This forces everyone to either ignore the FindBugs warning or include the snippet above in their subclass.&#xA;&#xA;Please add &#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    return super.hashCode();&#xA;  }&#xA;&#xA;to Converter, thanks.&#xA;" reporter="//@users.10" status="New" owner="//@users.12" labels="//@issueLabels.7 //@issueLabels.5" stars="2">
      <comments text="&#xA;To be clear, this is actually a false positive from FindBugs (since there isn't actually a bug here).&#xA;&#xA;Looks like we only override equals so we can add additional documentation. I wonder if we should just move that documentation into the class docs, or drop it all together.&#xA;" date="Sep 28, 2014" owner="//@users.16"/>
    </issues>
    <issues id="1867" date="Oct 20 (3 days ago)" summary="Adding a new value to a map if absent however lazily" description="&#xA;Need a putIfAbsent type method which takes a Builder rather than a created object as value along with Key K.&#xA;This in specific tries to create the object iff the key is absent.&#xA;&#xA;Advantage: The value doesn't get un-necessarily created.&#xA;" reporter="//@users.15" status="New" owner="//@users.12" stars="1">
      <comments text="&#xA;Java 8 provides this as a new default method on Map, but I imagine this would be unnecessarily complicated before Java 8, if you had to write the anonymous Supplier instance -- it'd probably take more lines than just writing it the old-fashioned way.&#xA;" date="Oct 20 (3 days ago)" owner="//@users.6"/>
      <comments text="&#xA;Given that migrating to Java 8 takes significant amount of time ; i was hoping if it were to be implemented in guava&#xA;" date="Oct 20 (3 days ago)" owner="//@users.15"/>
      <comments text="&#xA;As I was attempting to say, Guava could only really do this by letting you use an anonymous class, since you can't use lambdas until Java 8, and the anonymous class would be so verbose that your code would be shorter if you wrote it the &quot;normal way.&quot;&#xA;" date="Oct 20 (3 days ago)" owner="//@users.4"/>
      <comments text="&#xA;OK got it. thanks for clarification&#xA;" date="Oct 20 (3 days ago)" owner="//@users.15"/>
    </issues>
    <issues id="1856" date="Sep 24, 2014" summary="&quot;Throttle&quot; for slowing down rapidly submitted Runnables" description="&#xA;From the mailing-list:&#xA;&#xA;Especially in GUI-applications I often find myself in the need for a throttle which executes a Runnable only after a certain time has passed and only the last Runnable that has been scheduled.&#xA;&#xA;Example: In SWT, when the user resizes a window or a table-column I store that information.&#xA;SWT has a Listener for the resize-event which fires basically for every pixel that is moved, so one resize fires potentially hundreds of events, saving that every time would be slow and I'm only interested in the last value anyway.&#xA;&#xA;I implemented an Executor [0] that can give me an instance of Throttle [1] with a specified timeout..&#xA;&#xA;When a Runnable is submitted to/via the Throttle it is only executed after the timeout has passed. Within this time, every newly submitted Runnable replaces the one waiting.&#xA;&#xA;[0] https://github.com/fab1an/appkit/blob/master/src/main/java/org/appkit/concurrent/SmartExecutor.java&#xA;[1] https://fab1an.github.io/appkit/javadoc/org/appkit/concurrent/Throttle.html&#xA;&#xA;&#xA;" reporter="//@users.0" status="New" owner="//@users.12" stars="2"/>
    <issues id="1862" date="Oct 10, 2014" summary="Order of enqueued events" description="&#xA;The post order of enqueued events is not guaranteed. In practice the order of enqueued events is the same for the majority of the time but not always. In my case, each start of my application could have a different order of posted events. This makes testing and bugfixing a lot harder.&#xA;Changing the subscribersByType from HashMultimap to LinkedHashMultimap in the EventBus class fixed it for me.&#xA;" reporter="//@users.9" status="New" owner="//@users.12" stars="2"/>
    <issues id="1855" date="Sep 23, 2014" summary="Immutable collections do not guard against wrong Collection.toArray() method" description="&#xA;ImmutableList etc. can be changed after construction if a collection is passed to copyOf() that keeps a reference to the array returned by toArray(). If the resulting array is of correct size and has more than one element, it is directly used as the backing array of the immutable collection. I attached a file that shows this. The same happens in other places as well, for example in Ordering.immutableSortedCopy().&#xA;&#xA;Such a collection violates the contract of Collection.toArray() which explicitly mentions that the collection may not retain a reference to the array. The only way I could imagine this to happen accidentally might be someone who needs to convert a lot of data back and forth between a List and an array, and implements something like Arrays.asList() but returning the internal array directly in toArray(). Another possibility would be some third-party code that maliciously tries to mangle with internal data structures.&#xA;&#xA;The fix for this would be to do a second copy in these cases, which would probably be a major performance decrease for many users. In our project we do not need this additional protection as we do not have untrusted code, and would certainly prefer the speed of the current solution instead. I guess this is true for a vast majority of users.&#xA;&#xA;A variant of this fix would be to whitelist collections from the java.* and com.google.* packages which are known to be well-behaved in this regard, and do a second copy only for other collections. This would be quite ugly and still costs performance for all users that pass in their own collections.&#xA;&#xA;Thus I suggest to keep the current behavior, and instead document this.&#xA;Currently the wiki states that Guavas immutable collection are &quot;Safe for use by untrusted libraries&quot;, which I would interpret for example such that it is safe to take an immutable collection returned by some untrusted library and use it directly.&#xA;This is not true, regardless of whether the library directly returns an immutable collection, or whether it returns an arbitrary collection and my code calls copyOf().&#xA;Instead, users retrieving collections from untrusted sources and copying them into an immutable collection need to do a second copy themselves with ImmutableList.copyOf(collection.toArray(new T[0])). (Using toArray() would lose the element type, copying into a List would require yet another copy, and using copyOf(copyOf()) of course does not work because the second call does not copy again.)&#xA;" reporter="//@users.14" status="New" owner="//@users.12" labels="//@issueLabels.3 //@issueLabels.7" stars="3">
      <comments text="(No comment was entered for this change.)&#xA;" date="Sep 24, 2014" owner="//@users.16"/>
      <comments text="&#xA;One thing that could be done is&#xA;&#xA;    Object[] array = new Object[elements.size()];&#xA;    checkState(array == elements.toArray(array));&#xA;    return construct(array);&#xA;&#xA;instead of&#xA;&#xA;    return construct(elements.toArray());&#xA;&#xA;I'm not really sure it's worth it just to handle invalid Collection implementations though.&#xA;" date="Sep 24, 2014" owner="//@users.7"/>
      <comments text="&#xA;Calling toArray(array) will help with unintentional bugs. It's worth consideration, though I wonder if it has performance disadvantages for some collections.&#xA;&#xA;The problem of malicious implementations is one that we've intentionally decided not to tackle. We do need to fix our docs.&#xA;" date="Sep 24, 2014" owner="//@users.17"/>
      <comments text="&#xA;I believe the sense in which the wiki page meant things was that it was safe to *pass* ImmutableCollections to untrusted libraries, though there obviously isn't anything we can do about reflection.&#xA;" date="Sep 24, 2014" owner="//@users.4"/>
      <comments text="&#xA;Passing an own array would not help against malicious implementations as they could grab the array anyway. Concerning contracts, it's even worse as I can't see anything like &quot;no references to it are maintained by this collection&quot; in the javadoc of `Collection.toArray(T[])`, though it's somehow obvious.&#xA;" date="Sep 24, 2014" owner="//@users.2"/>
      <comments text="&#xA;Maaartinus, what do you mean?  The Collection.toArray Javadoc states:&#xA;> The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.&#xA;" date="Sep 24, 2014" owner="//@users.6"/>
      <comments text="&#xA;I mean the proposal from comment #2 to use *the other* toArray method which gives no such guarantee. Doing something like&#xA;&#xA;&lt;T> T[] toArray(T[] a) {&#xA;    this.gotcha = super.toArray();&#xA;    return this.gotcha;&#xA;}&#xA;&#xA;would violate common sense, but no explicitly stated contract.&#xA;" date="Sep 24, 2014" owner="//@users.2"/>
    </issues>
    <issues id="1864" date="Oct 10, 2014" summary="Should toStringHelper(Class|Object) use simple name or canonical name (or either)?" description="&#xA;For some nested classes you would really rather toStringHelper chose the canonical name &quot;Foo.Bar&quot; instead of just the simple name &quot;Bar&quot;.&#xA;&#xA;Questions:&#xA;&#xA;1. Which is the best default behavior?&#xA;&#xA;2. If that is the canonical name, would it be evil to change it now? It is perhaps debatable whether the current behavior really is strongly promised by spec. Some overenthusiastic unit tests would have to be changed, but how bad is that?&#xA;&#xA;3. Does this choice actually merit a new configuration option to ToStringHelper? Note that without it, users who want the opposite behavior will need to change typical (85%) usage code like so:&#xA;&#xA; toStringHelper(this) --> toStringHelper(getClass().getCanonicalName())&#xA;&#xA;... which is not pleasant. However, we don't want ToStringHelper to become too complex.&#xA;" reporter="//@users.13" status="Research" owner="//@users.12" labels="//@issueLabels.4 //@issueLabels.5" stars="2">
      <comments text="&#xA;Possibly we should apply our decision here equally to AutoValue. (AutoValue currently appears to use &quot;Bar.&quot;)&#xA;" date="Oct 14, 2014" owner="//@users.17"/>
    </issues>
    <issues id="1863" date="Oct 10, 2014" summary="Preventing thread starvation in blocking operations" description="&#xA;I've sub-classed ListenableFuture to wrap helper functions from the Futures class to make the futures slightly more composable, however, the issue I'm now facing is preventing potential thread starvation in a fixed worker thread pool (Executors.GLOBAL) in the example below due to someone accidentally blocking in a Function or AsyncFunction (thus potentially blocking all threads in this pool). &#xA;&#xA;Scala's Await.result uses &quot;managed blocking&quot;. i.e., detect the blocking operation and temporarily spawn a new thread (see http://stackoverflow.com/a/13099594). Is there anything equivalent in Guava/Java? &#xA;&#xA;Is this the reason Futures.transform has the option to use the current thread? &#xA;&#xA;    &#xA;public &lt;ReturnType> MFuture&lt;ReturnType> flatMap(AsyncFunction&lt;InputType, ReturnType> fn){&#xA;        return new MFuture&lt;ReturnType>(Futures.transform(listenableFuture, fn, Executors.GLOBAL));&#xA;    }&#xA;&#xA;    public &lt;ReturnType> MFuture&lt;ReturnType> map(Function&lt;InputType, ReturnType> fn){&#xA;        return new MFuture&lt;ReturnType>(Futures.transform(listenableFuture, fn, Executors.GLOBAL));&#xA;    }&#xA;&#xA;" reporter="//@users.20" status="New" owner="//@users.12" labels="//@issueLabels.2 //@issueLabels.0" stars="2">
      <comments text="&#xA;I've solved this issue by changing from a FixedThreadPool to a CachedThreadPool, which is probably ok for my scenario, but looking for suggestions. &#xA;" date="Oct 10, 2014" owner="//@users.20"/>
      <comments text="&#xA;The Java support for managed blocking that I'm aware of is in the JDK's ForkJoinPool. I don't believe we have anything related in Guava.&#xA;&#xA;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html&#xA;&#xA;As for applying that to your situation, I'm a bit over my head. You might try StackOverflow.&#xA;" date="Oct 10, 2014" owner="//@users.17"/>
      <comments text="&#xA;Thanks, that's exactly what I was looking for. &#xA;" date="Oct 10, 2014" owner="//@users.20"/>
    </issues>
    <issues id="1871" date="Today (13 hours ago)" summary="AbstractLoadingCache missing get(Object, Callable)" description="&#xA;AbstractLoadingCache says:&#xA;&quot;To implement a cache, the programmer needs only to extend this class and provide an implementation for the #get(Object) and #getIfPresent methods. #getUnchecked, #get(Object, Callable), and #getAll are implemented in terms of get&quot;&#xA;&#xA;But this is simply not true; get(Object, Callable) is not defined in AbstractLoadingCache, and in AbstractCache it throws UnsupportedOperationException.&#xA;" reporter="//@users.1" status="New" owner="//@users.12" stars="1"/>
    <issues id="1865" date="Oct 17 (6 days ago)" summary="Clarify the meaning of &quot;success&quot; of a Future" description="&#xA;From an internal discussion:&#xA;&#xA;---&#xA;&#xA;Huh. I had assumed that &quot;success&quot; was the usual name for this, but I can't find it anywhere in the Future docs. The closest term used there is &quot;completed normally,&quot; used in contrast to &quot;an exception&quot; and &quot;cancellation&quot;: http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone-- But other parts of the doc seem to consider there to be only two cases, &quot;completed normally&quot; and &quot;cancelled,&quot; suggesting that &quot;an exception&quot; is a kind of &quot;completed normally.&quot;&#xA;&#xA;---&#xA;&#xA;The word &quot;success&quot; is used throughout http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html&#xA;&#xA;---&#xA;&#xA;It would be super-confusing for &quot;success&quot; to mean anything other than &quot;completed without throwing&quot;, so the meaning of &quot;success&quot; is relatively obvous.  But it would be better if docs like in FutureCallback replaced &#xA;&#xA;   * Invoked with the result of the {@code Future} computation when it is&#xA;   * successful.&#xA;&#xA;with&#xA;&#xA;   * Invoked with the result of the {@code Future} computation when it completes&#xA;   * normally.&#xA;&#xA;or even more pedantically&#xA;&#xA;   * Invoked with the result of the {@code Future} computation if and when it completes normally (that is, without throwing an exception).&#xA;&#xA;---&#xA;&#xA;I'm still conflicted about this, given that &quot;completed normally&quot; is slightly ambiguous. Perhaps we could define &quot;success&quot; in our package-info and link to that? But mostly I'm just having trouble prioritizing this above other issues.&#xA;" reporter="//@users.17" status="New" owner="//@users.12" labels="//@issueLabels.7 //@issueLabels.0" stars="1"/>
    <issues id="1870" date="Yesterday (24 hours ago)" summary="Maps.unmodifiableNavigableMap not covariant in V" description="&#xA;Maps.unmodifiableNavigableMap is declared as follows:&#xA;&#xA;&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, V> map);&#xA;&#xA;this could be changed to &#xA;&#xA;&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V> map);&#xA;&#xA;as there are no methods in NavigableMap that take a V as a method parameter. This would also be consistent with the declarations of Collections.unmodifiableSortedMap and ImmutableSortedMap.copyOfSorted.&#xA;" reporter="//@users.8" status="Accepted" owner="//@users.12" labels="//@issueLabels.3 //@issueLabels.8" stars="1">
      <comments text="&#xA;I believe you are correct. And this will probably be sufficiently safe to change. Thanks!&#xA;" date="Yesterday (18 hours ago)" owner="//@users.13"/>
    </issues>
  </issueTracker>
  <wiki>
    <pages name="Release17" content="Guava Release 17.0: Release Notes&#xA;Release 17.0 was released on April 22, 2014. Release 17.0-rc2 was released on April 10, 2014. Release 17.0-rc1 was released on April 8, 2014.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;Guava Guava (GWT) Guava (JDK5 Backport) Maven Identifier com.google.guava:guava:17.0 com.google.guava:guava-gwt:17.0 com.google.guava:guava-jdk5:17.0 Jar guava-17.0.jar guava-gwt-17.0.jar guava-jdk5-17.0.jar Javadoc guava-17.0-javadoc.jar guava-gwt-17.0-javadoc.jar guava-jdk5-17.0-javadoc.jar Sources guava-17.0-sources.jar guava-gwt-17.0-sources.jar guava-jdk5-17.0-sources.jar&#xA;&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;Issues resolved&#xA;8 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 16.0.&#xA;To build a combined report of the API changes between release 17.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions and changes&#xA;common.base&#xA;Verify and VerifyException&#xA;Converter.from(Function&lt;A, B>, Function&lt;B, A>)&#xA;common.cache&#xA;CacheLoader.asyncReloading(CacheLoader&lt;K, V>, Executor)&#xA;common.io&#xA;ByteStreams.newDataInput(ByteArrayInputStream)&#xA;ByteStreams.newDataOutput(ByteArrayOutputStream)&#xA;Closeables.closeQuietly(InputStream)&#xA;Closeables.closeQuietly(Reader)&#xA;common.net&#xA;HostAndPort.fromHost(String)&#xA;common.util.concurrent&#xA;Futures.inCompletionOrder(Iterable&lt;ListenableFuture&lt;T>>)&#xA;MoreExecutors.shutdownAndAwaitTermination(ExecutorService, long, TimeUnit)&#xA;Service (and subclasses) - deprecated methods removed.&#xA;A note on BloomFilter&#xA;Release 17 fixes an issue (1119) with the performance of very large BloomFilters. For most users, this fix should be completely transparent. BloomFilter objects serialized with a previous version of Guava will be deserializable by and work fine in Guava 17. However, BloomFilters created by Guava 17 will not be deserializable by previous versions of Guava. This should still only affect you if both of the following are true:&#xA;You are serializing BloomFilters and sending them from one server or process to another. You can't upgrade all your servers to Guava 17 at the same time.&#xA;In this case, a server that's been upgraded to 17 could send a BloomFilter to a server that hasn't, which will then fail to deserialize it.&#xA;For this release only, we're providing the ability to use a system property to work around this issue. If the system property com.google.common.hash.BloomFilter.useMitz32 is set to true (ignoring case), Guava will create BloomFilters that are compatible with previous versions of Guava rather than using the new strategy. So while you're rolling out Guava 17, you can set this system property to keep everything working. Once it's fully rolled out, you can remove the system property to start using the new strategy. Guava 18.0 will no longer recognize the system property and will always use the new strategy for newly created BloomFilters." owner="//@users.11" updated_at="Aug 25, 2014" summary="Release notes for Guava Release 17.0"/>
    <pages name="RangesExplained" content="TODO: lots more examples&#xA;Example&#xA;List&lt;Double> scores;&#xA;Iterable&lt;Double> belowMedianScores = Iterables.filter(scores, Range.lessThan(median));&#xA;...&#xA;Range&lt;Integer> validGrades = Range.closed(1, 12);&#xA;for(int grade : ContiguousSet.create(validGrades, DiscreteDomain.integers())) {&#xA;  ...&#xA;}&#xA;Introduction&#xA;A range, sometimes known as an interval, is a convex (informally, &quot;contiguous&quot; or &quot;unbroken&quot;) portion of a particular domain. Formally, convexity means that for any a &lt;= b &lt;= c, range.contains(a) &amp;&amp; range.contains(c) implies that range.contains(b).&#xA;Ranges may &quot;extend to infinity&quot; -- for example, the range &quot;x > 3&quot; contains arbitrarily large values -- or may be finitely constrained, for example &quot;2 &lt;= x &lt; 5&quot;. We will use the more compact notation, familiar to programmers with a math background:&#xA;(a..b) = {x | a &lt; x &lt; b} [a..b] = {x | a &lt;= x &lt;= b} [a..b) = {x | a &lt;= x &lt; b} (a..b] = {x | a &lt; x &lt;= b} (a..+&#x221e;) = {x | x > a} [a..+&#x221e;) = {x | x >= a} (-&#x221e;..b) = {x | x &lt; b} (-&#x221e;..b] = {x | x &lt;= b} (-&#x221e;..+&#x221e;) = all values&#xA;The values a and b used above are called endpoints. To improve consistency, Guava's notion of Range requires that the upper endpoint may not be less than the lower endpoint. The endpoints may be equal only if at least one of the bounds is closed:&#xA;[a..a] : singleton range [a..a); (a..a] : empty, but valid (a..a) : invalid&#xA;A range in Guava has the type Range&lt;C>. All ranges are immutable.&#xA;Building Ranges&#xA;Ranges can be obtained from the static methods on Range:&#xA;(a..b) open(C, C) [a..b] closed(C, C) [a..b) closedOpen(C, C) (a..b] openClosed(C, C) (a..+&#x221e;) greaterThan(C) [a..+&#x221e;) atLeast(C) (-&#x221e;..b) lessThan(C) (-&#x221e;..b] atMost(C) (-&#x221e;..+&#x221e;) all()&#xA;&#xA;Range.closed(&quot;left&quot;, &quot;right&quot;); // all strings lexographically between &quot;left&quot; and &quot;right&quot; inclusive&#xA;Range.lessThan(4.0); // double values strictly less than 4&#xA;Additionally, Range instances can be constructed by passing the bound types explicitly:&#xA;Bounded on both ends range(C, BoundType, C, BoundType) Unbounded on top ((a..+&#x221e;) or [a..+&#x221e;)) downTo(C, BoundType) Unbounded on bottom ((-&#x221e;..b) or (-&#x221e;..b]) upTo(C, BoundType)&#xA;&#xA;Here, BoundType is an enum containing the values CLOSED and OPEN.&#xA;Range.downTo(4, boundType); // allows you to decide whether or not you want to include 4&#xA;Range.range(1, CLOSED, 4, OPEN); // another way of writing Range.closedOpen(1, 4)&#xA;Operations&#xA;The fundamental operation of a Range is its contains(C) methods, which behaves exactly as you might expect. Additionally, a Range may be used as a Predicate, and used in functional idioms. Any Range also supports containsAll(Iterable&lt;? extends C>).&#xA;Range.closed(1, 3).contains(2); // returns true&#xA;Range.closed(1, 3).contains(4); // returns false&#xA;Range.lessThan(5).contains(5); // returns false&#xA;Range.closed(1, 4).containsAll(Ints.asList(1, 2, 3)); // returns true&#xA;Query Operations&#xA;To look at the endpoints of a range, Range exposes the following methods:&#xA;hasLowerBound() and hasUpperBound(), which check if the range has the specified endpoints, or goes on &quot;through infinity.&quot; lowerBoundType() and upperBoundType() return the BoundType for the corresponding endpoint, which can be either CLOSED or OPEN. If this range does not have the specified endpoint, the method throws an IllegalStateException. lowerEndpoint() and upperEndpoint() return the endpoints on the specified end, or throw an IllegalStateException if the range does not have the specified endpoint. isEmpty() tests if the range is empty, that is, it has the form [a,a) or (a,a].&#xA;&#xA;Range.closedOpen(4, 4).isEmpty(); // returns true&#xA;Range.openClosed(4, 4).isEmpty(); // returns true&#xA;Range.closed(4, 4).isEmpty(); // returns false&#xA;Range.open(4, 4).isEmpty(); // Range.open throws IllegalArgumentException&#xA;&#xA;Range.closed(3, 10).lowerEndpoint(); // returns 3&#xA;Range.open(3, 10).lowerEndpoint(); // returns 3&#xA;Range.closed(3, 10).lowerBoundType(); // returns CLOSED&#xA;Range.open(3, 10).upperBoundType(); // returns OPEN&#xA;Interval Operations&#xA;encloses&#xA;The most basic relation on ranges is encloses(Range), which is true if the bounds of the inner range do not extend outside the bounds of the outer range. This is solely dependent on comparisons between the endpoints!&#xA;[3..6] encloses [4..5] (3..6) encloses (3..6) [3..6] encloses [4..4) (even though the latter is empty) (3..6] does not enclose [3..6] [4..5] does not enclose (3..6) even though it contains every value contained by the latter range, although use of discrete domains can address this (see below) [3..6] does not enclose (1..1] even though it contains every value contained by the latter range&#xA;encloses is a partial ordering.&#xA;Given this, Range provides the following operations:&#xA;isConnected&#xA;Range.isConnected(Range), which tests if these ranges are connected. Specifically, isConnected tests if there is some range enclosed by both of these ranges, but this is equivalent to the mathematical definition that the union of the ranges must form a connected set (except in the special case of empty ranges).&#xA;isConnected is a reflexive, symmetric relation.&#xA;Range.closed(3, 5).isConnected(Range.open(5, 10)); // returns true&#xA;Range.closed(0, 9).isConnected(Range.closed(3, 4)); // returns true&#xA;Range.closed(0, 5).isConnected(Range.closed(3, 9)); // returns true&#xA;Range.open(3, 5).isConnected(Range.open(5, 10)); // returns false&#xA;Range.closed(1, 5).isConnected(Range.closed(6, 10)); // returns false&#xA;intersection&#xA;Range.intersection(Range) returns the maximal range enclosed by both this range and other (which exists iff these ranges are connected), or if no such range exists, throws an IllegalArgumentException.&#xA;intersection is a commutative, associative operation.&#xA;Range.closed(3, 5).intersection(Range.open(5, 10)); // returns (5, 5]&#xA;Range.closed(0, 9).intersection(Range.closed(3, 4)); // returns [3, 4]&#xA;Range.closed(0, 5).intersection(Range.closed(3, 9)); // returns [3, 5]&#xA;Range.open(3, 5).intersection(Range.open(5, 10)); // throws IAE&#xA;Range.closed(1, 5).intersection(Range.closed(6, 10)); // throws IAE&#xA;span&#xA;Range.span(Range) returns the minimal range that encloses both this range and other. If the ranges are both connected, this is their union.&#xA;span is a commutative, associative, and closed operation.&#xA;Range.closed(3, 5).span(Range.open(5, 10)); // returns [3, 10)&#xA;Range.closed(0, 9).span(Range.closed(3, 4)); // returns [0, 9]&#xA;Range.closed(0, 5).span(Range.closed(3, 9)); // returns [0, 9]&#xA;Range.open(3, 5).span(Range.open(5, 10)); // returns (3, 10)&#xA;Range.closed(1, 5).span(Range.closed(6, 10)); // returns [1, 10]&#xA;Discrete Domains&#xA;Some types, but not all Comparable types, are discrete, meaning that ranges bounded on both sides can be enumerated.&#xA;In Guava, a DiscreteDomain&lt;C> implements discrete operations for type C. A discrete domain always represents the entire set of values of its type; it cannot represent partial domains such as &quot;prime integers&quot;, &quot;strings of length 5,&quot; or &quot;timestamps at midnight.&quot;&#xA;The DiscreteDomain class provides DiscreteDomain instances:&#xA;Type DiscreteDomain Integer integers() Long longs()&#xA;&#xA;Once you have a DiscreteDomain, you can use the following Range operations:&#xA;ContiguousSet.create(range, domain): view a Range&lt;C> as an ImmutableSortedSet&lt;C>, with a few extra operations thrown in. (Does not work for unbounded ranges, unless the type itself is bounded.) canonical(domain): put ranges in a &quot;canonical form.&quot; If ContiguousSet.create(a, domain).equals(ContiguousSet.create(b, domain)) and !a.isEmpty(), then a.canonical(domain).equals(b.canonical(domain)). (This does not, however, imply a.equals(b).)&#xA;&#xA;ImmutableSortedSet&lt;Integer> set = ContiguousSet.create(Range.open(1, 5), DiscreteDomain.integers());&#xA;// set contains [2, 3, 4]&#xA;&#xA;ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers());&#xA;// set contains [1, 2, ..., Integer.MAX_VALUE]&#xA;Note that ContiguousSet.create does not actually construct the entire range, but instead returns a view of the range as a set.&#xA;Your Own DiscreteDomains&#xA;You can make your own DiscreteDomain objects, but there are several important aspects of the DiscreteDomain contract that you must remember.&#xA;A discrete domain always represents the entire set of values of its type; it cannot represent partial domains such as &quot;prime integers&quot; or &quot;strings of length 5.&quot; So you cannot, for example, construct a DiscreteDomain to view a set of days in a range, with a JODA DateTime that includes times up to the second: because this would not contain all elements of the type. A DiscreteDomain may be infinite -- a BigInteger DiscreteDomain, for example. In this case, you should use the default implementation of minValue() and maxValue(), which throw a NoSuchElementException. This forbids you from using the ContiguousSet.create method on an infinite range, however!&#xA;What if I need a Comparator?&#xA;We wanted to strike a very specific balance in Range between power and API complexity, and part of that involved not providing a Comparator-based interface: we don't need to worry about how ranges based on different comparators interact; the API signatures are all significantly simplified; things are just nicer.&#xA;On the other hand, if you think you want an arbitrary Comparator, you can do one of the following:&#xA;Use a general Predicate and not Range. (Since Range implements the Predicate interface, you can use Predicates.compose(range, function) to get a Predicate.) Use a wrapper class around your objects that defines the desired ordering." owner="//@users.17" labels="//@wikiLabels.0" updated_at="May 28, 2014" summary="Guava's powerful Range API, explained."/>
    <pages name="HowToContribute" content="Contributing to Guava&#xA;Thank you so much for wanting to contribute to Guava! There are a couple ways to help out.&#xA;Evangelize!&#xA;Just tell people about Guava. We believe that a bigger, more involved community makes for a better library, and that better libraries make the world a better place. We can always use more feedback.&#xA;Bug Reports&#xA;If you come across a bug in Guava, please file a bug report. Guava gets used in production at Google, so it's rare for bugs to survive very long without us noticing, but bugs do happen.&#xA;Warning us of a bug is possibly the single most valuable contribution you can make to Guava. If you encounter a bug that hasn't already been filed, please file a report with an SSCCE demonstrating the bug.&#xA;If you think something might be a bug, but you're not sure, ask on StackOverflow or on guava-discuss.&#xA;Join Discussions&#xA;There's no Guava community without active, public discussions. Chime in with your opinion of feature requests; say what you think about a potential change.&#xA;In particular, a lot of what we look for in feature requests is a variety of real-world use cases for a proposed feature. Maybe we can't think of an application for some feature -- but you came across one just yesterday, or this new feature would make your current project massively easier.&#xA;Join guava-discuss for general discussion about Guava, and guava-issues to follow Guava issues, feature requests, and discussions.&#xA;Feature Requests&#xA;Filing feature requests is one of the most popular ways to contribute to Guava.&#xA;Be aware, though: most feature requests are not accepted, not even if they're suggested by a full-time Guava team member. The feedback from our users has said that they really appreciate Guava's high power-to-weight ratio. It's important to us to keep Guava as easy to pick up and understand as we can. That means boiling features down to compact but powerful abstractions, and controlling feature bloat carefully.&#xA;Guava's main yardstick for evaluating features proposed features can be summed up as utility times ubiquity.&#xA;Utility: compare with alternatives&#xA;There is always some alternative to adding this new feature to Guava, even if it's just forking Guava yourself.&#xA;We want to see that new features have some significant advantage over the alternatives. These advantages can take many forms, but taking the time to discuss them in detail will make it much clearer why this feature should be added to Guava.&#xA;What helps the most is to have the following laid out clearly:&#xA;What are you trying to do? What's the best code you can write to accomplish that using only today's Guava? What would that same code look like if we added your feature?&#xA;Having the two approaches to a use case side by side can make it much easier to pick out the differences between them.&#xA;Additionally, it's very useful to us if you can provide a &quot;straw API&quot; -- what the method signatures would look like, for example, even if the method and class names are still in flux. This can make the feature you're suggesting much clearer to us.&#xA;Ubiquity: provide concrete use cases&#xA;Did you actually encounter the need for this feature in a real-world scenario, or is it just a feature that seems like a sensible addition to Guava?&#xA;Before new features get added to Guava, we really want to be sure that it's a use case that actually comes up in the real world. We want to hear the real-world use case so the community can discuss and debate whether this feature is actually the best way to address the real use case, or whether or not a different abstraction might be appropriate.&#xA;It's okay that you can't always give us complete context on a use case. Not all of you are at liberty to discuss the details of what you're working on.&#xA;But Guava aims to provide features that are useful across boundaries of projects, companies, or even industries -- utilities useful for a sizable proportion of all Java programmers everywhere. If you can give enough detail that any of us can imagine coming across in our own work, that's extremely helpful in studying how broadly useful the feature will be.&#xA;Code Contributions&#xA;Contributing code is one of the more difficult ways to contribute to Guava, and is almost never what the project really needs most.&#xA;New Features&#xA;Is there some feature request that you'd like to code up yourself? Is there a feature you asked for yourself that you'd like to code?&#xA;Here's how to contribute code for a new feature to Guava. (A &quot;new feature&quot; is any change to Guava that exposes new methods, classes, fields, or interfaces, or changes method signatures.)&#xA;File a feature request, if you haven't already. Discuss the feature request until it is marked Accepted. Hammer out the API, if necessary. Method and class names can still be in flux, but method signatures (arguments and return type) should be agreed on. Comment on the issue, saying that you'd like to implement it. Ask for a reviewer to volunteer. Sign the Google Individual CLA before sending us any code! (If you're contributing on behalf of your company, the company must have signed the Google Corporate CLA instead.) Implement the change. Get your change through the (difficult) Guava code review process. Expect to spend as much time on documentation and tests as you do on the source code. Don't get discouraged -- this always takes many rounds. Your reviewer will import the change into Google's source control system, and your change will get mirrored out in a day or two. Congratulations!&#xA;Note: We know it's tempting to submit code before the feature is accepted, but this is not always a good use of your time. First, the community has to discuss whether the feature is a good fit for Guava, then the API gets hammered out, and then code happens. Sending in code won't help a feature request get accepted.&#xA;If someone else has already started implementing a feature, they'll you know when you request a reviewer. Even so, volunteers are always appreciated to help review and discuss new features.&#xA;Optimizations, Tests, and Documentation&#xA;The overwhelming majority of changes to Guava don't add new features at all. Optimizations, tests, documentation, refactorings -- these are all part of making Guava meet the highest standards of code quality and usability.&#xA;Contributing improvements in these areas is much easier, and much less of a hassle, than contributing code for new features.&#xA;Just email the guava-discuss mailing list with a summary of the improvements you'd like to make and why, and ask for a reviewer. If the community agrees that it's a good change to make, code up the change and send it to your reviewer as above. There's no need to write a feature request or anything.&#xA;Getting Started&#xA;Are you ready to start coding? See this page for instructions on how to get Guava checked out and building, and how to send in code for review." owner="//@users.13" updated_at="Jul 27, 2014" summary="Instructions for how to contribute code to Guava"/>
    <pages name="Release18" content="Guava Release 18.0: Release Notes&#xA;18.0 was released on August 25, 2014 18.0-rc2 was released on August 18, 2014. 18.0-rc1 was released on August 5, 2014.&#xA;(See ReleaseHistory.)&#xA;Full API Documentation&#xA;Using Guava in your project&#xA;Note: As of Guava 18, we will no longer be releasing JDK5 backports.&#xA;Guava Guava (GWT) Maven Identifier com.google.guava:guava:18.0 com.google.guava:guava-gwt:18.0 Jar guava-18.0.jar guava-gwt-18.0.jar Javadoc guava-18.0-javadoc.jar guava-gwt-18.0-javadoc.jar Sources guava-18.0-sources.jar guava-gwt-18.0-sources.jar&#xA;&#xA;See UseGuavaInYourBuild for help integrating Guava into your build environment.&#xA;Issues resolved&#xA;16 issues are resolved in this release.&#xA;API Changes&#xA;Full JDiff Report of changes since release 17.0.&#xA;To build a combined report of the API changes between release 18.0 and any older release, check out our docs tree and run jdiff/jdiff.sh with the previous release number as argument (example: jdiff.sh 5.0).&#xA;Significant API additions and changes&#xA;common.base&#xA;MoreObjects Methods in Objects which do not have equivalents in java.util.Objects have been moved to MoreObjects to allow importing of both classes. Those methods have been deprecated in our Objects class. Methods which do have equivalents in java.util.Objects will remain (undeprecated) in our Objects class as long as Guava continues to support JDK 6.&#xA;Converter.andThen(Converter&lt;B, C>) Enums - removed deprecated valueOfFunction` method.&#xA;common.collect&#xA;FluentIterable.of(E[]) FluentIterable.append(E...) FluentIterable.append(Iterable&lt;? extends E>) FluentIterable.join(Joiner)&#xA;common.hash&#xA;Hashing.crc32c()&#xA;BloomFilter no longer recognizes the system property com.google.common.hash.BloomFilter.useMitz32 (see Release 17 - A note on BloomFilter for more information).&#xA;common.io&#xA;Methods which took an InputSupplier or OutputSupplier parameter or which returned an InputSupplier or OutputSupplier (all of which were deprecated in Guava 15.0) have been removed. Additionally, ByteSource, ByteSink, CharSource and CharSink no longer implement InputSupplier or OutputSupplier.&#xA;The InputSupplier and OutputSupplier interfaces, which no longer have any usages in Guava, will be deleted in December 2015.&#xA;common.net&#xA;InetAddresses.decrement(InetAddress)&#xA;common.reflect&#xA;Parameter.getAnnotationsByType(Class&lt;A>) Parameter.getDeclaredAnnotation(Class&lt;A>) Parameter.getDeclaredAnnotationsByType(Class&lt;A>)&#xA;common.util.concurrent&#xA;MoreExecutors.directExecutor() - lightweight, simple Executor that runs tasks on the thread that invokes execute. MoreExecutors.newDirectExecutorService() - heavier ListeningExecutorService implementation of the same thing; equivalent to sameThreadExecutor(), which has been deprecated." owner="//@users.11" labels="//@wikiLabels.1" updated_at="Aug 25, 2014" summary="Release notes for Guava Release 18.0"/>
    <pages name="GuavaExplained" content="User Guide&#xA;The Guava project contains several of Google's core libraries that we rely on in our Java-based projects: collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, and so forth. Each of these tools really do get used every day by Googlers, in production services.&#xA;But trawling through Javadoc isn't always the most effective way to learn how to make best use of a library. Here, we try to provide readable and pleasant explanations of some of the most popular and most powerful features of Guava.&#xA;This wiki is a work in progress, and parts of it may still be under construction.&#xA;Basic utilities: Make using the Java language more pleasant. Using and avoiding null: null can be ambiguous, can cause confusing errors, and is sometimes just plain unpleasant. Many Guava utilities reject and fail fast on nulls, rather than accepting them blindly. Preconditions: Test preconditions for your methods more easily. Common object methods: Simplify implementing Object methods, like hashCode() and toString(). Ordering: Guava's powerful &quot;fluent Comparator&quot; class. Throwables: Simplify propagating and examining exceptions and errors.&#xA;Collections: Guava's extensions to the JDK collections ecosystem. These are some of the most mature and popular parts of Guava. Immutable collections, for defensive programming, constant collections, and improved efficiency. New collection types, for use cases that the JDK collections don't address as well as they could: multisets, multimaps, tables, bidirectional maps, and more. Powerful collection utilities, for common operations not provided in java.util.Collections. Extension utilities: writing a Collection decorator? Implementing Iterator? We can make that easier.&#xA;Caches: Local caching, done right, and supporting a wide variety of expiration behaviors. Functional idioms: Used sparingly, Guava's functional idioms can significantly simplify code. Concurrency: Powerful, simple abstractions to make it easier to write correct concurrent code. ListenableFuture: Futures, with callbacks when they are finished. Service: Things that start up and shut down, taking care of the difficult state logic for you.&#xA;Strings: A few extremely useful string utilities: splitting, joining, padding, and more. Primitives: operations on primitive types, like int and char, not provided by the JDK, including unsigned variants for some types. Ranges: Guava's powerful API for dealing with ranges on Comparable types, both continuous and discrete. I/O: Simplified I/O operations, especially on whole I/O streams and files, for Java 5 and 6. Hashing: Tools for more sophisticated hashes than what's provided by Object.hashCode(), including Bloom filters. EventBus: Publish-subscribe-style communication between components without requiring the components to explicitly register with one another. Math: Optimized, thoroughly tested math utilities not provided by the JDK. Reflection: Guava utilities for Java's reflective capabilities. Tips: Getting your application working the way you want it to with Guava. Philosophy: what Guava is and isn't, and our goals. Using Guava in your build, with build systems including Maven, Gradle, and more. Using ProGuard to avoid bundling parts of Guava you don't use with your JAR. Apache Commons equivalents, helping you translate code from using Apache Commons Collections. Compatibility, details between Guava versions. Idea Graveyard, feature requests that have been conclusively rejected. Friends, open-source projects we like and admire. HowToContribute, how to contribute to Guava.&#xA;&#xA;NOTE: To discuss the contents of this wiki, please just use the guava-discuss mailing list." owner="//@users.16" labels="//@wikiLabels.0 //@wikiLabels.1" updated_at="May 6, 2014" summary="Landing page for Guava explanations."/>
    <pages name="ImmutableCollectionsExplained" content="Example&#xA;public static final ImmutableSet&lt;String> COLOR_NAMES = ImmutableSet.of(&#xA;  &quot;red&quot;,&#xA;  &quot;orange&quot;,&#xA;  &quot;yellow&quot;,&#xA;  &quot;green&quot;,&#xA;  &quot;blue&quot;,&#xA;  &quot;purple&quot;);&#xA;&#xA;class Foo {&#xA;  final ImmutableSet&lt;Bar> bars;&#xA;  Foo(Set&lt;Bar> bars) {&#xA;    this.bars = ImmutableSet.copyOf(bars); // defensive copy!&#xA;  }&#xA;}&#xA;Why?&#xA;Immutable objects have many advantages, including:&#xA;Safe for use by untrusted libraries. Thread-safe: can be used by many threads with no risk of race conditions. Doesn't need to support mutation, and can make time and space savings with that assumption. All immutable collection implementations are more memory-efficient than their mutable siblings (analysis) Can be used as a constant, with the expectation that it will remain fixed&#xA;Making immutable copies of objects is a good defensive programming technique. Guava provides simple, easy-to-use immutable versions of each standard Collection type, including Guava's own Collection variations.&#xA;The JDK provides Collections.unmodifiableXXX methods, but in our opinion, these can be&#xA;unwieldy and verbose; unpleasant to use everywhere you want to make defensive copies unsafe: the returned collections are only truly immutable if nobody holds a reference to the original collection inefficient: the data structures still have all the overhead of mutable collections, including concurrent modification checks, extra space in hash tables, etc.&#xA;&#xA;When you don't expect to modify a collection, or expect a collection to remain constant, it's a good practice to defensively copy it into an immutable collection.&#xA;Important: Each of the Guava immutable collection implementations rejects null values. We did an exhaustive study on Google's internal code base that indicated that null elements were allowed in collections about 5% of the time, and the other 95% of cases were best served by failing fast on nulls. If you need to use null values, consider using Collections.unmodifiableList and its friends on a collection implementation that permits null. More detailed suggestions can be found here.&#xA;How?&#xA;An ImmutableXXX collection can be created in several ways:&#xA;using the copyOf method, for example, ImmutableSet.copyOf(set) using the of method, for example, ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) or ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2) using a Builder, for example,&#xA;public static final ImmutableSet&lt;Color> GOOGLE_COLORS =&#xA;       ImmutableSet.&lt;Color>builder()&#xA;           .addAll(WEBSAFE_COLORS)&#xA;           .add(new Color(0, 191, 255))&#xA;           .build();&#xA;&#xA;Except for sorted collections, order is preserved from construction time. For example,&#xA;ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;b&quot;)&#xA;will iterate over its elements in the order &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;.&#xA;copyOf is smarter than you think&#xA;It is useful to remember that ImmutableXXX.copyOf attempts to avoid copying the data when it is safe to do so -- the exact details are unspecified, but the implementation is typically &quot;smart&quot;. For example,&#xA;ImmutableSet&lt;String> foobar = ImmutableSet.of(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;);&#xA;thingamajig(foobar);&#xA;&#xA;void thingamajig(Collection&lt;String> collection) {&#xA;   ImmutableList&lt;String> defensiveCopy = ImmutableList.copyOf(collection);&#xA;   ...&#xA;}&#xA;In this code, ImmutableList.copyOf(foobar) will be smart enough to just return foobar.asList(), which is a constant-time view of the ImmutableSet.&#xA;As a general heuristic, ImmutableXXX.copyOf(ImmutableCollection) tries to avoid a linear-time copy if&#xA;it's possible using the underlying data structures in constant time. For example, ImmutableSet.copyOf(ImmutableList) can't be done in constant time. it wouldn't cause memory leaks -- for example, if you have ImmutableList&lt;String> hugeList, and you do ImmutableList.copyOf(hugeList.subList(0, 10)), an explicit copy is performed, so as to avoid accidentally holding on to references in hugeList that aren't needed. it won't change semantics -- so ImmutableSet.copyOf(myImmutableSortedSet) will perform an explicit copy, because the hashCode() and equals used by ImmutableSet have different semantics from the comparator-based behavior of ImmutableSortedSet.&#xA;This helps minimize the performance overhead of good defensive programming style.&#xA;asList&#xA;All immutable collections provide an ImmutableList view via asList(), so -- for example -- even if you have data stored as an ImmutableSortedSet, you can get the kth smallest element with sortedSet.asList().get(k).&#xA;The returned ImmutableList is frequently -- not always, but frequently -- a constant-overhead view, rather than an explicit copy. That said, it's often smarter than your average List -- for example, it'll use the efficient contains methods of the backing collection.&#xA;Details&#xA;Where?&#xA;Interface JDK or Guava? Immutable Version Collection JDK ImmutableCollection List JDK ImmutableList Set JDK ImmutableSet SortedSet/NavigableSet JDK ImmutableSortedSet Map JDK ImmutableMap SortedMap JDK ImmutableSortedMap Multiset Guava ImmutableMultiset SortedMultiset Guava ImmutableSortedMultiset Multimap Guava ImmutableMultimap ListMultimap Guava ImmutableListMultimap SetMultimap Guava ImmutableSetMultimap BiMap Guava ImmutableBiMap ClassToInstanceMap Guava ImmutableClassToInstanceMap Table Guava ImmutableTable" owner="//@users.18" labels="//@wikiLabels.0" updated_at="Jul 1, 2014" summary="Guava's immutable collections utilities, explained."/>
    <pages name="Compatibility" content="Android&#xA;Mainline Guava has targeted Java 6 since v12.0 (to support NavigableSet and other new APIs). Guava users who target Java 5 should use the guava_jdk5 backport. This includes users who target Android Froyo and earlier.&#xA;(Android programmers concerned with Guava's large JAR size are advised to use ProGuard to get only the parts of Guava they need. Guava is one of the most common dependencies for Android applications.)&#xA;GWT&#xA;Much of Guava is compatible with Google Web Toolkit (GWT), though we do not currently optimize code specifically for GWT. Guava APIs compatible with GWT are marked with the annotation @GwtCompatible.&#xA;Basics&#xA;Our README file covers the basics: The only features we'll ever remove are @Deprecated and, occasionally, @Beta methods and classes.&#xA;&quot;Source-compatible since Guava release xx&quot;&#xA;Sometimes we will add a more specific overload of an existing method. Code compiled against the old version of Guava will still run against the new version of Guava. Additionally, any code that compiles against the new version of Guava will also compile against the old version of Guava. However, code compiled against the new version of Guava might not run against the old version because it may compile against the new overload.&#xA;An example of this is Objects.toStringHelper, which originally accepted an Object but which now has String and Class overloads, as well. Object.toStringHelper(anything) compiles under any version of Guava, but if the static type of anything is String or Class, a compile against a recent Guava version will select a new overload.&#xA;&quot;Mostly source-compatible since Guava release xx&quot;&#xA;As of this writing, there are two causes of this:&#xA;First, we sometimes change a @Beta interface to a class. Simple anonymous uses like new Foo() { ... } will continue to compile, but named classes will not. In neither case is the result binary compatible.&#xA;Second, we sometimes replace a @Beta method with a version that returns a more specific type. In this case, code compiled against a version of Guava from before the change might not run against a version of Guava from after the change, and vice versa. However, code that compiles against the old version of Guava will almost always compile against the new version of Guava. (The reverse is often true, too, when the code doesn't take advantage of the new return type.)&#xA;However, there are rare exceptions. Consider this fictional case:&#xA;Guava release n:&#xA;public static List&lt;Integer> newList() { ... }&#xA;Guava release n + 1:&#xA;public static ArrayList&lt;Integer> newList() { ... }&#xA;Most callers will compile fine against either version:&#xA;List&lt;Integer> myList = newList();&#xA;Of course, if a caller uses the new, specific type, that code won't compile against the old version:&#xA;ArrayList&lt;Integer> myList = newList();&#xA;The more interesting case, though, is code that compiles against the old version but not the new version:&#xA;Set&lt;List&lt;Integer>> myLists = ImmutableSet.of(newList());&#xA;Java's type inference isn't strong enough for ImmutableSet.of() to realize that it should treat its input as a List&lt;Integer> instead of an ArrayList&lt;Integer>, so the code must be rewritten:&#xA;Set&lt;ArrayList&lt;Integer>> myLists = ImmutableSet.of(newList());&#xA;Or, to produce code that compiles against either version of Guava:&#xA;Set&lt;List&lt;Integer>> myLists = ImmutableSet.&lt;List&lt;Integer>>of(newList());&#xA;Or, equivalently:&#xA;List&lt;Integer> myList = newList();&#xA;Set&lt;List&lt;Integer>> myLists = ImmutableSet.of(myList);" owner="//@users.5" updated_at="Jul 6, 2014" summary="Can upgrading the version of Guava I use break my build?"/>
    <pages name="ServiceExplained" content="Overview&#xA;The Guava Service interface represents an object with an operational state, with methods to start and stop. For example, webservers, RPC servers, and timers can implement the Service interface. Managing the state of services like these, which require proper startup and shutdown management, can be nontrivial, especially if multiple threads or scheduling is involved. Guava provides some skeletons to manage the state logic and synchronization details for you.&#xA;Using a Service&#xA;The normal lifecycle of a Service is&#xA;Service.State.NEW to Service.State.STARTING to Service.State.RUNNING to Service.State.STOPPING to Service.State.TERMINATED&#xA;A stopped service may not be restarted. If the service fails where starting, running, or stopping, it goes into state Service.State.FAILED.&#xA;A service can be started asynchronously using startAsync(), which returns this to enable method chaining. It is only valid to call startAsync() if the service is NEW. So you should structure your application to have a unique place where each service is started.&#xA;Stopping the service is analogous, using the asynchronous stopAsync() method. But unlike startAsync(), it is safe to call this method multiple times. This is to make it possible to handle races that may occur when shutting down services.&#xA;Service also provides several methods to wait for service transitions to complete.&#xA;asynchronously using addListener(). addListener() allows you to add a Service.Listener that will be invoked on every state transition of the service. N.B. if a service is not NEW when the listener is added, then any state transitions that have already occurred will not be replayed on the listener. synchronously using awaitRunning(). This is uninterruptible, throws no checked exceptions, and returns once the service has finished starting. If the service fails to start, this throws an IllegalStateException. Similarly, awaitTerminated() waits for the service to reach a terminal state (TERMINATED or FAILED). Both methods also have overloads that allow timeouts to be specified.&#xA;&#xA;The Service interface is subtle and complicated. We do not recommend implementing it directly. Instead please use one of the abstract base classes in guava as the base for your implementation. Each base class supports a specific threading model.&#xA;Implementations&#xA;AbstractIdleService&#xA;The AbstractIdleService skeleton implements a Service which does not need to perform any action while in the &quot;running&quot; state -- and therefore does not need a thread while running -- but has startup and shutdown actions to perform. Implementing such a service is as easy as extending AbstractIdleService and implementing the startUp() and shutDown() methods.&#xA;protected void startUp() {&#xA;  servlets.add(new GcStatsServlet());&#xA;}&#xA;protected void shutDown() {}&#xA;Note that any queries to the GcStatsServlet already have a thread to run in. We don't need this service to perform any operations on its own while the service is running.&#xA;AbstractExecutionThreadService&#xA;An AbstractExecutionThreadService performs startup, running, and shutdown actions in a single thread. You must override the run() method, and it must respond to stop requests. For example, you might perform actions in a work loop:&#xA;public void run() {&#xA;  while (isRunning()) {&#xA;    // perform a unit of work&#xA;  }&#xA;}&#xA;Alternately, you may override triggerShutdown() in any way that causes run() to return.&#xA;Overriding startUp() and shutDown() is optional, but the service state will be managed for you.&#xA;protected void startUp() {&#xA;  dispatcher.listenForConnections(port, queue);&#xA;}&#xA;protected void run() {&#xA;  Connection connection;&#xA;  while ((connection = queue.take() != POISON)) {&#xA;    process(connection);&#xA;  }&#xA;}&#xA;protected void triggerShutdown() {&#xA;  dispatcher.stopListeningForConnections(queue);&#xA;  queue.put(POISON);&#xA;}&#xA;Note that start() calls your startUp() method, creates a thread for you, and invokes run() in that thread. stop() calls triggerShutdown() and waits for the thread to die.&#xA;AbstractScheduledService&#xA;An AbstractScheduledService performs some periodic task while running. Subclasses implement runOneIteration() to specify one iteration of the task, as well as the familiar startUp and shutDown() methods.&#xA;To describe the execution schedule, you must implement the scheduler() method. Typically, you will use one of the provided schedules from AbstractScheduledService.Scheduler, either newFixedRateSchedule(initialDelay, delay, TimeUnit) or newFixedDelaySchedule(initialDelay, delay, TimeUnit), corresponding to the familiar methods in ScheduledExecutorService. Custom schedules can be implemented using CustomScheduler; see the Javadoc for details.&#xA;AbstractService&#xA;When you need to do your own manual thread management, override AbstractService directly. Typically, you should be well served by one of the above implementations, but implementing AbstractService is recommended when, for example, you are modeling something that provides its own threading semantics as a Service, you have your own specific threading requirements.&#xA;To implement AbstractService you must implement 2 methods.&#xA;doStart(): doStart() is called directly by the first call to startAsync(), your doStart() method should perform all initialization and then eventually call notifyStarted() if start up succeeded or notifyFailed() if start up failed. doStop(): doStop() is called directly by the first call to stopAsync(), your doStop() method should shut down your service and then eventually call notifyStopped() if shutdown succeeded or notifyFailed() if shutdown failed.&#xA;&#xA;Your doStart and doStop, methods should be fast. If you need to do expensive initialization, such as reading files, opening network connections, or any operation that might block, you should consider moving that work to another thread.&#xA;Using ServiceManager&#xA;In addition to the Service skeleton implementations, Guava provides a ServiceManager class that makes certain operations involving multiple Service implementations easier. Create a new ServiceManager with a collection of Services. Then you can manage them:&#xA;startAsync() will start all the services under management. Much like Service#startAsync() you can only call this method once, if all services are NEW. stopAsync() will stop all the services under management. addListener will add a ServiceManager.Listener that will be called on major state transitions. awaitHealthy() will wait for all services to reach the RUNNING state. awaitStopped() will wait for all services to reach a terminal state.&#xA;Or inspect them:&#xA;isHealthy() returns true if all services are RUNNING. servicesByState() returns a consistent snapshot of all the services indexed by their state. startupTimes() returns a map from Service under management to how long it took for that service to start in milliseconds. The returned map is guaranteed to be ordered by startup time.&#xA;&#xA;While it is recommended that service lifecycles be managed via ServiceManager, state transitions initiated via other mechanisms do not impact the correctness of its methods. For example, if the services are started by some mechanism besides startAsync(), the listeners will be invoked when appropriate and awaitHealthy() will still work as expected. The only requirement that ServiceManager enforces is that all Services must be NEW when `ServiceManager is constructed." owner="//@users.11" labels="//@wikiLabels.0" updated_at="Aug 26, 2014" summary="The Guava Service abstraction, explained."/>
    <pages name="PrimitivesExplained" content="Overview&#xA;The primitive types of Java are the basic types:&#xA;byte short int long float double char boolean&#xA;&#xA;Before searching Guava for a method, you should check if it is in Arrays or the corresponding JDK wrapper type, e.g. Integer.&#xA;These types cannot be used as objects or as type parameters to generic types, which means that many general-purpose utilities cannot be applied to them. Guava provides a number of these general-purpose utilities, ways of interfacing between primitive arrays and collection APIs, conversion from types to byte array representations, and support for unsigned behaviors on certain types.&#xA;Primitive Type Guava Utilities (all in com.google.common.primitives) byte Bytes, SignedBytes, UnsignedBytes short Shorts int Ints, UnsignedInteger, UnsignedInts long Longs, UnsignedLong, UnsignedLongs float Floats double Doubles char Chars boolean Booleans&#xA;&#xA;Methods that differ in behavior for signed and unsigned bytes are completely skipped in Bytes, but only present in the SignedBytes and UnsignedBytes utilities, since the signedness of bytes is somewhat more ambiguous than the signedness of other types.&#xA;Unsigned variants of methods on int and long are provided in the UnsignedInts and UnsignedLongs classes, but since most uses of those types are signed, the Ints and Longs classes treat their inputs as signed.&#xA;Additionally, Guava provides &quot;wrapper types&quot; for unsigned int and long values, UnsignedInteger and UnsignedLong, to help you use the type system to enforce distinctions between signed and unsigned values, in exchange for a small performance cost. These classes directly support simple arithmetic operations in the style of BigInteger.&#xA;All method signatures use Wrapper to refer to the corresponding JDK wrapper type, and prim to refer to the primitive type. (Prims, where applicable, refers to the corresponding Guava utilities class.)&#xA;Primitive array utilities&#xA;Primitive arrays are the most efficient way (in both memory and performance) to work with primitive types in aggregate. Guava provides a variety of utilities to work with these methods.&#xA;Signature Description Collection analogue Availability List&lt;Wrapper> asList(prim... backingArray) Wraps a primitive array as a List of the corresponding wrapper type. Arrays.asList Sign-independent* prim[] toArray(Collection&lt;Wrapper> collection) Copies a collection into a new prim[]. This method is as thread-safe as collection.toArray(). Collection.toArray() Sign-independent prim[] concat(prim[]... arrays) Concatenate several primitive arrays. Iterables.concat Sign-independent boolean contains(prim[] array, prim target) Determines if the specified element is in the specified array. Collection.contains Sign-independent int indexOf(prim[] array, prim target) Finds the index of the first appearance of the value target in array, or returns -1 if no such value exists. List.indexOf Sign-independent int lastIndexOf(prim[] array, prim target) Finds the index of the last appearance of the value target in array, or returns -1 if no such value exists. List.lastIndexOf Sign-independent prim min(prim... array) Returns the minimum element of the array. Collections.min Sign-dependent** prim max(prim... array) Returns the maximum element of the array. Collections.max Sign-dependent String join(String separator, prim... array) Constructs a string containing the elements of array, separated by separator. Joiner.on(separator).join Sign-dependent Comparator&lt;prim[]> lexicographicalComparator() A comparator which compares primitive arrays lexicographically. Ordering.natural().lexicographical() Sign-dependent&#xA;&#xA;* Sign-independent methods are present in: Bytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans. Not UnsignedInts, UnsignedLongs, SignedBytes, or UnsignedBytes.&#xA;** Sign-dependent methods are present in: SignedBytes, UnsignedBytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans, UnsignedInts, UnsignedLongs. Not Bytes.&#xA;General utility methods&#xA;Guava provides a number of basic utilities which were not part of JDK 6. Some of these methods, however, are available in JDK 7.&#xA;Signature Description Availability int compare(prim a, prim b) A traditional Comparator.compare method, but on the primitive types. Provided in the JDK wrapper classes as of JDK 7. Sign-dependent prim checkedCast(long value) Casts the specified value to prim, unless the specified value does not fit into a prim, in which case an IllegalArgumentException is thrown. Sign-dependent for integral types only* prim saturatedCast(long value) Casts the specified value to prim, unless the specified value does not fit into a prim, in which case the closest prim value is used. Sign-dependent for integral types only&#xA;&#xA;*Here, integral types include byte, short, int, long. Integral types do not include char, boolean, float, or double.&#xA;Note: Rounding from double is provided in com.google.common.math.DoubleMath, and supports a variety of rounding modes. See the article for details.&#xA;Byte conversion methods&#xA;Guava provides methods to convert primitive types to and from byte array representations in big-endian order. All methods are sign-independent, except that Booleans provides none of these methods.&#xA;Signature Description int BYTES Constant representing the number of bytes needed to represent a prim value. prim fromByteArray(byte[] bytes) Returns the prim value whose big-endian representation is the first Prims.BYTES bytes in the array bytes. Throws an IllegalArgumentException if bytes.length &lt;= Prims.BYTES. prim fromBytes(byte b1, ..., byte bk) Takes Prims.BYTES byte arguments. Returns the prim value whose byte representation is the specified bytes in big-endian order. byte[] toByteArray(prim value) Returns an array containing the big-endian byte representation of value.&#xA;&#xA;Unsigned support&#xA;The UnsignedInts and UnsignedLongs utility classes provide some of the generic utilities that Java provides for signed types in their wrapper classes. UnsignedInts and UnsignedLongs deal with the primitive type directly: it is up to you to make sure that only unsigned values are passed to these utilities.&#xA;Additionally, for int and long, Guava provides &quot;unsigned&quot; wrapper types (UnsignedInteger and UnsignedLong) to help you enforce distinctions between unsigned and signed values in the type system, in exchange for a small performance penalty.&#xA;Generic utilities&#xA;These methods' signed analogues are provided in the wrapper classes in the JDK.&#xA;Signature Explanation int UnsignedInts.parseUnsignedInt(String)&#xA;long UnsignedLongs.parseUnsignedLong(String) Parses an unsigned value from a string in base 10. int UnsignedInts.parseUnsignedInt(String string, int radix)&#xA;long UnsignedLongs.parseUnsignedLong(String string, int radix) Parses an unsigned value from a string in the specified base. String UnsignedInts.toString(int)&#xA;String UnsignedLongs.toString(long) Returns a string representation of the unsigned value in base 10. String UnsignedInts.toString(int value, int radix)&#xA;String UnsignedLongs.toString(long value, int radix) Returns a string representation of the unsigned value in the specified base.&#xA;&#xA;Wrapper&#xA;The provided unsigned wrapper types include a number of methods to make their use and conversion easier.&#xA;Signature Explanation UnsignedPrim plus(UnsignedPrim), minus, times, dividedBy, mod Simple arithmetic operations. UnsignedPrim valueOf(BigInteger) Returns the value from a BigInteger as an UnsignedPrim, or throw an IAE if the specified BigInteger is negative or does not fit. UnsignedPrim valueOf(long) Returns the value from the long as an UnsignedPrim, or throw an IAE if the specified long is negative or does not fit. UnsignedPrim fromPrimBits(prim value) View the given value as unsigned. For example, UnsignedInteger.fromIntBits(1 &lt;&lt; 31) has the value 231, even though 1 &lt;&lt; 31 is negative as an int. BigInteger bigIntegerValue() Get the value of this UnsignedPrim as a BigInteger. toString(), toString(int radix) Returns a string representation of this unsigned value." owner="//@users.16" labels="//@wikiLabels.0" updated_at="May 8, 2014" summary="Guava's primitives utilities, explained."/>
    <pages name="ExplainedContents" content="Introduction Basic Utilities Using/avoiding null Optional&#xA;Preconditions Ordering Creation Chaining Application&#xA;Object methods equals hashCode toString compare/compareTo&#xA;Throwables&#xA;Collections Immutable collections New collection types Multiset Multimap BiMap Table ClassToInstanceMap RangeSet&#xA;Utility Classes Iterables Lists Sets Maps Multisets Multimaps Tables&#xA;Extension Utilities Forwarding Decorators PeekingIterator AbstractIterator&#xA;&#xA;Caches Applicability Population Eviction Removal Listeners Refresh Timed Eviction Size Caps Garbage Collection Explicit Removals&#xA;Features Statistics&#xA;Interruption&#xA;Functional Idioms Obtaining Using Predicates Using Functions&#xA;Concurrency ListenableFuture Service Using Implementations&#xA;&#xA;Strings Joiner Splitter CharMatcher Charsets&#xA;Networking InternetDomainName&#xA;Primitives Primitive arrays General utilities Byte conversion Unsigned support&#xA;Ranges Building Operations Discrete Domains&#xA;I/O Closing Resources&#xA;Hashing BloomFilter&#xA;EventBus Math Integral Overflow Checking&#xA;Floating Point&#xA;Reflection TypeToken Invokable Dynamic Proxies ClassPath&#xA;Releases Release 18 Release 17 Release 16 Release 15 Release 14 Release 13 Release 12 Release 11 Release 10&#xA;Tips Philosophy Building with Guava Shrinking JARs with ProGuard Translating from Apache Commons Guava and Compatibility Idea Graveyard Friends of Guava How to Contribute&#xA;Glossary Mailing List Stack Overflow Footprint of JDK/Guava data structures" owner="//@users.11" updated_at="Aug 5, 2014" summary="Sidebar for Guava Explained."/>
    <pages name="ReleaseHistory" content="Release Date javadoc API changes r01*% 2009-09-15 javadoc r02* 2010-01-04 javadoc r03 2010-04-09 javadoc r04 2010-04-27 javadoc API changes r05 2010-05-28 javadoc API changes r06 2010-07-07 javadoc API changes Release07 2010-09-22 javadoc API changes Release08 2011-01-27 javadoc API changes Release09 2011-04-07 javadoc API changes Release10 2011-09-28, 2011-10-10 javadoc API changes Release11 2011-12-18, 2012-01-09, 2012-02-22 javadoc API changes Release12 2012-04-30, 2012-07-10 javadoc API changes Release13 2012-08-03, 2012-08-28 javadoc API changes Release14 2013-02-25, 2013-03-15 javadoc API changes Release15 2013-09-06 javadoc API changes Release16 2014-01-17, 2014-02-03 javadoc API changes Release17 2014-04-22 javadoc API changes Release18 2014-08-25 javadoc API changes&#xA;&#xA;* source release only&#xA;% did not include Google Collections&#xA;Note: Releases 1 through 11 required JDK 1.5. Releases 12 and on require JDK 1.6." owner="//@users.11" updated_at="Aug 25, 2014" summary="List of releases"/>
    <pages name="CollectionUtilitiesExplained" content="TODO: Queues, Tables&#xA;Any programmer with experience with the JDK Collections Framework knows and loves the utilities available in java.util.Collections. Guava provides many more utilities along these lines: static methods applicable to all collections. These are among the most popular and mature parts of Guava.&#xA;Methods corresponding to a particular interface are grouped in a relatively intuitive manner:&#xA;Interface JDK or Guava? Corresponding Guava utility class Collection JDK Collections2 (avoiding conflict with java.util.Collections) List JDK Lists Set JDK Sets SortedSet JDK Sets Map JDK Maps SortedMap JDK Maps Queue JDK Queues Multiset Guava Multisets Multimap Guava Multimaps BiMap Guava Maps Table Guava Tables&#xA;&#xA;Looking for transform, filter, and the like? That stuff is here, under functional idioms.&#xA;Static constructors&#xA;Before JDK 7, constructing new generic collections requires unpleasant code duplication:&#xA;List&lt;TypeThatsTooLongForItsOwnGood> list = new ArrayList&lt;TypeThatsTooLongForItsOwnGood>();&#xA;I think we can all agree that this is unpleasant. Guava provides static methods that use generics to infer the type on the right side:&#xA;List&lt;TypeThatsTooLongForItsOwnGood> list = Lists.newArrayList();&#xA;Map&lt;KeyType, LongishValueType> map = Maps.newLinkedHashMap();&#xA;To be sure, the diamond operator in JDK 7 makes this less of a hassle:&#xA;List&lt;TypeThatsTooLongForItsOwnGood> list = new ArrayList&lt;>();&#xA;But Guava goes further than this. With the factory method pattern, we can initialize collections with their starting elements very conveniently.&#xA;Set&lt;Type> copySet = Sets.newHashSet(elements);&#xA;List&lt;String> theseElements = Lists.newArrayList(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;);&#xA;Additionally, with the ability to name factory methods (Effective Java item 1), we can improve the readability of initializing collections to sizes:&#xA;List&lt;Type> exactly100 = Lists.newArrayListWithCapacity(100);&#xA;List&lt;Type> approx100 = Lists.newArrayListWithExpectedSize(100);&#xA;Set&lt;Type> approx100Set = Sets.newHashSetWithExpectedSize(100);&#xA;The precise static factory methods provided are listed with their corresponding utility classes below.&#xA;Note: New collection types introduced by Guava don't expose raw constructors, or have initializers in the utility classes. Instead, they expose static factory methods directly, for example:&#xA;Multiset&lt;String> multiset = HashMultiset.create();&#xA;Iterables&#xA;Whenever possible, Guava prefers to provide utilities accepting an Iterable rather than a Collection. Here at Google, it's not out of the ordinary to encounter a &quot;collection&quot; that isn't actually stored in main memory, but is being gathered from a database, or from another data center, and can't support operations like size() without actually grabbing all of the elements.&#xA;As a result, many of the operations you might expect to see supported for all collections can be found in Iterables. Additionally, most Iterables methods have a corresponding version in Iterators that accepts the raw iterator.&#xA;The overwhelming majority of operations in the Iterables class are lazy: they only advance the backing iteration when absolutely necessary. Methods that themselves return Iterables return lazily computed views, rather than explicitly constructing a collection in memory.&#xA;As of Guava 12, Iterables is supplemented by the FluentIterable class, which wraps an Iterable and provides a &quot;fluent&quot; syntax for many of these operations.&#xA;The following is a selection of the most commonly used utilities, although many of the more &quot;functional&quot; methods in Iterables are discussed in Guava functional idioms.&#xA;General&#xA;Method Description See Also concat(Iterable&lt;Iterable>) Returns a lazy view of the concatenation of several iterables. concat(Iterable...) frequency(Iterable, Object) Returns the number of occurrences of the object. Compare Collections.frequency(Collection, Object); see Multiset partition(Iterable, int) Returns an unmodifiable view of the iterable partitioned into chunks of the specified size. Lists.partition(List, int), paddedPartition(Iterable, int) getFirst(Iterable, T default) Returns the first element of the iterable, or the default value if empty. Compare Iterable.iterator().next()&#xA;FluentIterable.first() getLast(Iterable) Returns the last element of the iterable, or fails fast with a NoSuchElementException if it's empty. getLast(Iterable, T default)&#xA;FluentIterable.last() elementsEqual(Iterable, Iterable) Returns true if the iterables have the same elements in the same order. Compare List.equals(Object) unmodifiableIterable(Iterable) Returns an unmodifiable view of the iterable. Compare Collections.unmodifiableCollection(Collection) limit(Iterable, int) Returns an Iterable returning at most the specified number of elements. FluentIterable.limit(int) getOnlyElement(Iterable) Returns the only element in Iterable. Fails fast if the iterable is empty or has multiple elements. getOnlyElement(Iterable, T default)&#xA;&#xA;Iterable&lt;Integer> concatenated = Iterables.concat(&#xA;  Ints.asList(1, 2, 3),&#xA;  Ints.asList(4, 5, 6));&#xA;// concatenated has elements 1, 2, 3, 4, 5, 6&#xA;&#xA;String lastAdded = Iterables.getLast(myLinkedHashSet);&#xA;&#xA;String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);&#xA;  // if this set isn't a singleton, something is wrong!&#xA;Collection-Like&#xA;Typically, collections support these operations naturally on other collections, but not on iterables.&#xA;Each of these operations delegates to the corresponding Collection interface method when the input is actually a Collection. For example, if Iterables.size is passed a Collection, it will call the Collection.size method instead of walking through the iterator.&#xA;Method Analogous Collection method FluentIterable equivalent addAll(Collection addTo, Iterable toAdd) Collection.addAll(Collection) contains(Iterable, Object) Collection.contains(Object) FluentIterable.contains(Object)removeAll(Iterable removeFrom, Collection toRemove) Collection.removeAll(Collection) retainAll(Iterable removeFrom, Collection toRetain) Collection.retainAll(Collection) size(Iterable) Collection.size() FluentIterable.size() toArray(Iterable, Class) Collection.toArray(T[]) FluentIterable.toArray(Class) isEmpty(Iterable) Collection.isEmpty() FluentIterable.isEmpty() get(Iterable, int) List.get(int) FluentIterable.get(int) toString(Iterable) Collection.toString() FluentIterable.toString()&#xA;&#xA;FluentIterable&#xA;Besides the methods covered above and in the functional idioms article, FluentIterable has a few convenient methods for copying into an immutable collection:&#xA;ImmutableList ImmutableSet toImmutableSet() ImmutableSortedSet toImmutableSortedSet(Comparator)&#xA;&#xA;Lists&#xA;In addition to static constructor methods and functional programming methods, Lists provides a number of valuable utility methods on List objects.&#xA;Method Description partition(List, int) Returns a view of the underlying list, partitioned into chunks of the specified size. reverse(List) Returns a reversed view of the specified list. Note: if the list is immutable, consider ImmutableList.reverse() instead.&#xA;&#xA;List&lt;Integer> countUp = Ints.asList(1, 2, 3, 4, 5);&#xA;List&lt;Integer> countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1}&#xA;&#xA;List&lt;List&lt;Integer>> parts = Lists.partition(countUp, 2); // {{1, 2}, {3, 4}, {5}}&#xA;Static Factories&#xA;Lists provides the following static factory methods:&#xA;Implementation Factories ArrayList basic, with elements, from Iterable, with exact capacity, with expected size, from Iterator LinkedList basic, from Iterable&#xA;&#xA;Sets&#xA;The Sets utility class includes a number of spicy methods.&#xA;Set-Theoretic Operations&#xA;We provide a number of standard set-theoretic operations, implemented as views over the argument sets. These return a SetView, which can be used:&#xA;as a Set directly, since it implements the Set interface by copying it into another mutable collection with copyInto(Set) by making an immutable copy with immutableCopy()&#xA;&#xA;Method union(Set, Set) intersection(Set, Set) difference(Set, Set) symmetricDifference(Set, Set)&#xA;&#xA;For example:&#xA;Set&lt;String> wordsWithPrimeLength = ImmutableSet.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;);&#xA;Set&lt;String> primes = ImmutableSet.of(&quot;two&quot;, &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;);&#xA;&#xA;SetView&lt;String> intersection = Sets.intersection(primes, wordsWithPrimeLength); // contains &quot;two&quot;, &quot;three&quot;, &quot;seven&quot;&#xA;// I can use intersection as a Set directly, but copying it can be more efficient if I use it a lot.&#xA;return intersection.immutableCopy();&#xA;Other Set Utilities&#xA;Method Description See Also cartesianProduct(List&lt;Set>) Returns every possible list that can be obtained by choosing one element from each set. cartesianProduct(Set...) powerSet(Set) Returns the set of subsets of the specified set.&#xA;&#xA;Set&lt;String> animals = ImmutableSet.of(&quot;gerbil&quot;, &quot;hamster&quot;);&#xA;Set&lt;String> fruits = ImmutableSet.of(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;);&#xA;&#xA;Set&lt;List&lt;String>> product = Sets.cartesianProduct(animals, fruits);&#xA;// {{&quot;gerbil&quot;, &quot;apple&quot;}, {&quot;gerbil&quot;, &quot;orange&quot;}, {&quot;gerbil&quot;, &quot;banana&quot;},&#xA;//  {&quot;hamster&quot;, &quot;apple&quot;}, {&quot;hamster&quot;, &quot;orange&quot;}, {&quot;hamster&quot;, &quot;banana&quot;}}&#xA;&#xA;Set&lt;Set&lt;String>> animalSets = Sets.powerSet(animals);&#xA;// {{}, {&quot;gerbil&quot;}, {&quot;hamster&quot;}, {&quot;gerbil&quot;, &quot;hamster&quot;}}&#xA;Static Factories&#xA;Sets provides the following static factory methods:&#xA;Implementation Factories HashSet basic, with elements, from Iterable, with expected size, from Iterator LinkedHashSet basic, from Iterable, with expected size TreeSet basic, with Comparator, from Iterable&#xA;&#xA;Maps&#xA;Maps has a number of cool utilities that deserve individual explanation.&#xA;uniqueIndex&#xA;Maps.uniqueIndex(Iterable, Function) addresses the common case of having a bunch of objects that each have some unique attribute, and wanting to be able to look up those objects based on that attribute.&#xA;Let's say we have a bunch of strings that we know have unique lengths, and we want to be able to look up the string with some particular length.&#xA;ImmutableMap&lt;Integer, String> stringsByIndex = Maps.uniqueIndex(strings, new Function&lt;String, Integer> () {&#xA;    public Integer apply(String string) {&#xA;      return string.length();&#xA;    }&#xA;  });&#xA;If indices are not unique, see Multimaps.index below.&#xA;difference&#xA;Maps.difference(Map, Map) allows you to compare all the differences between two maps. It returns a MapDifference object, which breaks down the Venn diagram into:&#xA;entriesInCommon() The entries which are in both maps, with both matching keys and values. entriesDiffering() The entries with the same keys, but differing values. The values in this map are of type MapDifference.ValueDifference, which lets you look at the left and right values. entriesOnlyOnLeft() Returns the entries whose keys are in the left but not in the right map. entriesOnlyOnRight() Returns the entries whose keys are in the right but not in the left map.&#xA;&#xA;Map&lt;String, Integer> left = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3);&#xA;Map&lt;String, Integer> right = ImmutableMap.of(&quot;b&quot;, 2, &quot;c&quot;, 4, &quot;d&quot;, 5);&#xA;MapDifference&lt;String, Integer> diff = Maps.difference(left, right);&#xA;&#xA;diff.entriesInCommon(); // {&quot;b&quot; => 2}&#xA;diff.entriesDiffering(); // {&quot;c&quot; => (3, 4)}&#xA;diff.entriesOnlyOnLeft(); // {&quot;a&quot; => 1}&#xA;diff.entriesOnlyOnRight(); // {&quot;d&quot; => 5}&#xA;BiMap utilities&#xA;The Guava utilities on BiMap live in the Maps class, since a BiMap is also a Map.&#xA;BiMap utility Corresponding Map utility synchronizedBiMap(BiMap) Collections.synchronizedMap(Map) unmodifiableBiMap(BiMap) Collections.unmodifiableMap(Map)&#xA;&#xA;Static Factories&#xA;Maps provides the following static factory methods.&#xA;Implementation Factories HashMap basic, from Map, with expected size LinkedHashMap basic, from Map TreeMap basic, from Comparator, from SortedMap EnumMap from Class, from Map ConcurrentMap (supporting all operations) basic IdentityHashMap basic&#xA;&#xA;Multisets&#xA;Standard Collection operations, such as containsAll, ignore the count of elements in the multiset, and only care about whether elements are in the multiset at all, or not. Multisets provides a number of operations that take into account element multiplicities in multisets.&#xA;Method Explanation Difference from Collection method containsOccurrences(Multiset sup, Multiset sub) Returns true if sub.count(o) &lt;= super.count(o) for all o. Collection.containsAll ignores counts, and only tests whether elements are contained at all. removeOccurrences(Multiset removeFrom, Multiset toRemove) Removes one occurrence in removeFrom for each occurrence of an element in toRemove. Collection.removeAll removes all occurences of any element that occurs even once in toRemove. retainOccurrences(Multiset removeFrom, Multiset toRetain) Guarantees that removeFrom.count(o) &lt;= toRetain.count(o) for all o. Collection.retainAll keeps all occurrences of elements that occur even once in toRetain. intersection(Multiset, Multiset) Returns a view of the intersection of two multisets; a nondestructive alternative to retainOccurrences. Has no analogue&#xA;&#xA;Multiset&lt;String> multiset1 = HashMultiset.create();&#xA;multiset1.add(&quot;a&quot;, 2);&#xA;&#xA;Multiset&lt;String> multiset2 = HashMultiset.create();&#xA;multiset2.add(&quot;a&quot;, 5);&#xA;&#xA;multiset1.containsAll(multiset2); // returns true: all unique elements are contained, &#xA;  // even though multiset1.count(&quot;a&quot;) == 2 &lt; multiset2.count(&quot;a&quot;) == 5&#xA;Multisets.containsOccurrences(multiset1, multiset2); // returns false&#xA;&#xA;multiset2.removeOccurrences(multiset1); // multiset2 now contains 3 occurrences of &quot;a&quot;&#xA;&#xA;multiset2.removeAll(multiset1); // removes all occurrences of &quot;a&quot; from multiset2, even though multiset1.count(&quot;a&quot;) == 2&#xA;multiset2.isEmpty(); // returns true&#xA;Other utilities in Multisets include:&#xA;copyHighestCountFirst(Multiset) Returns an immutable copy of the multiset that iterates over elements in descending frequency order. unmodifiableMultiset(Multiset) Returns an unmodifiable view of the multiset. unmodifiableSortedMultiset(SortedMultiset) Returns an unmodifiable view of the sorted multiset.&#xA;&#xA;Multiset&lt;String> multiset = HashMultiset.create();&#xA;multiset.add(&quot;a&quot;, 3);&#xA;multiset.add(&quot;b&quot;, 5);&#xA;multiset.add(&quot;c&quot;, 1);&#xA;&#xA;ImmutableMultiset&lt;String> highestCountFirst = Multisets.copyHighestCountFirst(multiset);&#xA;&#xA;// highestCountFirst, like its entrySet and elementSet, iterates over the elements in order {&quot;b&quot;, &quot;a&quot;, &quot;c&quot;}&#xA;Multimaps&#xA;Multimaps provides a number of general utility operations that deserve individual explanation.&#xA;index&#xA;The cousin to Maps.uniqueIndex, Multimaps.index(Iterable, Function) answers the case when you want to be able to look up all objects with some particular attribute in common, which is not necessarily unique.&#xA;Let's say we want to group strings based on their length.&#xA;ImmutableSet&lt;String> digits = ImmutableSet.of(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;,&#xA;  &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;);&#xA;Function&lt;String, Integer> lengthFunction = new Function&lt;String, Integer>() {&#xA;  public Integer apply(String string) {&#xA;    return string.length();&#xA;  }&#xA;};&#xA;ImmutableListMultimap&lt;Integer, String> digitsByLength = Multimaps.index(digits, lengthFunction);&#xA;/*&#xA; * digitsByLength maps:&#xA; *  3 => {&quot;one&quot;, &quot;two&quot;, &quot;six&quot;}&#xA; *  4 => {&quot;zero&quot;, &quot;four&quot;, &quot;five&quot;, &quot;nine&quot;}&#xA; *  5 => {&quot;three&quot;, &quot;seven&quot;, &quot;eight&quot;}&#xA; */&#xA;invertFrom&#xA;Since Multimap can map many keys to one value, and one key to many values, it can be useful to invert a Multimap. Guava provides invertFrom(Multimap toInvert, Multimap dest) to let you do this, without choosing an implementation for you.&#xA;NOTE: If you are using an ImmutableMultimap, consider ImmutableMultimap.inverse() instead.&#xA;ArrayListMultimap&lt;String, Integer> multimap = ArrayListMultimap.create();&#xA;multimap.putAll(&quot;b&quot;, Ints.asList(2, 4, 6));&#xA;multimap.putAll(&quot;a&quot;, Ints.asList(4, 2, 1));&#xA;multimap.putAll(&quot;c&quot;, Ints.asList(2, 5, 3));&#xA;&#xA;TreeMultimap&lt;Integer, String> inverse = Multimaps.invertFrom(multimap, TreeMultimap.&lt;String, Integer> create());&#xA;// note that we choose the implementation, so if we use a TreeMultimap, we get results in order&#xA;/*&#xA; * inverse maps:&#xA; *  1 => {&quot;a&quot;}&#xA; *  2 => {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}&#xA; *  3 => {&quot;c&quot;}&#xA; *  4 => {&quot;a&quot;, &quot;b&quot;}&#xA; *  5 => {&quot;c&quot;}&#xA; *  6 => {&quot;b&quot;}&#xA; */&#xA;forMap&#xA;Need to use a Multimap method on a Map? forMap(Map) views a Map as a SetMultimap. This is particularly useful, for example, in combination with Multimaps.invertFrom.&#xA;Map&lt;String, Integer> map = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 1, &quot;c&quot;, 2);&#xA;SetMultimap&lt;String, Integer> multimap = Multimaps.forMap(map);&#xA;// multimap maps [&quot;a&quot; => {1}, &quot;b&quot; => {1}, &quot;c&quot; => {2}]&#xA;Multimap&lt;Integer, String> inverse = Multimaps.invertFrom(multimap, HashMultimap.&lt;Integer, String> create());&#xA;// inverse maps [1 => {&quot;a&quot;, &quot;b&quot;}, 2 => {&quot;c&quot;}]&#xA;Wrappers&#xA;Multimaps provides the traditional wrapper methods, as well as tools to get custom Multimap implementations based on Map and Collection implementations of your choice.&#xA;Unmodifiable Multimap ListMultimap SetMultimap SortedSetMultimap Synchronized Multimap ListMultimap SetMultimap SortedSetMultimap Custom Implementation Multimap ListMultimap SetMultimap SortedSetMultimap&#xA;&#xA;The custom Multimap implementations let you specify a particular implementation that should be used in the returned Multimap. Caveats include:&#xA;The multimap assumes complete ownership over of map and the lists returned by factory. Those objects should not be manually updated, they should be empty when provided, and they should not use soft, weak, or phantom references. No guarantees are made on what the contents of the Map will look like after you modify the Multimap. The multimap is not threadsafe when any concurrent operations update the multimap, even if map and the instances generated by factory are. Concurrent read operations will work correctly, though. Work around this with the synchronized wrappers if necessary. The multimap is serializable if map, factory, the lists generated by factory, and the multimap contents are all serializable. The collections returned by Multimap.get(key) are not of the same type as the collections returned by your Supplier, though if you supplier returns RandomAccess lists, the lists returned by Multimap.get(key) will also be random access.&#xA;Note that the custom Multimap methods expect a Supplier argument to generate fresh new collections. Here is an example of writing a ListMultimap backed by a TreeMap mapping to LinkedList.&#xA;ListMultimap&lt;String, Integer> myMultimap = Multimaps.newListMultimap(&#xA;  Maps.&lt;String, Collection&lt;Integer>>newTreeMap(),&#xA;  new Supplier&lt;LinkedList&lt;Integer>>() {&#xA;    public LinkedList&lt;Integer> get() {&#xA;      return Lists.newLinkedList();&#xA;    }&#xA;  });&#xA;Tables&#xA;The Tables class provides a few handy utilities.&#xA;customTable&#xA;Comparable to the Multimaps.newXXXMultimap(Map, Supplier) utilities, Tables.newCustomTable(Map, Supplier&lt;Map>) allows you to specify a Table implementation using whatever row or column map you like.&#xA;// use LinkedHashMaps instead of HashMaps&#xA;Table&lt;String, Character, Integer> table = Tables.newCustomTable(&#xA;  Maps.&lt;String, Map&lt;Character, Integer>>newLinkedHashMap(),&#xA;  new Supplier&lt;Map&lt;Character, Integer>> () {&#xA;    public Map&lt;Character, Integer> get() {&#xA;      return Maps.newLinkedHashMap();&#xA;    }&#xA;  });&#xA;transpose&#xA;The transpose(Table&lt;R, C, V>) method allows you to view a Table&lt;R, C, V> as a Table&lt;C, R, V>. For example, if you're using a Table to model a weighted digraph, this will let you view the graph with all the edges reversed.&#xA;Wrappers&#xA;These are the familiar unmodifiability wrappers you know and love. Consider, however, using ImmutableTable instead in most cases.&#xA;Unmodifiable Table RowSortedTable" owner="//@users.16" labels="//@wikiLabels.0" updated_at="Aug 5, 2014" summary="Guava's static collections utilities, explained."/>
  </wiki>
  <issueLabels name="Package-Concurrent"/>
  <issueLabels name="Package-Testing"/>
  <issueLabels name="Type-Performance"/>
  <issueLabels name="Package-Collect"/>
  <issueLabels name="Type-Enhancement"/>
  <issueLabels name="Package-Base"/>
  <issueLabels name="Type-Addition"/>
  <issueLabels name="Type-ApiDocs"/>
  <issueLabels name="Type-Defect"/>
  <wikiLabels name="explained"/>
  <wikiLabels name="Featured"/>
  <users email="fabian.z...@gmail.com" id="fabian.z...@gmail.com"/>
  <users email="dborowitz@google.com" id="dborowitz@google.com"/>
  <users email="Maaarti...@gmail.com" id="Maaarti...@gmail.com"/>
  <users email="ozzy...@gmail.com" id="ozzy...@gmail.com"/>
  <users email="lowas...@google.com" id="lowas...@google.com"/>
  <users email="lu...@google.com" id="lu...@google.com"/>
  <users email="wasserman.louis" id="wasserman.louis"/>
  <users email="tavianator@gmail.com" id="tavianator@gmail.com"/>
  <users email="thecoop1...@googlemail.com" id="thecoop1...@googlemail.com"/>
  <users email="christia...@gmail.com" id="christia...@gmail.com"/>
  <users email="sebastia...@gmail.com" id="sebastia...@gmail.com"/>
  <users email="cgdecker@google.com" id="cgdecker@google.com"/>
  <users email="----" id="----"/>
  <users email="kevinb@google.com" id="kevinb@google.com"/>
  <users email="phwend...@gmail.com" id="phwend...@gmail.com"/>
  <users email="venkates...@gmail.com" id="venkates...@gmail.com"/>
  <users email="kak@google.com" id="kak@google.com"/>
  <users email="cpov...@google.com" id="cpov...@google.com"/>
  <users email="cgdec...@gmail.com" id="cgdec...@gmail.com"/>
  <users email="leventov...@gmail.com" id="leventov...@gmail.com"/>
  <users email="consiliu...@gmail.com" id="consiliu...@gmail.com"/>
</gc:GoogleCodeProject>
