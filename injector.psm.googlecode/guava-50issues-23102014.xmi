<?xml version="1.0" encoding="ASCII"?>
<gc:GoogleCodeProject xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:gc="http://atlanmod/googlecode" name="guava-libraries" license="Apache License 2.0">
  <issueTracker url="https://code.google.com/p/guava-libraries/issues">
    <issues id="1868" date="Oct 20 (2 days ago)" summary="Document that Predicates.in uses the contains() method of the collection" description="&#xA;Hi,&#xA;There seems to be a performance bug in the &quot;in&quot; method from the Predicates class.&#xA;&#xA;The problem is that we can generate an In Predicate that has an underlying collection with a slow containment implementation, for example an ArrayList.&#xA;&#xA;The following code exposes the problem:&#xA;&#xA;_________________________________________&#xA;public static void testPredicateIn() {&#xA;&#xA;        ArrayList&lt;Integer> predicateCollection=new ArrayList&lt;Integer>();&#xA;&#xA;        for(int i=0;i&lt;500000;++i)&#xA;            predicateCollection.add(new Integer(i));&#xA;                                                          &#xA;        Predicate&lt;Integer> inPred=Predicates.in(predicateCollection);&#xA;&#xA;        for(int i=0;i&lt;500000;++i) {&#xA;            inPred.apply(new Integer(i));&#xA;        }&#xA;&#xA;    }&#xA;&#xA;__________________________________________-&#xA;Notice that we're creating an in Predicate over an ArrayList of 500000 integers. &#xA;Applying that predicate to the integers between 1 and 500000 takes a few minutes.&#xA;&#xA;I could think of a couple of ways of fixing it:&#xA;&#xA;1) Put a disclaimer in the documentation that the user is advised to pass collections with fast containment methods.&#xA;&#xA;2) Convert slow collections into HashSets, as in the following snippet:&#xA;_______________________________________________________&#xA;    private static &lt;T> Predicate&lt;T> optimizedIn(Collection&lt;? extends T> target) {&#xA;&#xA;        if(target instanceof Set)&#xA;            return Predicates.in(target);&#xA;        else&#xA;            return Predicates.in(new HashSet&lt;T>(target));&#xA;&#xA;    }&#xA;____________________________________________________&#xA;&#xA;&#xA;Here are some experimental results with different sizes for the collection predicate for the original implementation and optimizedIn:&#xA;&#xA;&#xA;      Size      Original     Optimized                                                                                                       &#xA;        10      0m0.972s     0m0.996s                                                                                                        &#xA;       100      0m1.068s     0m1.004s                                                                                                        &#xA;      1000      0m1.572s     0m0.980s                                                                                                        &#xA;     10000      0m8.065s     0m1.016s                                                                                                        &#xA;    100000      1m5.596s     0m1.052s                                                                                                        &#xA;    500000      4m56.423s    0m1.200s               &#xA;&#xA;&#xA;Regards,&#xA; Oswaldo.&#xA;" reporter="//@users.49" status="New" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.15" stars="1">
      <comments text="&#xA;Actually, I posted the root cause, rather than an actual performance bug in the library code.&#xA;&#xA;Here's a less artificial example, where creating Filtered Collections exposes the performance issue in the slow predicate:&#xA;&#xA;______________________________________________&#xA; public static void testCollections2Filter() {&#xA;&#xA;        ArrayList&lt;Integer> filterCollection=new ArrayList&lt;Integer>();&#xA;        ArrayList&lt;Integer> toAddCollection=new ArrayList&lt;Integer>();&#xA;        for(int i=0;i&lt;500000;++i) {&#xA;            filterCollection.add(new Integer(i));&#xA;            toAddCollection.add(new Integer(i));&#xA;        }&#xA;&#xA;        //      Predicate&lt;Integer> inPred=optimizedIn(filterCollection);                                                                        &#xA;             Predicate&lt;Integer> inPred=Predicates.in(filterCollection);&#xA;&#xA;            Collection&lt;Integer> filteredCollection=Collections2.filter(new ArrayList&lt;Integer>(),inPred);&#xA;&#xA;                filteredCollection.addAll(toAddCollection);&#xA;&#xA;    }&#xA;_______________&#xA;&#xA;Here are the results I'm getting with the original and optimized versions of the &quot;in&quot; predicate:&#xA;&#xA; // Size    Original  Optimized                                                                                                              &#xA;&#xA;       Size  Original  Optimized&#xA;         10  0m1.124s  0m1.096s                                                                                                               &#xA;        100  0m1.112s  0m1.088s                                                                                                               &#xA;       1000  0m1.164s  0m1.152s                                                                                                               &#xA;      10000  0m1.216s  0m1.160s                                                                                                               &#xA;     100000  0m9.421s  0m1.228s                                                                                                               &#xA;     200000  0m50.611s 0m1.252s                                                                                                               &#xA;     500000  > 10 min  0m1.324s    &#xA;&#xA;&#xA;Regards,&#xA; Oswaldo.&#xA;" date="Oct 21 (2 days ago)" owner="//@users.49"/>
      <comments text="&#xA;There's a couple points here:&#xA;&#xA;  - The documentation of Predicates.in specifies, &quot;It does not defensively copy the collection passed in, so future changes to it will alter the behavior of the predicate.&quot;  That's a non-@Beta method contract that we would almost certainly not change, and there's not really any way to satisfy that contract and do anything like what you're proposing.&#xA;  - We could document better than the collection's own contains() method is used, and that the performance of the predicate will be equivalent to the performance of the collection's contains() method.&#xA;  - For very short lists, it is not always the case that converting to a HashSet will help performance.&#xA;  - It's possible that it might make sense as a warning or an error in error-prone (http://errorprone.info/) to pass a List to Predicates.in, but we'd have to investigate this -- and that'd be more appropriate as a bug filed against error-prone, rather than Guava.&#xA;" date="Oct 21 (45 hours ago)" owner="//@users.50"/>
    </issues>
    <issues id="1867" date="Oct 20 (2 days ago)" summary="Adding a new value to a map if absent however lazily" description="&#xA;Need a putIfAbsent type method which takes a Builder rather than a created object as value along with Key K.&#xA;This in specific tries to create the object iff the key is absent.&#xA;&#xA;Advantage: The value doesn't get un-necessarily created.&#xA;" reporter="//@users.28" status="New" owner="//@users.56" stars="1">
      <comments text="&#xA;Java 8 provides this as a new default method on Map, but I imagine this would be unnecessarily complicated before Java 8, if you had to write the anonymous Supplier instance -- it'd probably take more lines than just writing it the old-fashioned way.&#xA;" date="Oct 20 (2 days ago)" owner="//@users.4"/>
      <comments text="&#xA;Given that migrating to Java 8 takes significant amount of time ; i was hoping if it were to be implemented in guava&#xA;" date="Oct 20 (2 days ago)" owner="//@users.28"/>
      <comments text="&#xA;As I was attempting to say, Guava could only really do this by letting you use an anonymous class, since you can't use lambdas until Java 8, and the anonymous class would be so verbose that your code would be shorter if you wrote it the &quot;normal way.&quot;&#xA;" date="Oct 20 (2 days ago)" owner="//@users.50"/>
      <comments text="&#xA;OK got it. thanks for clarification&#xA;" date="Oct 20 (2 days ago)" owner="//@users.28"/>
    </issues>
    <issues id="1869" date="Yesterday (36 hours ago)" summary="CountingOutputStream allegedly declares @Nullable out (wrapped), but will NPE" description="&#xA;The constructor suggests that outputsteam may be null:&#xA;&#xA;public CountingOutputStream(@Nullable OutputStream out)&#xA;&#xA;But then any write/close operation will NPE:&#xA;&#xA;@Override public void write(byte[] b, int off, int len) throws IOException {&#xA;    out.write(b, off, len);&#xA;    count += len;&#xA;}&#xA;&#xA;Either the @Nullable annotation should be removed, or the write/close methods should only pass-through when out is non-null.&#xA;" reporter="//@users.11" status="Accepted" owner="//@users.6" labels="//@issueLabels.7 //@issueLabels.2 //@issueLabels.5" stars="1">
      <comments text="&#xA;Thanks for the report. This does look like something that should be changed.&#xA;" date="Yesterday (20 hours ago)" owner="//@users.6"/>
    </issues>
    <issues id="1862" date="Oct 10, 2014" summary="Order of enqueued events" description="&#xA;The post order of enqueued events is not guaranteed. In practice the order of enqueued events is the same for the majority of the time but not always. In my case, each start of my application could have a different order of posted events. This makes testing and bugfixing a lot harder.&#xA;Changing the subscribersByType from HashMultimap to LinkedHashMultimap in the EventBus class fixed it for me.&#xA;" reporter="//@users.22" status="New" owner="//@users.56" stars="2"/>
    <issues id="1864" date="Oct 10, 2014" summary="Should toStringHelper(Class|Object) use simple name or canonical name (or either)?" description="&#xA;For some nested classes you would really rather toStringHelper chose the canonical name &quot;Foo.Bar&quot; instead of just the simple name &quot;Bar&quot;.&#xA;&#xA;Questions:&#xA;&#xA;1. Which is the best default behavior?&#xA;&#xA;2. If that is the canonical name, would it be evil to change it now? It is perhaps debatable whether the current behavior really is strongly promised by spec. Some overenthusiastic unit tests would have to be changed, but how bad is that?&#xA;&#xA;3. Does this choice actually merit a new configuration option to ToStringHelper? Note that without it, users who want the opposite behavior will need to change typical (85%) usage code like so:&#xA;&#xA; toStringHelper(this) --> toStringHelper(getClass().getCanonicalName())&#xA;&#xA;... which is not pleasant. However, we don't want ToStringHelper to become too complex.&#xA;" reporter="//@users.41" status="Research" owner="//@users.56" labels="//@issueLabels.14 //@issueLabels.15" stars="2">
      <comments text="&#xA;Possibly we should apply our decision here equally to AutoValue. (AutoValue currently appears to use &quot;Bar.&quot;)&#xA;" date="Oct 14, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1863" date="Oct 10, 2014" summary="Preventing thread starvation in blocking operations" description="&#xA;I've sub-classed ListenableFuture to wrap helper functions from the Futures class to make the futures slightly more composable, however, the issue I'm now facing is preventing potential thread starvation in a fixed worker thread pool (Executors.GLOBAL) in the example below due to someone accidentally blocking in a Function or AsyncFunction (thus potentially blocking all threads in this pool). &#xA;&#xA;Scala's Await.result uses &quot;managed blocking&quot;. i.e., detect the blocking operation and temporarily spawn a new thread (see http://stackoverflow.com/a/13099594). Is there anything equivalent in Guava/Java? &#xA;&#xA;Is this the reason Futures.transform has the option to use the current thread? &#xA;&#xA;    &#xA;public &lt;ReturnType> MFuture&lt;ReturnType> flatMap(AsyncFunction&lt;InputType, ReturnType> fn){&#xA;        return new MFuture&lt;ReturnType>(Futures.transform(listenableFuture, fn, Executors.GLOBAL));&#xA;    }&#xA;&#xA;    public &lt;ReturnType> MFuture&lt;ReturnType> map(Function&lt;InputType, ReturnType> fn){&#xA;        return new MFuture&lt;ReturnType>(Futures.transform(listenableFuture, fn, Executors.GLOBAL));&#xA;    }&#xA;&#xA;" reporter="//@users.45" status="New" owner="//@users.56" labels="//@issueLabels.3 //@issueLabels.0" stars="2">
      <comments text="&#xA;I've solved this issue by changing from a FixedThreadPool to a CachedThreadPool, which is probably ok for my scenario, but looking for suggestions. &#xA;" date="Oct 10, 2014" owner="//@users.45"/>
      <comments text="&#xA;The Java support for managed blocking that I'm aware of is in the JDK's ForkJoinPool. I don't believe we have anything related in Guava.&#xA;&#xA;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html&#xA;&#xA;As for applying that to your situation, I'm a bit over my head. You might try StackOverflow.&#xA;" date="Oct 10, 2014" owner="//@users.43"/>
      <comments text="&#xA;Thanks, that's exactly what I was looking for. &#xA;" date="Oct 10, 2014" owner="//@users.45"/>
    </issues>
    <issues id="1865" date="Oct 17 (5 days ago)" summary="Clarify the meaning of &quot;success&quot; of a Future" description="&#xA;From an internal discussion:&#xA;&#xA;---&#xA;&#xA;Huh. I had assumed that &quot;success&quot; was the usual name for this, but I can't find it anywhere in the Future docs. The closest term used there is &quot;completed normally,&quot; used in contrast to &quot;an exception&quot; and &quot;cancellation&quot;: http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone-- But other parts of the doc seem to consider there to be only two cases, &quot;completed normally&quot; and &quot;cancelled,&quot; suggesting that &quot;an exception&quot; is a kind of &quot;completed normally.&quot;&#xA;&#xA;---&#xA;&#xA;The word &quot;success&quot; is used throughout http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html&#xA;&#xA;---&#xA;&#xA;It would be super-confusing for &quot;success&quot; to mean anything other than &quot;completed without throwing&quot;, so the meaning of &quot;success&quot; is relatively obvous.  But it would be better if docs like in FutureCallback replaced &#xA;&#xA;   * Invoked with the result of the {@code Future} computation when it is&#xA;   * successful.&#xA;&#xA;with&#xA;&#xA;   * Invoked with the result of the {@code Future} computation when it completes&#xA;   * normally.&#xA;&#xA;or even more pedantically&#xA;&#xA;   * Invoked with the result of the {@code Future} computation if and when it completes normally (that is, without throwing an exception).&#xA;&#xA;---&#xA;&#xA;I'm still conflicted about this, given that &quot;completed normally&quot; is slightly ambiguous. Perhaps we could define &quot;success&quot; in our package-info and link to that? But mostly I'm just having trouble prioritizing this above other issues.&#xA;" reporter="//@users.43" status="New" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.0" stars="1"/>
    <issues id="1821" date="Jul 30, 2014" summary="DenseImmutableTable$Row is not GWT Serializable" description="&#xA;Error from our log:&#xA;com.google.gwt.user.client.rpc.SerializationException: could not get type signature for class com.google.common.collect.DenseImmutableTable$Row&#xA;&#xA;There is no CustomFieldSerializer for the subclasses of ImmutableArrayMap which is an inner class of DenseImmutableTable&#xA;" reporter="//@users.55" status="New" owner="//@users.56" labels="//@issueLabels.12" stars="1">
      <comments text="&#xA;Thanks. I'm hoping that GWT will make some changes to make this easier. I've been hoping that for a while, though. I just filed a GWT feature request to try to get an update:&#xA;&#xA;https://code.google.com/p/google-web-toolkit/issues/detail?id=8844&#xA;" date="Aug 1, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1822" date="Jul 30, 2014" summary="Class name repeated in output of resolveType()" description="&#xA;Test program:&#xA;&#xA;  import com.google.common.reflect.TypeToken;&#xA;&#xA;  public class Outer {&#xA;&#xA;    public abstract static class Inner&lt;T extends Inner&lt;T>> {&#xA;    }&#xA;&#xA;    public void foo(Iterable&lt;? extends Inner&lt;?>> arg) {&#xA;    }&#xA;&#xA;    public static void main(String[] args) throws Exception {&#xA;        System.out.println(&#xA;          TypeToken.of(Outer.class.getMethod(&quot;foo&quot;, Iterable.class)&#xA;          .getGenericParameterTypes()[0]));&#xA;    }&#xA;  }&#xA;&#xA;Expected output:&#xA;&#xA;  java.lang.Iterable&lt;? extends Outer$Inner&lt;?>>&#xA;&#xA;Actual output:&#xA;&#xA;  java.lang.Iterable&lt;? extends Outer.Outer$Inner&lt;?>>&#xA;&#xA;" reporter="//@users.26" status="New" owner="//@users.37" labels="//@issueLabels.7 //@issueLabels.6" stars="1">
      <comments text="&#xA;Sorry forgot to include: Guava version 1.17.&#xA;&#xA;" date="Jul 30, 2014" owner="//@users.26"/>
      <comments text="(No comment was entered for this change.)&#xA;" date="Jul 30, 2014" owner="//@users.43"/>
      <comments text="&#xA;Any strong opinion between Outer.Inner vs. Outer$Inner?&#xA;&#xA;The tricky part is when the outer class is parameterized. &#xA;&#xA;innerClass.getName() would print: &quot;O$I&quot;&#xA;&#xA;But one may prefer to see &quot;O&lt;T>.I&lt;S>&quot;.&#xA;" date="Jul 30, 2014" owner="//@users.37"/>
      <comments text="&#xA;Actually I reduced the test case to something so simple I think it obscured the real bug.&#xA;&#xA;If you add &quot;package pkg&quot; at the top of the test case, then this will be the output:&#xA;&#xA;  java.lang.Iterable&lt;? extends pkg.Outer.pkg.Outer$Inner&lt;?>>&#xA;&#xA;So it's not just a question of preference - &quot;pkg.Outer.pkg.Outer&quot; is clearly wrong.&#xA;&#xA;Back to your question, seems like staying consistent with Class.getName() is good, but that means we lose the outer type parameter, and IMHO the latter is more important... i.e., TypeToken.toString() should reveal as much of its secret type information as possible because people are mainly using it to understand what the type really is.&#xA;&#xA;" date="Jul 30, 2014" owner="//@users.26"/>
      <comments text="&#xA;Interestingly, JDK7's built-in ParameterizedType.toString() does the same thing.&#xA;&#xA;Map.Entry&lt;String, String>.toString() => &quot;java.util.Map.java.util.Map$Entry&lt;java.lang.String, java.lang.String>&quot;&#xA;&#xA;Do we want to make our types behave differently from builtin types?&#xA;" date="Jul 31, 2014" owner="//@users.37"/>
      <comments text="&#xA;Well. Actually, when you call TypeToken.of(jvmType).toString(), it's really just calling jvmType.toString().&#xA;&#xA;TypeToken isn't doing anything in the middle here.&#xA;&#xA;" date="Jul 31, 2014" owner="//@users.37"/>
      <comments text="&#xA;FWIW I filed a bug on bugs.sun.com (which, in my experience, is just a black hole fronted by a web site).&#xA;&#xA;" date="Aug 2, 2014" owner="//@users.26"/>
    </issues>
    <issues id="1820" date="Jul 29, 2014" summary="BloomFilter.create to accept Funnel&lt;? extends T> instead of Funnel&lt;T>" description="&#xA;For now,  BloomFilter.create accepts strictly Funnel&lt;T> which makes it impossible to write type-safe String BloomFilter using builtin funnels:&#xA;&#xA;BloomFilter&lt;String> filter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), 10000); &#xA;&#xA;does not compile which is somewhat frustrating.&#xA;&#xA;I'd propose to change BloomFilter.create to accept Funnel&lt;? extends T> which should allow such code.&#xA;" reporter="//@users.18" status="Accepted" owner="//@users.57" labels="//@issueLabels.13 //@issueLabels.14" stars="1">
      <comments text="&#xA;Yep, this looks like an oversight on our part. Should be fixed shortly.&#xA;" date="Jul 29, 2014" owner="//@users.57"/>
      <comments text="&#xA;I dont quite ubderstand why you couldn't just go with Funnel&lt;CharSequence>?&#xA;" date="Jul 29, 2014" owner="//@users.50"/>
      <comments text="&#xA;Also you mean Funnel&lt;? super T>, right?&#xA;" date="Jul 29, 2014" owner="//@users.57"/>
      <comments text="&#xA;2kak@google.com: sure, my bad.&#xA;" date="Jul 29, 2014" owner="//@users.18"/>
    </issues>
    <issues id="1825" date="Aug 1, 2014" summary="feature request: intersect method for RangeSet" description="&#xA;[Via email, kevinb encouraged me to submit this request.]&#xA;&#xA;RangeSet is great, and provides me with lots of useful capabilities. There is one fundamental, useful operation that's unexpectedly missing: intersect. There's a subRangeSet method, but it only operates on a single Range, not another RangeSet.&#xA;&#xA;Since there is a union method (aka addAll), and a complement method, I should be able to cobble together an intersect method thus:&#xA;  &lt;T> RangeSet&lt;T> intersect(RangeSet&lt;T> a, RangeSet&lt;T> b) {&#xA;    RangeSet inverse = TreeRangeSet.create(a.complement);&#xA;    inverse.addAll(b.complement());&#xA;    return inverse.complement();&#xA;  }&#xA;&#xA;Nonetheless, life would be simpler and more worry-free for all users if the API directly supported an intersect method.&#xA;" reporter="//@users.19" status="New" owner="//@users.50" labels="//@issueLabels.16 //@issueLabels.12" stars="2">
      <comments text="&#xA;See also issue 1778, which addresses this use case but unfortunately has received no review or triage in two months.&#xA;" date="Aug 5, 2014" owner="//@users.40"/>
      <comments text="&#xA;I feel like if we were to do this, it should be a magic view method, which I think would be feasible, just somewhat tricky?&#xA;" date="Aug 6, 2014" owner="//@users.50"/>
      <comments text="&#xA;The code referred to in issue 1778 has been open sourced under the LPGL version 3 or later license.&#xA;&#xA;https://github.com/nmdp-bioinformatics/ngs/tree/master/range/src/main/java/org/nmdp/ngs/range/tree&#xA;" date="Sep 24, 2014" owner="//@users.40"/>
    </issues>
    <issues id="1823" date="Jul 31, 2014" summary="Method for using a Invokable as a function?" description="&#xA;Could there be a method on Invokable or static factory in Functions to convert Invokable to a Function assuming arg-less invocation?&#xA;" reporter="//@users.2" status="New" owner="//@users.56" stars="1"/>
    <issues id="1824" date="Aug 1, 2014" summary="Booleans is marked as @GwtCompatible but imports java.util.BitSet which is not emulated by GWT" description="&#xA;The summary pretty much sums it up. &#xA;&#xA;Actually Booleans does only use BitSet in JavaDoc @link references and not in code, however the import is enough for GWT to fail during compilation. Using full qualified @link references should probably fix the problem.&#xA;&#xA;[java]    [ERROR] Errors in 'jar:file:/..../guava-gwt.jar!/com/google/common/primitives/Booleans.java'&#xA;[java]    [ERROR] Line 29: The import java.util.BitSet cannot be resolved&#xA;[java]    [ERROR] Aborting compile due to errors in some input files&#xA;" reporter="//@users.1" status="Accepted" owner="//@users.56" labels="//@issueLabels.1 //@issueLabels.7 //@issueLabels.5" stars="5">
      <comments text="(No comment was entered for this change.)&#xA;" date="Aug 1, 2014" owner="//@users.57"/>
      <comments text="&#xA;Huh. Apparently our tests don't care. What version of GWT is this, and what compilation flags do you pass?&#xA;" date="Aug 1, 2014" owner="//@users.43"/>
      <comments text="&#xA;It was not me who had the problem, I just reported it. After a bit more talk with the guy who has the problem it seems he uses a custom GWT build so I would blame that build.&#xA;&#xA;Actually I just tried it myself with official GWT 2.5.0 and 2.6.1 and I can't produce the error.&#xA;&#xA;I think you can close this issue.&#xA;" date="Aug 1, 2014" owner="//@users.1"/>
      <comments text="&#xA;OK, thanks. Do let us know if you find otherwise.&#xA;" date="Aug 1, 2014" owner="//@users.43"/>
      <comments text="&#xA;We have same problem here. We are using:&#xA;&#xA;- Windows 8 &#xA;- Java 7 (src/target version 1.6)&#xA;- GXT 2.5.1&#xA;- GWT 2.5.1&#xA;&#xA;Apparently this seems not to make a problem with Windows 7 (like my local machine).&#xA;" date="Aug 20, 2014" owner="//@users.53"/>
      <comments text="&#xA;What flags do you compile with?&#xA;" date="Aug 20, 2014" owner="//@users.43"/>
      <comments text="&#xA;Currently not at office. But I think there are no special settings activated for the GWT build with Maven. Just Java 1.6 for source and target. As said: Does not work on a Window 8 machine. Works fine on Windows 7 or Debian Linux (build server).&#xA;" date="Aug 20, 2014" owner="//@users.53"/>
      <comments text="&#xA;We might as well fix this, though it's hard to promise that it won't creep back in, since we can't reproduce the problem.&#xA;&#xA;In the long term, the problem might solve itself:&#xA;https://code.google.com/p/google-web-toolkit/issues/detail?id=3279&#xA;" date="Sep 5, 2014" owner="//@users.43"/>
      <comments text="&#xA;I started experiencing this same problem when I switched to jdk8 with GWT 2.5.0 / Guava 15.0.&#xA;&#xA;I took the OPs suggestion of using fully qualified @link references but that didn't seem to help.&#xA;" date="Oct 16 (6 days ago)" owner="//@users.16"/>
      <comments text="&#xA;My temporary workaround is to copy the source code into sources folder und remove that import. GWT compilation succeeds in my case. But why isn't it just possible to remove that import. In my opinion importing a class that is not really use is a code smell. Or?!&#xA;" date="Oct 16 (6 days ago)" owner="//@users.53"/>
      <comments text="&#xA;I also have Java 8 installed and I am using GWT 2.5.1&#xA;" date="Oct 16 (6 days ago)" owner="//@users.53"/>
      <comments text="&#xA;I was wrong earlier when I stated that the OPs suggestion did not work.  When I was testing it I changed the references to be fully-qualified but I forgot to remove the import.  With both fully-qualified javadoc references and the removal of the import, our GWT compile is now succeeding.&#xA;&#xA;" date="Oct 17 (5 days ago)" owner="//@users.16"/>
      <comments text="&#xA;I've submitted the fix internally. It will be mirrored out shortly. I didn't find an easy way to test for the problem (short of hardcoding a check for &quot;import java.util.BitSet&quot; for Booleans.java specifically), so I'll hope that we don't reintroduce it in the future. Please let us know if we do.&#xA;" date="Oct 17 (5 days ago)" owner="//@users.43"/>
    </issues>
    <issues id="1859" date="Sep 30, 2014" summary="Guava testlib doesn't test support of equal, but not identical (==) map/set keys at all" description="&#xA;Which is a very important case.&#xA;" reporter="//@users.59" status="Accepted" owner="//@users.56" labels="//@issueLabels.11 //@issueLabels.16" stars="2">
      <comments text="&#xA;Oh, in the test-suite builders? I had never thought about that. We should do something about it.&#xA;" date="Sep 30, 2014" owner="//@users.43"/>
      <comments text="&#xA;The thing is everywhere in the framework we just use the given SimpleElements, same object for each &quot;equivalence class&quot; all the time. We don't try to, say, put a value for one key object, and get the value back querying equal, but not identical key.&#xA;" date="Sep 30, 2014" owner="//@users.59"/>
      <comments text="&#xA;*SampleElements&#xA;" date="Sep 30, 2014" owner="//@users.59"/>
    </issues>
    <issues id="1858" date="Sep 28, 2014" summary="Converter - FindBugs problem" description="&#xA;FindBugs reports &quot;inherits equals and uses Object.hashCode()&quot; for Converter-subclasses.&#xA;&#xA;http://findbugs.sourceforge.net/bugDescriptions.html#HE_INHERITS_EQUALS_USE_HASHCODE&#xA;&#xA;@ test/Test.java @&#xA;&#xA;package test;&#xA;&#xA;import com.google.common.base.Converter;&#xA;&#xA;import java.io.Serializable;&#xA;&#xA;public final class Test {&#xA;&#xA;  private static final class TestConverter&#xA;      extends Converter&lt;String, String> implements Serializable {&#xA;&#xA;    /*package*/ static final TestConverter INSTANCE = new TestConverter();&#xA;&#xA;    private static final long serialVersionUID = 1;&#xA;&#xA;    @Override&#xA;    public String toString() {&#xA;      return &quot;TestConverter.testConverter()&quot;;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected String doForward(String string) {&#xA;      return string;&#xA;    }&#xA;&#xA;    @Override&#xA;    protected String doBackward(String string) {&#xA;      return string;&#xA;    }&#xA;&#xA;    private Object readResolve() {&#xA;      return INSTANCE;&#xA;    }&#xA;  }&#xA;&#xA;  public static Converter&lt;String, String> testConverter() {&#xA;    return TestConverter.INSTANCE;&#xA;  }&#xA;&#xA;  private Test() {&#xA;  }&#xA;}&#xA;&#xA;@ pom.xml @&#xA;&#xA;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#xA;&#x9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;>&#xA;&#x9;&lt;modelVersion>4.0.0&lt;/modelVersion>&#xA;&#x9;&lt;groupId>test&lt;/groupId>&#xA;&#x9;&lt;artifactId>test&lt;/artifactId>&#xA;&#x9;&lt;version>1.0.0-SNAPSHOT&lt;/version>&#xA;&#x9;&lt;dependencies>&#xA;&#x9;&#x9;&lt;dependency>&#xA;&#x9;&#x9;&#x9;&lt;groupId>com.google.guava&lt;/groupId>&#xA;&#x9;&#x9;&#x9;&lt;artifactId>guava&lt;/artifactId>&#xA;&#x9;&#x9;&#x9;&lt;version>18.0&lt;/version>&#xA;&#x9;&#x9;&lt;/dependency>&#xA;&#x9;&lt;/dependencies>&#xA;&#x9;&lt;build>&#xA;&#x9;&#x9;&lt;plugins>&#xA;&#x9;&#x9;&#x9;&lt;plugin>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;groupId>org.codehaus.mojo&lt;/groupId>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;artifactId>findbugs-maven-plugin&lt;/artifactId>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;version>3.0.0&lt;/version>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;executions>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;execution>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;goals>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;goal>check&lt;/goal>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/goals>&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;/execution>&#xA;&#x9;&#x9;&#x9;&#x9;&lt;/executions>&#xA;&#x9;&#x9;&#x9;&lt;/plugin>&#xA;&#x9;&#x9;&lt;/plugins>&#xA;&#x9;&lt;/build>&#xA;&lt;/project>&#xA;&#xA;@@&#xA;&#xA;mvn clean install&#xA;&#xA;...&#xA;[INFO] --- findbugs-maven-plugin:3.0.0:check (default) @ test ---&#xA;[INFO] BugInstance size is 1&#xA;[INFO] Error size is 0&#xA;[INFO] Total bugs: 1&#xA;[INFO] test.Test$TestConverter inherits equals and uses Object.hashCode() [&quot;test.Test$TestConverter&quot;] At Test.java:[lines 9-32]&#xA;[INFO] ------------------------------------------------------------------------&#xA;[INFO] BUILD FAILURE&#xA;[INFO] ------------------------------------------------------------------------&#xA;[INFO] Total time: 6.516 s&#xA;[INFO] Finished at: 2014-09-29T00:00:54+01:00&#xA;[INFO] Final Memory: 23M/118M&#xA;[INFO] ------------------------------------------------------------------------&#xA;[ERROR] Failed to execute goal org.codehaus.mojo:findbugs-maven-plugin:3.0.0:check (default) on project test: failed with 1 bugs and 0 errors -> [Help 1]&#xA;...&#xA;&#xA;@@&#xA;&#xA;The &quot;problem&quot; is the override in Converter:&#xA;&#xA;  @Override&#xA;  public boolean equals(@Nullable Object object) {&#xA;    return super.equals(object);&#xA;  }&#xA;&#xA;But there is no corresponding override for hashCode:&#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    return super.hashCode();&#xA;  }&#xA;&#xA;This forces everyone to either ignore the FindBugs warning or include the snippet above in their subclass.&#xA;&#xA;Please add &#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    return super.hashCode();&#xA;  }&#xA;&#xA;to Converter, thanks.&#xA;" reporter="//@users.27" status="New" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.15" stars="2">
      <comments text="&#xA;To be clear, this is actually a false positive from FindBugs (since there isn't actually a bug here).&#xA;&#xA;Looks like we only override equals so we can add additional documentation. I wonder if we should just move that documentation into the class docs, or drop it all together.&#xA;" date="Sep 28, 2014" owner="//@users.57"/>
    </issues>
    <issues id="1856" date="Sep 24, 2014" summary="&quot;Throttle&quot; for slowing down rapidly submitted Runnables" description="&#xA;From the mailing-list:&#xA;&#xA;Especially in GUI-applications I often find myself in the need for a throttle which executes a Runnable only after a certain time has passed and only the last Runnable that has been scheduled.&#xA;&#xA;Example: In SWT, when the user resizes a window or a table-column I store that information.&#xA;SWT has a Listener for the resize-event which fires basically for every pixel that is moved, so one resize fires potentially hundreds of events, saving that every time would be slow and I'm only interested in the last value anyway.&#xA;&#xA;I implemented an Executor [0] that can give me an instance of Throttle [1] with a specified timeout..&#xA;&#xA;When a Runnable is submitted to/via the Throttle it is only executed after the timeout has passed. Within this time, every newly submitted Runnable replaces the one waiting.&#xA;&#xA;[0] https://github.com/fab1an/appkit/blob/master/src/main/java/org/appkit/concurrent/SmartExecutor.java&#xA;[1] https://fab1an.github.io/appkit/javadoc/org/appkit/concurrent/Throttle.html&#xA;&#xA;&#xA;" reporter="//@users.33" status="New" owner="//@users.56" stars="2"/>
    <issues id="1851" date="Sep 19, 2014" summary="Sets.newHashSet Javadoc should suggest use of diamond operator" description="&#xA;Lists.newArrayList and Maps.newHashMap include blurbs like:&#xA;&#xA;   * &lt;p>&lt;b>Note for Java 7 and later:&lt;/b> if {@code elements} is a {@link&#xA;   * Collection}, you don't need this method. Use the {@code ArrayList}&#xA;   * {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking&#xA;   * advantage of the new &lt;a href=&quot;http://goo.gl/iz2Wi&quot;>&quot;diamond&quot; syntax&lt;/a>.&#xA;&#xA;Sets.newHashSet should include a similar note.&#xA;" reporter="//@users.35" status="Accepted" owner="//@users.56" stars="2">
      <comments text="&#xA;Indeed, a lot of things still need this, thanks for the kick.&#xA;" date="Sep 19, 2014" owner="//@users.41"/>
      <comments text="&#xA;modernizer-maven-plugin has a more complete list of there:&#xA;&#xA;https://github.com/andrewgaul/modernizer-maven-plugin/blob/master/src/main/resources/modernizer.xml&#xA;" date="Sep 22, 2014" owner="//@users.35"/>
    </issues>
    <issues id="1799" date="Jul 9, 2014" summary="Missing use case: transforming Optional to Optional" description="&#xA;I have a use case where I am transforming an `Optional`, transforming it into the value of a member variable. The issue: The member variable can be null so I'd like to convert it to an Optional if it exists.&#xA;&#xA;Proposal:&#xA;&#xA;class Optional&lt;T> ... {&#xA;    ...&#xA;&#xA;    public Optional&lt;F> Optional#transformToOptional(Function&lt;T, F> transformer) {&#xA;        try {&#xA;            return this.transform(transformer);&#xA;        catch (NullPointerException e) {&#xA;            return Optional.&lt;F>.absent()&#xA;        }&#xA;    }&#xA;}&#xA;(which reservations to typos and probably not catching NullPointerException in real implementation, instead checking for null)&#xA;" reporter="//@users.13" status="New" owner="//@users.56" stars="1">
      <comments text="&#xA;I've reported similar issue in October 2012 and cannot wait for resolution, see https://code.google.com/p/guava-libraries/issues/detail?id=1171 (the cause of NPE can be arbitrary so I feel weird of globally catching NPE, instead I suggested transforming null result to Optional which eventually showed to be consistent with JDK8).&#xA;" date="Jul 9, 2014" owner="//@users.10"/>
    </issues>
    <issues id="1855" date="Sep 23, 2014" summary="Immutable collections do not guard against wrong Collection.toArray() method" description="&#xA;ImmutableList etc. can be changed after construction if a collection is passed to copyOf() that keeps a reference to the array returned by toArray(). If the resulting array is of correct size and has more than one element, it is directly used as the backing array of the immutable collection. I attached a file that shows this. The same happens in other places as well, for example in Ordering.immutableSortedCopy().&#xA;&#xA;Such a collection violates the contract of Collection.toArray() which explicitly mentions that the collection may not retain a reference to the array. The only way I could imagine this to happen accidentally might be someone who needs to convert a lot of data back and forth between a List and an array, and implements something like Arrays.asList() but returning the internal array directly in toArray(). Another possibility would be some third-party code that maliciously tries to mangle with internal data structures.&#xA;&#xA;The fix for this would be to do a second copy in these cases, which would probably be a major performance decrease for many users. In our project we do not need this additional protection as we do not have untrusted code, and would certainly prefer the speed of the current solution instead. I guess this is true for a vast majority of users.&#xA;&#xA;A variant of this fix would be to whitelist collections from the java.* and com.google.* packages which are known to be well-behaved in this regard, and do a second copy only for other collections. This would be quite ugly and still costs performance for all users that pass in their own collections.&#xA;&#xA;Thus I suggest to keep the current behavior, and instead document this.&#xA;Currently the wiki states that Guavas immutable collection are &quot;Safe for use by untrusted libraries&quot;, which I would interpret for example such that it is safe to take an immutable collection returned by some untrusted library and use it directly.&#xA;This is not true, regardless of whether the library directly returns an immutable collection, or whether it returns an arbitrary collection and my code calls copyOf().&#xA;Instead, users retrieving collections from untrusted sources and copying them into an immutable collection need to do a second copy themselves with ImmutableList.copyOf(collection.toArray(new T[0])). (Using toArray() would lose the element type, copying into a List would require yet another copy, and using copyOf(copyOf()) of course does not work because the second call does not copy again.)&#xA;" reporter="//@users.42" status="New" owner="//@users.56" labels="//@issueLabels.12 //@issueLabels.8" stars="3">
      <comments text="(No comment was entered for this change.)&#xA;" date="Sep 24, 2014" owner="//@users.57"/>
      <comments text="&#xA;One thing that could be done is&#xA;&#xA;    Object[] array = new Object[elements.size()];&#xA;    checkState(array == elements.toArray(array));&#xA;    return construct(array);&#xA;&#xA;instead of&#xA;&#xA;    return construct(elements.toArray());&#xA;&#xA;I'm not really sure it's worth it just to handle invalid Collection implementations though.&#xA;" date="Sep 24, 2014" owner="//@users.21"/>
      <comments text="&#xA;Calling toArray(array) will help with unintentional bugs. It's worth consideration, though I wonder if it has performance disadvantages for some collections.&#xA;&#xA;The problem of malicious implementations is one that we've intentionally decided not to tackle. We do need to fix our docs.&#xA;" date="Sep 24, 2014" owner="//@users.43"/>
      <comments text="&#xA;I believe the sense in which the wiki page meant things was that it was safe to *pass* ImmutableCollections to untrusted libraries, though there obviously isn't anything we can do about reflection.&#xA;" date="Sep 24, 2014" owner="//@users.50"/>
      <comments text="&#xA;Passing an own array would not help against malicious implementations as they could grab the array anyway. Concerning contracts, it's even worse as I can't see anything like &quot;no references to it are maintained by this collection&quot; in the javadoc of `Collection.toArray(T[])`, though it's somehow obvious.&#xA;" date="Sep 24, 2014" owner="//@users.46"/>
      <comments text="&#xA;Maaartinus, what do you mean?  The Collection.toArray Javadoc states:&#xA;> The returned array will be &quot;safe&quot; in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array.&#xA;" date="Sep 24, 2014" owner="//@users.4"/>
      <comments text="&#xA;I mean the proposal from comment #2 to use *the other* toArray method which gives no such guarantee. Doing something like&#xA;&#xA;&lt;T> T[] toArray(T[] a) {&#xA;    this.gotcha = super.toArray();&#xA;    return this.gotcha;&#xA;}&#xA;&#xA;would violate common sense, but no explicitly stated contract.&#xA;" date="Sep 24, 2014" owner="//@users.46"/>
    </issues>
    <issues id="1854" date="Sep 23, 2014" summary="Change size-based eviction to allow for significantly varying segment sizes" description="&#xA;Presently size-based eviction divides maxWeight by the number of segments (concurrency level) and then each segment checks individually on writes for the need to evict entries.  &#xA;&#xA;This leads to under utilization of ram when the size of the data in each segment varies a lot.  One can pick a larger maxWeight, of course, but then if the distribution of the sizes of the segments changes, one is in danger of ram really being overcommitted.  One might also pick a better hash function, but it is not clear that will solve this consistently.&#xA;&#xA;A better solution is to coordinate eviction across the segments so that the total cache more or less stays below the maxWeight, but allows segments to be larger when they are imbalanced.  The additional need is that when one segment is below it's max and yet the cache as a whole is still over weight, one needs to poke at least one other segment to evict. &#xA;&#xA;I have coded a solution to this in https://code.google.com/r/craigwi-guava/.  The tests don't pass and so I'm not sure what to do about them.  It would make sense to change the eviction unit test to account for this change, but that hasn't been done yet.&#xA;" reporter="//@users.34" status="New" owner="//@users.56" cc="//@users.7" labels="//@issueLabels.3 //@issueLabels.4" stars="6">
      <comments text="&#xA;Under what sorts of circumstances would the relative size of the segments vary significantly?  I'm having a hard time visualizing when this would happen other than a deliberate hash attack.&#xA;" date="Sep 23, 2014" owner="//@users.50"/>
      <comments text="&#xA;Guava is used in several places in ElasticSearch.  In the case of the fielddata cache, the concurrency level is 16.  Many of us have set the fielddata cache to use size-based eviction only to find that evictions are happening well before the cache is 'full'.  In my case, I specified a 2GB cache and only 650mb was used when evictions started.&#xA;&#xA;You can read more about these cases here: https://groups.google.com/forum/#!msg/elasticsearch/HZj2AR16oss/812kgZb8FhMJ and https://groups.google.com/forum/#!msg/elasticsearch/42qrpYRJvsU/IPArEH8KSYQJ.&#xA;" date="Sep 23, 2014" owner="//@users.34"/>
      <comments text="&#xA;Ah, I see. So first things first: if each entry was on the order of say ~1 mb or less, this would point to a bad hash function (or hash attack).&#xA;&#xA;It is, however, expected behavior when entries are much coarser than that. You really have 16 independent caches, which is of course where the high concurrency comes from.&#xA;&#xA;So this FR makes sense, but I suspect it's not highly feasible given the way common.cache works now.&#xA;" date="Sep 23, 2014" owner="//@users.41"/>
      <comments text="&#xA;In case it wasn't clear, I already wrote the code and worked to ensure the independent (in the concurrency sense) of the segments.  Let me know what you think after reviewing the code.&#xA;" date="Sep 23, 2014" owner="//@users.34"/>
      <comments text="&#xA;Part of the point of the way LocalCache is currently implemented is that operations on two different segments should not contend for any locks.  From what I can tell, your approach seems to require a global AtomicLong updated on every operation on every segment.&#xA;&#xA;The current approach was a deliberate tradeoff: accepting imprecise weight-based evictions for the sake of keeping segments as independent as possible.  For more typical usages of Cache, this seems likely to be a significant performance loss as lots of small, cheap cache operations are forced to contend on a single AtomicLong.&#xA;" date="Sep 23, 2014" owner="//@users.50"/>
      <comments text="&#xA;The real solution here is to implement the eviction queue globally instead of per-segment. We have an internal issue about this (which needs to be made external), but we know how to do this and even wanted to do it in 2011 but didn't have a compelling case for justifying the change. This seems like a pretty compelling reason to do that right.&#xA;" date="Sep 23, 2014" owner="//@users.7"/>
      <comments text="(No comment was entered for this change.)&#xA;" date="Sep 23, 2014" owner="//@users.7"/>
      <comments text="&#xA;Re using AtomicLong, if this is anything more than an interlocked increment or compare exchange at the hardware level, that definitely would be the wrong thing to do.  &#xA;&#xA;As for how often it is called, AtomicLong.addAndGet() is called in two places -- same two places that this.totalWeight is updated.  These calls occur only for writes and removals which already take the per-segment lock and are relative heavy weight.&#xA;&#xA;In particular, AtomicLong.addAndGet() is NOT called in the normal read case.  There is one edge case I covered, but it is likely very rare and may not be worth coding for.&#xA;&#xA;However, I might have missed some other problematic case and would be happy to know what I missed.&#xA;&#xA;As for the &quot;real solution&quot; I agree and of course would be happy with any better solution than the one I have proposed.&#xA;" date="Sep 23, 2014" owner="//@users.34"/>
      <comments text="> As for how often it is called, AtomicLong.addAndGet() is called in two places -- same two places that this.totalWeight is updated.  These calls occur only for writes and removals which already take the per-segment lock and are relative heavy weight.&#xA;&#xA;My understanding is that taking the segment lock is one thing, but that many threads hammering on a single AtomicLong can be a serious performance issue.  For example, Doug Lea's most recent ConcurrentHashMap implementation avoids AtomicLong for this reason, using some seriously magic alternatives.  We actually have that class in Guava, under the name LongAdder, but I'm not sure we could use that and still preserve the invariant that the cache as a whole never goes over the limit.&#xA;" date="Sep 23, 2014" owner="//@users.50"/>
      <comments text="&#xA;The LongAdder is indeed interesting and inspired me to use a different approach for my requested feature.  &#xA;&#xA;The existing Segment.totalWeight values are like the Cell values in Doug Lea's approach.  I changed my code to avoid the AtomicLong completely at the cost of a sum of the segments totalWeight values.  &#xA;&#xA;I pushed the new approach to https://code.google.com/r/craigwi-guava/.&#xA;&#xA;Let me know what you think.&#xA;" date="Sep 23, 2014" owner="//@users.34"/>
      <comments text="&#xA;I may be blind, but I can't see there any visibility guarantee for segment.totalWeight in evictEntriesFromLargestSegment.&#xA;&#xA;Concerning the AtomicLong, you could reduce the contention by updating it only when currentSegment.totalWeight has changed significantly since the last update, i.e., let's say by more than 1/8 of the segment capacity. This way you'd maintain an approximation of the total weight within this precision and you could ensure that no eviction takes place before the cache reaches 7/8 (instead of 1/segments.length) of its capacity.&#xA;&#xA;For normally behaving caches, there'd no contention at all as all segments would reach and stay at about their maximum size and never update the AtomicLong.&#xA;" date="Sep 24, 2014" owner="//@users.46"/>
      <comments text="&#xA;That's another good idea to reduce the potential cost / contention of using AtomicLong.   &#xA;&#xA;My most recent version avoids AtomicLong altogether -- summing up the total segment weights as needed during eviction.&#xA;&#xA;What are the next steps here?  Do you have perf tests against which we can measure this change?&#xA;" date="Sep 29, 2014" owner="//@users.34"/>
      <comments text="&#xA;It was mentioned above and in another forum that perhaps a better hash function would solve this.  The issue stems from the combination of the hash function distribution AND the distribution of the sizes of the elements -- the later of which cannot be encoded in the hash function.  With a &quot;perfect&quot; hash function, each cache segment would have an equal number of (and let's say equal aged) entries.  If the entries vary in size then the cache will still be out of balance (size-wise) and likely never utilize the specified cache fully.  The more the size varies, the more the cache won't utilized RAM fully.&#xA;" date="Sep 30, 2014" owner="//@users.34"/>
      <comments text="&#xA;Any update on this?  Would like to get an idea of where this is heading in order to take the appropriate action in ES (see https://github.com/elasticsearch/elasticsearch/issues/7836).&#xA;" date="Oct 8, 2014" owner="//@users.9"/>
      <comments text="&#xA;I think my concrete issue with the current version of the change is that it's back to allowing races: totalSegmentView() can have an inconsistent view of the size of the different segments.  You'd encounter this issue with LongAdder, too, I believe.&#xA;&#xA;The current solution manages to *guarantee* that the weight cap is never exceeded even in a multithreaded context, and keeps each operation local to the specific segment it needs to access, without contending with operations on any other segment.  In exchange, it works poorly for a very narrow range of use cases like this, where the size of individual cache entries is a large fraction of the total weight cap, relative to the concurrencyLevel.&#xA;&#xA;To be honest, I can't see any way of maintaining these invariants while accomplishing something like your goal here.  If we come up with a way to maintain these invariants while increasing cache utilization, we can come back to this, but I don't think this is likely to go anywhere in the near term.&#xA;" date="Oct 13, 2014" owner="//@users.50"/>
      <comments text="&#xA;The current solution, in fact, does NOT guarantee that the weight cap is never exceeded.  On cache miss the following high level steps happen in this order:&#xA;&#xA;1. load new data and store into segment &#xA;    (cf. code called from loadSync())&#xA;2. *then* check to see if segment is *over* full (while (totalWeight > maxSegmentWeight) { &lt;do evict> } )&#xA;    (this is in eviceEntries())&#xA;&#xA;Which means that every segment can be at 100% full and the very next load on any segment will cause the memory usage to exceed the segment weight and thus the whole cache weight.  If this happened all at the same time for many/all segments, each of those segments could go over at the same time and the cache would be over weight by the size of the data just loaded.&#xA;&#xA;I believe that my proposal will result in a cache level over commit amount similar to the current code (not identical, but similar).  &#xA;&#xA;Of course, the problem I'm trying to solve is the under commit amount.  My proposal dramatically improves the behavior on the under commit side.&#xA;" date="Oct 13, 2014" owner="//@users.34"/>
    </issues>
    <issues id="1853" date="Sep 23, 2014" summary="Performance tweak for CharSink.write(CharSequence) and related methods" description="&#xA;Hi there. I set-out to replace a little utility with:&#xA;&#xA;  Files.write(CharSequence, File, Charset)&#xA;&#xA;But a quick microbenchmark found Guava's method to be slower on sustained writes of large Strings to individual files. (e.g. +33% longer for 16MB strings.) Results targeting HDD and SSD were similar. Surprisingly, peak memory was heavily impacted too. (I guess Java uses a big in-process write-buffer somewhere.)&#xA;&#xA;Here's a tweak in CharSink which I think will give memory &amp; speed improvements to the Files method above (and maybe others):&#xA;&#xA;   public void write(CharSequence charSequence) throws IOException {&#xA;     checkNotNull(charSequence);&#xA;&#xA;     Closer closer = Closer.create();&#xA;     try {&#xA;-      Writer out = closer.register(openStream());&#xA;+      Writer out = closer.register(charSequence.length() > 8192 ? openBufferedStream() : openStream());&#xA;       out.append(charSequence);&#xA;     //...&#xA;&#xA;In the case of OutputStreamWriter / FileWriter, this change ultimately calls into StreamEncoder.write(char[], int, int) which can use BufferedWriter's char buffer directly; rather than StreamEncoder.write(String, int, int) which makes a copy of the entire string.&#xA;&#xA;The default implementation in Writer also get the same benefit when wrapped by BufferedWriter, so I think this will benefit a range of Writer classes, not just file writers.&#xA;&#xA;I couldn't test the proposed tweak directly, so here's my actual tests which appear to support the theory:&#xA;&#xA;Harness:&#xA;&#xA;    String TEXT = Strings.repeat(&#xA;            &quot;12345678901234567890123456789012345678901234567890123456789012345678901234567890&quot;,&#xA;            200_000);&#xA;&#xA;    for (int i = 0; i &lt; 40; i++) {&#xA;        long t0 = System.nanoTime();&#xA;        File out = new File(&quot;T:\\tmp\\i&quot; + i);&#xA;        doWrite(out);&#xA;        System.out.println((System.nanoTime() - t0) / 1_000_000f);&#xA;    }&#xA;&#xA;With these implementations of doWrite:&#xA;&#xA;  Test 1: 44ms per file, 1590 MB peak memory**&#xA;&#xA;        Files.write(TEXT, out, Charset.defaultCharset());&#xA;&#xA;&#xA;  Test 2: 44ms per file, 1590 MB peak memory&#xA;&#xA;        try (Writer w = new FileWriter(out)) {&#xA;            w.append(TEXT);&#xA;            w.flush();&#xA;        }&#xA;&#xA;  Test 3: 32ms per file, 366 MB peak memory&#xA;&#xA;        try (Writer w = new BufferedWriter(new FileWriter(out))) {&#xA;            w.append(TEXT);&#xA;            w.flush();&#xA;        }&#xA;&#xA;Notes: &#xA; * Tested using Java 8 32b running on Win 64b on an i7-860&#xA; * 8192 matches BufferedWriter's buffer, maybe it can be turned further. Or maybe just using BufferedWriters always might be sufficient.&#xA; * A similar tweak may be applicable to ByteSink? (Not tried.)&#xA;&#xA;** memory = &quot;Peak Private Bytes&quot; according to SysInternal's Process Explorer.&#xA;&#xA;" reporter="//@users.36" status="Accepted" owner="//@users.6" labels="//@issueLabels.14 //@issueLabels.2" stars="2">
      <comments text="&#xA;Interesting... my expectation would be that a Writer implementation, given a single large String, should be able to handle it as efficiently as possible since it has all the cards so to speak. I imagine BufferedWriter to be more useful for collecting many small writes.&#xA;&#xA;But it looks like regardless of how large a chunk you provide the characters to the Writer in, an OutputStreamWriter will only write out 8192 bytes at a time, so copying the large String's char array is basically just a big waste of time. It's actually really surprising to me that StreamEncoder doesn't handle this differently... it could just wrap the String in a CharBuffer and use that with CharsetEncoder without needing to copy the char array at all. Maybe there's some good reason for that I'm not aware of.&#xA;&#xA;Anyway, this does look like a good potential solution.&#xA;&#xA;> A similar tweak may be applicable to ByteSink? (Not tried.)&#xA;&#xA;This seems less likely since byte arrays don't need to go through encoding but can just be passed directly to a native method to be written.&#xA;" date="Sep 23, 2014" owner="//@users.6"/>
      <comments text="> an OutputStreamWriter will only write out 8192 bytes at a time (...)&#xA;&#xA;Huh, so it does. I missed that. &#xA;&#xA;> byte arrays don't need to go through encoding but can just be passed directly to a native method to be written&#xA;&#xA;Indeed. Sorry I should have taken a few minutes to check that.&#xA;&#xA;> It's actually really surprising to me that StreamEncoder doesn't handle this differently (...) Maybe there's some good reason for that I'm not aware of.&#xA;&#xA;I agree. Possibly because StreamEncoder is itself a Writer, and the JDK Writers seem to follow this (undocumented?) pattern:&#xA; 1. call write(char[], int, int) to do the real work&#xA; 2. only call it once&#xA;&#xA;(1) makes some sense when there's lots of overridden and overridable methods in a deep hierarchy. (But maybe it hints of yearning for a better design?)&#xA;&#xA;(2) could be concern about per-call-costs in derived classes? (multiply-wrapped Writers, synchronisation, class CarrierPidgeonIpWriter {handy in the days of NSA snooping} etc.) Or just trying to be more friendly to overridden classes?&#xA;&#xA;Anyway, I'd still rate performance as a higher concern for StreamEncoder than these other things... but no point crying over Java's spilt milk, I guess. It ain't going to help ;-)&#xA;&#xA;" date="Sep 23, 2014" owner="//@users.36"/>
    </issues>
    <issues id="1852" date="Sep 21, 2014" summary="Add a checked narrowing operation to TypeToken." description="&#xA;Suppose I have checked at runtime that TypeToken.of(Base.class).isAssignableFrom(type), where &quot;type&quot; is a java Type.&#xA;I now want to do TypeToken.of(type).getSupertype(Base.class).&#xA;However, this will not compile as TypeToken.of(type) returns TypeToken&lt;?>, and getSuperclass wants its argument to be a Class&lt;? super T>, where T is the capture type for &lt;?>.&#xA;&#xA;AFAIK, there is no way to get a TypeToken&lt;? extends Base> from TypeToken.of(type), even if we know at runtime that Base is assignable from &quot;type&quot;.&#xA;&#xA;A possible solution would be to add a checked narrowing operation to TypeToken, such as:&#xA;&#xA;public &lt;U> TypeToken&lt;? extends U> as(TypeToken&lt;U> other) {&#xA;  // check other is assignable from this&#xA;  return (TypeToken&lt;? extends U>) this;&#xA;}&#xA;&#xA;and a similar method that accepts a Class&lt;U> instead of TypeToken&lt;U>.&#xA;This would avoid the need of unchecked conversions by the user.&#xA;&#xA;" reporter="//@users.54" status="New" owner="//@users.56" stars="3"/>
    <issues id="1812" date="Jul 21, 2014" summary="Improved nullability annotations" description="&#xA;There are a number of distinct issues here, and it's not really fair of me to mark them all as duplicates. However, we've got at least 7 bugs filed, and in broad strokes, they come down to 3 basic points:&#xA;&#xA;1. Annotate return types as @Nullable/@NonNull more consistently.&#xA;2. Follow the annotation interpretations used by different versions of Findbugs / by Eclipse / by the Checker Framework.&#xA;3. Take advantage of more annotation and a more sophisticated type system (typically the Checker Framework). (Or, in some cases, introduce extra interfaces to Guava with different annotations on each.)&#xA;&#xA;Kevin is likely to attempt to do some of (1), but we will never get it 100% unless we do (2) or (3), both of which look more difficult than we expect to take on soon.&#xA;&#xA;Again, I apologize for the oversimplification of collapsing these all to one bug. I'm just trying to better capture the way we think of the situation, which is basically &quot;annotation some return types, then give up for a while.&quot;&#xA;" reporter="//@users.43" status="Research" owner="//@users.56" cc="//@users.41" labels="//@issueLabels.14 //@issueLabels.9" stars="48">
      <comments text=" Issue 1811  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text=" Issue 1810  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text=" Issue 1677  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text=" Issue 1278  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text=" Issue 1221  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text=" Issue 920  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text=" Issue 1279  has been merged into this issue.&#xA;" date="Jul 21, 2014" owner="//@users.43"/>
      <comments text="&#xA;In our main Java application we drew a line in the sand to minimize null values in every class. This involved implementing the Null Object pattern in many cases but mostly being consistent with our annotations. &#xA;&#xA;We started by creating the missing package-level annotations FieldsAreNonnulByDefault and ReturnValuesAreNonnullByDefault and ensuring they are applied to every package along with ParametersAreNonnullByDefault. From there it was easy: apply CheckForNull whenever null is allowed. &#xA;&#xA;The beauty of this approach is that anyone reading the code knows what to expect in the absence of an annotation. If most elements allow null, create your own defaults, but I highly recommend using the same default for fields, parameters, and return values. Mixing defaults across the three will only cause confusion.&#xA;&#xA;I would be happy to help out in this endeavor because I feel it would help lots of developers use this awesome library.&#xA;" date="Jul 21, 2014" owner="//@users.8"/>
    </issues>
    <issues id="1813" date="Jul 23, 2014" summary="Document immutability of ranges in the JavaDocs" description="&#xA;I didn't find information on the immutability of `Range` instances in the JavaDocs [1]; only the wiki page [2] explicitly states it.&#xA;&#xA;I suggest documenting the immutability directly in the JavaDocs, and thus in the implementation itself.&#xA;&#xA;[1] http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Range.html&#xA;[2] https://code.google.com/p/guava-libraries/wiki/RangesExplained&#xA;&#xA;&#xA;(Slightly unrelated: The comments disappeared from the wiki, especially helpful ones which I remembered to be on the page on ranges are gone. I'd like to state that I don't welcome that change.)&#xA;" reporter="//@users.30" status="Accepted" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.12" stars="1">
      <comments text="&#xA;Augh! How terrible.&#xA;" date="Jul 23, 2014" owner="//@users.41"/>
    </issues>
    <issues id="1814" date="Jul 24, 2014" summary="Support for partially random expiration" description="&#xA;When rolling out an upgrade to a cluster of Guava powered instances there's a risk that local caches will expire within the same time.&#xA;&#xA;Proposal: Add a method to CacheBuilder that allows for randomization of expiration. This will eventually spread expiration evenly over time.&#xA;&#xA;Workaround: Instantiate a Random instance and use it as input to `.expire*` method. Cumbersome.&#xA;&#xA;I'd love to hear your input on this.&#xA;" reporter="//@users.13" status="New" owner="//@users.56" labels="//@issueLabels.14 //@issueLabels.4" stars="1"/>
    <issues id="1817" date="Jul 25, 2014" summary="Allow AsyncEventBus to drain its queue" description="&#xA;As issue #1348 is not really going anywhere right now, I am trying to shut down an AsyncEventBus instance in a controlled manner (ensure that no new events are enqueued, make sure that all events in the queue get dispatched before shut down).&#xA;&#xA;Right now, this is pretty hard and requires dancing around the black box that the event bus is (https://github.com/groupon/jesos/blob/master/src/main/java/com/groupon/mesos/util/ManagedEventBus.java). &#xA;&#xA;It would be great to have a defined way to &quot;shut down&quot; an event bus so that it no longer accepts new events and also a way to ask it whether it is &quot;fully drained&quot; (No events in flight). &#xA;&#xA;As the current event bus code is all package private, the only way to actually implement it is to shim my code into the com.google package which seems to be weird. So consider this another vote to make EventBus and AsyncEventBus easily extendable.&#xA;" reporter="//@users.47" status="New" owner="//@users.56" stars="2"/>
    <issues id="1818" date="Jul 28, 2014" summary="Add Debounce and Throttle to Guava?" description="&#xA;Would it be interesting to have something like Debounce and Throttle functions in Guava?&#xA;&#xA;I really like those 2 and have used them from Underscore.js a couple times.&#xA;&#xA;I Think they are more like a functional thing, but nevertheless they are very useful for handling UI events.&#xA;&#xA;http://underscorejs.org/#throttle&#xA;http://underscorejs.org/#debounce&#xA;&#xA;I could try to send a pull request if you guys thing it would be usefull to Guava to have those.&#xA;&#xA;Cheers&#xA;" reporter="//@users.51" status="New" owner="//@users.56" labels="//@issueLabels.14 //@issueLabels.10" stars="1"/>
    <issues id="1819" date="Jul 29, 2014" summary="ClassSanityTester.testNulls fails on equals" description="&#xA;When I call the following, the test case fails (see full test case in attachment).&#xA;&#xA;  new ClassSanityTester().testNulls(MyObject.class);&#xA;&#xA;I get the following error: No exception thrown for parameter at index 0 from MyObjectTest$MyObject.public boolean MyObjectTest$MyObject.equals(java.lang.Object)[null] for class MyObjectTest$MyObject&#xA;&#xA;Clearly, this indicates that it expects a call to &quot;equals(Object)&quot; to throw a NullPointerException. That method should never throw an exception but rather return true or false. The test seems to skip this assertion and I'm surprised this hasn't been reported earlier. &#xA;&#xA;Please make it so ClassSanityTester#testNulls(Class) doesn't fail when equals is behaving correctly (see the test case where testEquals(MyObject.class succeeds).&#xA;&#xA;On a side note, the text returned should be adapted as it mentions three times MyObjectTest$MyObject. That's 2 too many, and it renders the whole error message nearly not understandable.&#xA;" reporter="//@users.44" status="New" owner="//@users.56" labels="//@issueLabels.11 //@issueLabels.7" stars="1">
      <comments text="&#xA;Okay, I found one issue on my side: the lack of online javadoc available. I had to check in the code online to find out that it's playing nice only if @Nullable is present.&#xA;&#xA;I checked the front-page of Guava and no, there is no link at all to the testlib javadoc. I played a bit with urls and couldn't find any url for the testlib javadoc.&#xA;&#xA;" date="Jul 30, 2014" owner="//@users.44"/>
    </issues>
    <issues id="1783" date="Jun 16, 2014" summary="Case Formatter handling of accronym from camel Case" description="&#xA;When converting a caml case String to Upper snake case the desired handling would be to consider the accronym (aka substring of only upcase caracters) as a single word. Instead the converter treats all consecutive upcase caracter as a single word.&#xA;&#xA;Reproduce: System.out.println(LOWER_CAMEL.to(UPPER_UNDERSCORE, &quot;ISBN&quot;));&#xA;(guava 17)&#xA;&#xA;Result: I_S_B_N&#xA;&#xA;Desired Output: ISBN&#xA;&#xA;" reporter="//@users.25" status="New" owner="//@users.56" labels="//@issueLabels.15 //@issueLabels.14" stars="1">
      <comments text="&#xA;FYI, in upper camel case (at least using the style we recommend for Java--obviously there are other views on this), an acronym like ISBN should be written &quot;Isbn&quot;, in which case you get &quot;ISBN&quot; as desired. In lower camel case, it'd just be &quot;isbn&quot;.&#xA;&#xA;Whether or not we want to change the behavior is a different story, though my inclination is somewhat against it unless we're sure it's harmless to existing usages.&#xA;" date="Jun 16, 2014" owner="//@users.6"/>
      <comments text="&#xA;I know It should be the case but even java api is not consistent with acronyms in camel case (ex: URL,HttpHeaders,..). &#xA;&#xA;Forget about this, it might broke for sure existing usage, and a found a way around by having a pre-treatment where i convert acronym to real camel case using the following pattern:&#xA;  /(?&lt;=\p{Lower}|\A)(\p{Upper}+)(?=(\p{Upper}\p{Lower})|\Z)/  (groovy string)&#xA;&#xA;:)&#xA;" date="Jun 18, 2014" owner="//@users.25"/>
    </issues>
    <issues id="1786" date="Jun 20, 2014" summary="add indexOf to all immutable Set/collection" description="&#xA;As immutable Set and SortedSet cannot change, it is safe to add an indexOf method.&#xA;&#xA;I find this usefull while tryng to implement a Map with immutable keyset&#xA;" reporter="//@users.48" status="New" owner="//@users.56" labels="//@issueLabels.14 //@issueLabels.12" stars="2">
      <comments text="&#xA;If you don't need special performance characteristics for this, then you can just do set.asList().indexOf(object).&#xA;&#xA;If you do need special performance characteristics, that's a bit more of an issue: that's difficult to add without incurring performance overhead -- either CPU or memory -- for every other user of ImmutableSet, of whom the vast majority have no need for this feature.&#xA;" date="Jun 20, 2014" owner="//@users.4"/>
      <comments text="&#xA;I need performance, or i would just use a ImmutableList. I need to do a lot&#xA;of lookup, so I'm thinking about using a sorted array and the java's&#xA;binarySearch instead of a collection.&#xA;&#xA;I would use a&#xA;Il 20/giu/2014 18:31 &lt;guava-libraries@googlecode.com> ha scritto:&#xA;" date="Jun 24, 2014" owner="//@users.48"/>
      <comments text="&#xA;ImmutableSortedSet.asList().indexOf(...) already performs binary search, so if we're talking about sorted data, there's no need to roll it yourself.&#xA;" date="Jun 24, 2014" owner="//@users.43"/>
      <comments text="&#xA;The simplest way is `ImmutableSortedMap&lt;YourObject, Integer>` from which you can use the `keySet` as your `ImmutableSortedSet` and `get` for `indexOf`. If you don't care about the order, an `ImmutableHashMap` would be faster. If you need also indexed access, there's the `ImmutableBiMap`.&#xA;" date="Jun 24, 2014" owner="//@users.46"/>
      <comments text="&#xA;@cpov asList() i THINK will slow everything down, and keeping one referece&#xA;of tge asList result may non be a good idea, as this isn't immutable a lot&#xA;of things may go wrong (basically why i use immutable break).&#xA;@maaarti the idea of the Map is good, but i fear it is hiding more&#xA;complexity (one array extraction more -at least-, also i would pay&#xA;attention on the creation of Integer..very dangerous, as there is no check&#xA;on what duplicate!)&#xA;&#xA;i think the best thing to do in this case is to use an ImmutableList, as it&#xA;is compliant with the method signature from official API (only list has&#xA;indexOf) but that way it is not using binarySearch;&#xA;maybe a ImmutableSortedList witch want it's element to be Comparable,or an&#xA;ImmutableHashList wich use hashCode()&#xA;BTW i wanted this for&#xA;https://code.google.com/p/guava-libraries/issues/detail?id=1787, so if you&#xA;don't think fast immutable list value/index lookup it can be closed as nofix&#xA;&#xA;Sorry to use your precius time to solve this nobbish problem :D&#xA;&#xA;&#xA;2014-06-24 13:53 GMT+02:00 &lt;guava-libraries@googlecode.com>:&#xA;" date="Jun 24, 2014" owner="//@users.48"/>
      <comments text="&#xA;I guess, Chris' solution is better. Be assured that ImmutableWhatever.asList() gets cached and is immutable, too. However, I'd suggest to continue on SO with tag Guava, as this doesn't look as feature request anymore. Moreover, you'll get your answer even faster there.&#xA;&#xA;http://stackoverflow.com/questions/tagged/guava&#xA;" date="Jun 24, 2014" owner="//@users.46"/>
      <comments text="&#xA; asList() i THINK will slow everything down, and keeping one referece&#xA;of tge asList result may non be a good idea, as this isn't immutable a lot&#xA;of things may go wrong (basically why i use immutable break).&#xA;@maaarti the idea of the Map is good, but i fear it is hiding more&#xA;complexity (one array extraction more -at least-, also i would pay&#xA;attention on the creation of Integer..very dangerous, as there is no check&#xA;on what duplicate!)&#xA;&#xA;ImmutableSortedMap.keySet().asList() performs no &quot;array extraction,&quot; creates no boxed Integers that were not already there, and returns in constant time.  Please look up the details of the implementation: it is as cheap as you could want, and has binary-search indexOf() for free.  It's *designed* to be used in this way.&#xA;" date="Jun 24, 2014" owner="//@users.4"/>
    </issues>
    <issues id="1788" date="Jun 22, 2014" summary="Make ByteStreams.toByteArray(InputStream, int) public" description="&#xA;I'd like to suggest making the&#xA;&#xA;  ByteStreams.toByteArray(InputStream in, int expectedSize)&#xA;&#xA;method &quot;public&quot; rather than having package visibility. I'm aware that limit() and the single-argument toByteArray() methods could be combined to achieve a similar effect, but that would incur an extra array copy since toByteArray(InputStream in) uses ByteArrayOutputStream's toByteArray() method.&#xA;" reporter="//@users.23" status="New" owner="//@users.56" labels="//@issueLabels.16 //@issueLabels.2" stars="1">
      <comments text="&#xA;Out of curiosity, what are you interested in using this method for? It's primarily designed around the use case of files, where the actual number of bytes in the stream could differ from what you get when you check the length of the file beforehand (but in most cases won't). It handles the stream having both more and fewer bytes than the expected size gracefully... for other use cases, it's possible that's not the best behavior.&#xA;&#xA;Note that using limit() with toByteArray() does not have the same result: if there are more than the expected number of bytes in the stream when using limit, it will read at most the expected number of bytes, where this method will read all bytes regardless.&#xA;" date="Jun 23, 2014" owner="//@users.6"/>
      <comments text="&#xA;Dang it, you're right -- I misread the code. However, I could still use it in combination with ByteStreams.limit -- that would get me the behavior I would like, i.e. avoiding the extra copy of ByteStreams.toArray(InputStream). That would probably be too contrived as an API, though.&#xA;&#xA;Thinking a bit more about it, I think I'll probably be better off just using a customized ByteArrayOutputStream (to gain access to its internal buffer) and using ByteStreams.copy().&#xA;&#xA;Feel free to close this.&#xA;" date="Jun 23, 2014" owner="//@users.23"/>
    </issues>
    <issues id="1809" date="Jul 21, 2014" summary="InternetDomainName.topPrivateDomain() Fails on Suffix .ET - Ethiopia and .ZM - Zambia" description="&#xA;When calling topPrivateDomain() on a domain that ends with .ET - Ethiopia or .ZM - Zambia   I get an IllegalStateException stating that the domain is &quot;Not under a public suffix&quot;.&#xA;&#xA;.ET - Ethiopia and .ZM - Zambia is on the public suffix list and should return true.&#xA;" reporter="//@users.58" status="New" owner="//@users.56" stars="1">
      <comments text="&#xA;example : http://www.ethiotelecom.et&#xA;" date="Jul 21, 2014" owner="//@users.58"/>
    </issues>
    <issues id="1789" date="Jun 24, 2014" summary="Immutable supplier of ByteChannels" description="&#xA;I propose to implement something similar to Guava's ByteSource and ByteSink which would provide ReadableByteChannel and WritableByteChannel instances.&#xA;&#xA;These classes should also provide common operations such as copy data from source to sink.&#xA;&#xA;&#xA;&#xA;" reporter="//@users.24" status="New" owner="//@users.6" labels="//@issueLabels.16 //@issueLabels.2" stars="2">
      <comments text="(No comment was entered for this change.)&#xA;" date="Jun 29, 2014" owner="//@users.57"/>
    </issues>
    <issues id="1843" date="Sep 4, 2014" summary="Nullpointerexception if FluentIterable.transformAndConcat()'s function parameter is nullable" description="&#xA;i'm conflicted over the fact that Function.apply is annotated as nullable, yet this causes an exception&#xA;  &#xA; FluentIterable&lt;Object> objects = FluentIterable.from(Arrays.asList(&quot;a&quot;, &quot;b&quot;))&#xA;                .transformAndConcat(new Function&lt;String, Iterable&lt;?>>() {&#xA;                    @Nullable&#xA;                    @Override&#xA;                    public Iterable&lt;?> apply(@Nullable String input) {&#xA;                        return null;&#xA;                    }&#xA;                });&#xA;        try {&#xA;            Iterables.isEmpty(objects);&#xA;        }catch (NullPointerException e){&#xA;            System.err.println(&quot;see?&quot;);&#xA;            e.printStackTrace();&#xA;        }&#xA;    }&#xA;" reporter="//@users.0" status="New" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.12" stars="2">
      <comments text="&#xA;The intention of the @Nullable annotations on Function.apply is that implementations of Function may or may not choose to accept or return null, and to make that freedom explicit.  Interpretations of @Nullable vary, however.&#xA;&#xA;The behavior itself looks WAI for FluentIterable.transformAndConcat, though I'm not sure if we should change the documentation to make this more explicit.&#xA;" date="Sep 4, 2014" owner="//@users.50"/>
    </issues>
    <issues id="1841" date="Sep 3, 2014" summary="RegularImmutableAsList CustomFieldSerializer depends on RegularImmutableSet but did not include it into Serializationpolicy" description="&#xA;if you have a RemoteService with only 1 method and the signature:&#xA;&#xA;    void testImmutableList(ImmutableList&lt;String> list);&#xA;&#xA;and you call it with&#xA;&#xA;    testImmutableList(ImmutableSet.of(&quot;a&quot;, &quot;b&quot;).asList())&#xA;&#xA;you will get an exception:&#xA;&#xA;    com.google.gwt.user.client.rpc.SerializationException: Type 'com.google.common.collect.RegularImmutableSet' was not included in the set of types which can be deserialized by this SerializationPolicy or its Class object could not be loaded. For security purposes, this type will not be deserialized.&#xA;        at com.google.gwt.user.server.rpc.impl.StandardSerializationPolicy.validateDeserialize(StandardSerializationPolicy.java:158)&#xA;&#xA;this happens because the delegate of RegularImmutableAsList is a RegularImmutableSet which is not included into the serialization policy but is written by the RegularImmutableAsList_CustomFieldSerializer&#xA;&#xA;    writer.writeObject(instance.delegateCollection());&#xA;    writer.writeObject(instance.delegateList());&#xA;" reporter="//@users.55" status="Accepted" owner="//@users.56" labels="//@issueLabels.12" stars="2">
      <comments text="&#xA;you have to call the RemoteServiceAsync which looks like&#xA;&#xA;    testImmutableList(ImmutableSet.of(&quot;a&quot;, &quot;b&quot;).asList(), new AsyncCallbacl&lt;Void>() { ... });&#xA;" date="Sep 3, 2014" owner="//@users.55"/>
      <comments text="&#xA;That's bad :(&#xA;&#xA;The workaround is to do something like ImmutableList.copyOf(new ArrayList&lt;>(set)), but of course that's not something that we should make you do.&#xA;&#xA;Under the current GWT serialization implementation, this is hard (impossible?) to fix without requiring everyone who serializes ImmutableList to have every possible implementation available on the client side. Some clients don't like the resulting bloat. To avoid that, we'd ideally like for GWT to implement https://code.google.com/p/google-web-toolkit/issues/detail?id=8844&#xA;&#xA;A possible alternative that I've been considering is for us to have a single ImmutableList class that delegates all its implementation to an ImmutableListImpl class. This would allow us to have a single ImmutableList serializer for all ImmutableLists. The downside is indirection and extra memory on the server. It's hard to know how much that would cost. One day I hope to look into this. Until then, we're unlikely to do much here, barring new ideas. Sorry that I don't have something more immediate for you.&#xA;" date="Sep 3, 2014" owner="//@users.43"/>
      <comments text="&#xA;We have overriden the CustomFieldSerializer with our own implementation and the problem is solved.&#xA;" date="Sep 8, 2014" owner="//@users.55"/>
      <comments text="&#xA;Clever! I think we'll do it.&#xA;" date="Sep 8, 2014" owner="//@users.43"/>
      <comments text="&#xA;I'd be happy to take the revised version directly, but we'd need your legal permission:&#xA;&#xA;https://developers.google.com/open-source/cla/individual&#xA;or:&#xA;https://developers.google.com/open-source/cla/corporate&#xA;&#xA;Let me know whether you'd like to do that. Otherwise, I'll figure out what we can do to implement things from scratch.&#xA;" date="Sep 8, 2014" owner="//@users.43"/>
      <comments text="&#xA;Have you found any decision on whether the patch is something you can officially/legally contribute? Thanks.&#xA;" date="Oct 1, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1806" date="Jul 17, 2014" summary="ExceptionInInitializerError" description="&#xA;Hi,&#xA;&#xA;I've got this:&#xA;java.lang.ExceptionInInitializerError&#xA;&#x9;at com.google.common.base.Splitter.&lt;init>(SourceFile:110)&#xA;&#x9;at com.google.common.base.Splitter.on(SourceFile:174)&#xA;&#x9;at com.x.y.BaseApplication.count(SourceFile:900)&#xA;&#x9;at com.x.y.CheckNewApps.doInBackground(SourceFile:106)&#xA;&#x9;at com.x.y.CheckNewApps.doInBackground(SourceFile:1)&#xA;&#x9;at android.os.AsyncTask$2.call(AsyncTask.java:288)&#xA;&#x9;at java.util.concurrent.FutureTask.run(FutureTask.java:237)&#xA;&#x9;at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)&#xA;&#x9;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)&#xA;&#x9;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)&#xA;&#x9;at java.lang.Thread.run(Thread.java:811)&#xA;Caused by: java.lang.UnsupportedOperationException&#xA;&#x9;at com.google.common.base.CharMatcher.a(SourceFile:775)&#xA;&#x9;at com.google.common.base.CharMatcher.&lt;clinit>(SourceFile:212)&#xA;&#x9;... 11 more&#xA;&#xA;&#xA;This is the code:&#xA; public int count(String string, String substring) {&#xA;   int count=0;&#xA;   try{&#xA;&#x9;count = Iterables.size(Splitter.on(substring).split(string)) - 1;&#xA;   } catch (Exception e){&#xA;...&#xA;   }&#xA;&#xA;Yes, count = ... is the line 900?&#xA;&#xA;How can it be? It comes from Galaxy S3 4.4.4&#xA;Thanks&#xA;" reporter="//@users.38" status="New" owner="//@users.56" labels="//@issueLabels.15 //@issueLabels.7" stars="1">
      <comments text="&#xA;Guava 17.0&#xA;" date="Jul 17, 2014" owner="//@users.38"/>
      <comments text="&#xA;String parameters aren't null.&#xA;" date="Jul 17, 2014" owner="//@users.38"/>
      <comments text="&#xA;That's pretty strange. The UOE is clearly coming from here:&#xA;&#xA;  public static final CharMatcher JAVA_ISO_CONTROL =&#xA;      inRange('\u0000', '\u001f')&#xA;      .or(inRange('\u007f', '\u009f'))&#xA;      .withToString(&quot;CharMatcher.JAVA_ISO_CONTROL&quot;);&#xA;&#xA;(https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/base/CharMatcher.java?name=v17.0#212)&#xA;&#xA;But withToString is being called on a CharMatcher returned by or(...), and the Or CharMatcher definitely overrides withToString and doesn't throw UOE from it.&#xA;&#xA;Is there another version of Guava on your classpath somehow? Seems unlikely to cause this issue given that the problem here seems to be constrained to just 1 class, but probably worth checking. I also wonder if the obfuscation that appears to have been done could be causing it somehow. This obviously doesn't normally happen, as it would cause CharMatcher and anything that uses it to never work.&#xA;" date="Jul 17, 2014" owner="//@users.6"/>
      <comments text="&#xA;Hi,&#xA;I have on guava lib in the project, but I use proguard.&#xA;" date="Jul 17, 2014" owner="//@users.38"/>
      <comments text="&#xA;one guava&#xA;" date="Jul 17, 2014" owner="//@users.38"/>
      <comments text="&#xA;I have to think this is somehow caused by proguard. I wonder if it's for some reason stripping out the override of withToString from CharMatcher.Or, causing the default implementation of withToString on CharMatcher to be called?&#xA;" date="Jul 17, 2014" owner="//@users.6"/>
      <comments text="&#xA;I'm no an expert, I cannot help you :D&#xA;But if it's a proguard thing why this comes in one device? Is it possibe?&#xA;Why one device? Or it's a rare bug and it was just an accident?&#xA;" date="Jul 17, 2014" owner="//@users.38"/>
      <comments text="&#xA;I really have no idea... I don't know much about proguard myself. For Guava 17's original source code, what happened should be impossible. So at the very least I don't think this is a problem with Guava itself. What exactly is causing it, though, I'm not sure.&#xA;" date="Jul 17, 2014" owner="//@users.6"/>
      <comments text="&#xA;Is it uptodate? Seems to be a bit old&#xA;https://code.google.com/p/guava-libraries/wiki/UsingProGuardWithGuava&#xA;" date="Jul 21, 2014" owner="//@users.38"/>
    </issues>
    <issues id="1805" date="Jul 16, 2014" summary="com.google.common.collect.ImmutableCollection.Builder&lt;E> should contain a method to add an Optional&lt;E> if present" description="&#xA;&#xA;&#xA;It would be really useful if com.google.common.collect.ImmutableCollection&lt;E> contained a method of the following.&#xA;&#xA;public com.google.common.collect.ImmutableSet.Builder&lt;E> add(Optional&lt;E> element);&#xA;&#xA;and&#xA;&#xA;public com.google.common.collect.ImmutableSet.Builder&lt;E> add(Optional&lt;E>... element);&#xA;&#xA;which is adds to the builder if element.isPresent() is true.&#xA;&#xA;&#xA;If such a method existed bolier plate code like the following could be avoided&#xA;&#xA;if (element.isPresent()) {&#xA;  builder.add(element.get());&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;" reporter="//@users.32" status="New" owner="//@users.56" stars="2">
      <comments text="&#xA;You could just do&#xA;&#xA;builder.addAll(element.asSet());&#xA;&#xA;or, with Java 8's Optional, you'll be able to do&#xA;&#xA;element.ifPresent(builder::add);&#xA;" date="Jul 16, 2014" owner="//@users.50"/>
      <comments text="&#xA;&#xA;builder.addAll(element.asSet());&#xA;&#xA;Feels like smell and I am not sure if there are performance considerations of converting a single Optional value to a Set just to be added to the Builder as well.&#xA;&#xA;&#xA;Second requires use of Java 8 rather than Guava for Optional which has trade offs. Not to mention the requirement of actually using Java 8. &#xA;&#xA;Again this is a nice to have enhancement, but I feel it is so simple and practical, not to mention fits with the paradigm that I am suppressed that something like this does not exist.&#xA;&#xA;" date="Jul 16, 2014" owner="//@users.32"/>
      <comments text="&#xA;** surprised &#xA;" date="Jul 16, 2014" owner="//@users.32"/>
    </issues>
    <issues id="1840" date="Sep 2, 2014" summary="EventBus.LoggingSubscriberExceptionHandler drops an exception" description="&#xA;The handleException() method on the LoggingSubscriberExceptionHandler is called with exception.getCause(). This is fine - it returns the target exception of the InvocationTargetException.&#xA;However, the handleException() method logs this failure with exception.getCause() which than skips one exception.&#xA;&#xA;A simple workaround is to provide an own SubscriberExceptionHandler.&#xA;&#xA;Guava version 18.&#xA;" reporter="//@users.14" status="New" owner="//@users.56" labels="//@issueLabels.7 //@issueLabels.10" stars="2">
      <comments text="&#xA;Good catch. It looks like this is already fixed in some changes to EventBus for Guava 19, but we may need to consider an 18.0.1 release for this.&#xA;" date="Sep 3, 2014" owner="//@users.6"/>
    </issues>
    <issues id="1803" date="Jul 16, 2014" summary="Add abstract support superclasses for NavigableSet, NavigableMap" description="&#xA;This issue is a suggestion for some new classes, based on my own experience. Working example code is provided.&#xA;&#xA;Request #1:&#xA;&#xA;  Add support superclasses AbstractNavigableSet and AbstractNavigableMap&#xA;&#xA;Rationale:&#xA;&#xA;Creating NavigableSet and NavigableMap implementations from scratch is really tricky and error-prone, due to the sheer number of methods to implement and their semantic intersection with order reversal, optional lower &amp; upper bounds, subSet(), subMap(), etc.&#xA;&#xA;Fortunately, abstract superclasses can implement most methods in terms of others, and manage the bounds in such a way that leaves the subclass to handle the &quot;essence&quot; of the set/map.&#xA;&#xA;FWIW I've done this already and these classes could be used as an basis to start with. See https://code.google.com/p/jsimpledb/source/browse/#svn%2Ftrunk%2Fsrc%2Fjava%2Forg%2Fjsimpledb%2Futil&#xA;&#xA;Request #2:&#xA;&#xA;  Add a NavigableSet-specific implementation of Sets.intersection()&#xA;&#xA;Rationale:&#xA;&#xA;  Sets.intersection() suffers from the flaw that even if the intersection of two sets is empty, iterating their intersection takes time proportional to the size of first of the two sets given, no matter how small the second set is. Since often you won't know which set is smaller, this means you have a 50% chance of getting it badly wrong. &#xA;&#xA;  For two NavigableSets that use the same Comparator, there is a more efficient algorithm that iterates in O(N) queries, where N is the number of elements in the *smallest* of the two sets - no matter in which order they are presented.&#xA;&#xA;  In common scenarios such as iterating through key/value ranges in large datasets, this can make a huge difference.&#xA;&#xA;I also have an implementation for this intersection iteration algorithm here: https://code.google.com/p/jsimpledb/source/browse/trunk/src/java/org/jsimpledb/util/IntersectionNavigableSet.java&#xA;&#xA;&#xA;&#xA;&#xA;" reporter="//@users.26" status="New" owner="//@users.56" labels="//@issueLabels.14 //@issueLabels.12" stars="2">
      <comments text="&#xA;Please file these as separate requests.&#xA;" date="Jul 16, 2014" owner="//@users.50"/>
      <comments text="&quot;Add a NavigableSet-specific implementation of Sets.intersection()&quot; filed as  issue #1804 .&#xA;&#xA;" date="Jul 16, 2014" owner="//@users.26"/>
    </issues>
    <issues id="1792" date="Jun 25, 2014" summary="FileBackedOutputStream can leak open files on IO error" description="&#xA;In https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/io/FileBackedOutputStream.java#203, if there is a file IO error when transferring to an on-disk buffer we'll leak the temp file (if resetOnFinalize is false) and will leak an open file handle until the finalizer for FileOutputStream happens to run.   &#xA;" reporter="//@users.31" status="New" owner="//@users.6" labels="//@issueLabels.7 //@issueLabels.2" stars="1">
      <comments text="&#xA;I think this is a duplicate of #1664 (or at the very least closely related to).&#xA;" date="Jun 27, 2014" owner="//@users.29"/>
      <comments text="(No comment was entered for this change.)&#xA;" date="Jun 29, 2014" owner="//@users.57"/>
    </issues>
    <issues id="1791" date="Jun 25, 2014" summary="Double.POSITIVE_INFINITY seems to poison the com.google.common.util.concurrent.RateLimiter" description="&#xA;Once a RateLimiter is configured with permitsPerSecond == Double.POSITIVE_INFINITY, it can never deliver a non-infinite rate. Tested on Guava 17.0.&#xA;&#xA;Test case:&#xA;&#xA;public static void main(String[] args) {&#xA;        RateLimiter rateLimiter = RateLimiter.create(Double.POSITIVE_INFINITY);&#xA;        final double permitsPerSecond = 1.0;&#xA;        rateLimiter.setRate(permitsPerSecond);&#xA;        final long l = System.currentTimeMillis();&#xA;        final int totalPermits = 60;&#xA;        final int permitsEachTime = 1;&#xA;        for (int i = 0; i &lt; totalPermits; i++) {&#xA;            rateLimiter.acquire(permitsEachTime);&#xA;            System.out.print(i + &quot;,&quot;);&#xA;        }&#xA;        final double seconds = 1.0 * (System.currentTimeMillis() - l) / 1000;&#xA;        System.out.println();&#xA;        System.out.println(seconds);&#xA;        System.out.println((totalPermits / permitsPerSecond));&#xA;    }&#xA;&#xA;The behavior should be that it prints out the numbers about once a second and then prints the two &quot;seconds&quot; metrics roughly in agreement, like &#xA;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,&#xA;59.0&#xA;60.0&#xA;&#xA;When the rate limiter is initialized with a non-infinite value (like 10.0), we see the desired behavior.&#xA;&#xA;What the code above actually produces is:&#xA;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,&#xA;0.002&#xA;60.0&#xA;&#xA;showing that the limiter is still issuing permits at an infinite rate.&#xA;&#xA;&#xA;The culprit seems to be this code:&#xA;in com.google.common.util.concurrent.RateLimiter.Bursty#doSetRate&#xA;    storedPermits = (oldMaxPermits == 0.0)&#xA;          ? 0.0 // initial state&#xA;          : storedPermits * maxPermits / oldMaxPermits;&#xA;once the rate has been set to infinity, we also have an infinite number of stored permits, as well as an infinite number of oldMaxPermits. This division yields NaN, which then goes on to ensure that com.google.common.util.concurrent.RateLimiter#reserveNextTicket will return 0 micros to wait.&#xA;&#xA;It seems you may want to look at the whole rateLimiter with infinity in mind. Infinity is a reasonable value to configure a rate limiter with, so I think you should continue to accept it, but there may be other places where the math requires special handling of Infinity.&#xA;&#xA;Let me know if I can help.&#xA;&#xA;Thanks,&#xA;-John&#xA;" reporter="//@users.15" status="Accepted" owner="//@users.43" labels="//@issueLabels.7 //@issueLabels.0" stars="1">
      <comments text="&#xA;Interesting. The test method testInfinity_Bursty() is supposed to check this, but it must miss some case that your test catches. I'll look into it.&#xA;" date="Jun 25, 2014" owner="//@users.43"/>
      <comments text="&#xA;It looks like the test doesn't catch this because no time elapses between the creation and the changing of the rate. As soon as I tell the fake stopwatch that time has elapsed, things go haywire.&#xA;" date="Jun 25, 2014" owner="//@users.43"/>
      <comments text="&#xA;For a fix, I think we can get by with the same test as SmoothWarmingUp.doSetRate has. I don't have 100% confidence in that -- in particular, I can imagine that it's possible for maxPermits or another computed value to overflow to POSITIVE_INFINITY in another way -- but based on the facts that (a) SmoothWarmingUp is set up for this and (b) we had tests for this, I suspect that we'd given at least a passing thought to infinite-rate RateLimiters before.&#xA;&#xA;Thanks for the report. I'll post again when the fix is submitted.&#xA;" date="Jun 25, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1800" date="Jul 10, 2014" summary="Helper for sorting nested nullable properties" description="&#xA;I have been implementing `Ordering`s/Comparators/Comparables of nested properties and everytime I do this I get tired of all the null checks to handle ordering of nullable nested propertys. Currently Guava does not help me here.&#xA;&#xA;Example code I'm tired of:&#xA;&#xA;public int compare(MyProperty left, MyProperty right) {&#xA;  if (left.getSubProperty() == null || right.getSubProperty()) {&#xA;    return 0;&#xA;  }&#xA;  if (left.getSubProperty().getSubSubProperty() == null || right.getSubProperty().getSubSubProperty() == null) {&#xA;    return 0;&#xA;  }&#xA;  return ComparisonChain.start().compare(left.getSubProperty().getSubSubProperty().value(), right.getSubProperty().getSubSubProperty().value()).result();&#xA;}&#xA;&#xA;If I'd like to order by null value it gets even worse:&#xA;&#xA;public int compare(MyProperty left, MyProperty right) {&#xA;  if (left.getSubProperty() == null || right.getSubProperty()) {&#xA;    return ComparisonChain.start().compare(left.getSubProperty(), right.getSubProperty()).result();&#xA;  }&#xA;  if (left.getSubProperty().getSubSubProperty() == null || right.getSubProperty().getSubSubProperty() == null) {&#xA;    return ComparisonChain.start().compare(left.getSubProperty().getSubSubProperty(), right.getSubProperty().getSubSubProperty()).result();&#xA;  }&#xA;  return ComparisonChain.start().compare(left.getSubProperty().getSubSubProperty().value(), right.getSubProperty().getSubSubProperty().value()).result();&#xA;}&#xA;&#xA;Two proposed solutions: https://gist.github.com/JensRantil/3063132784a0945dc6f0&#xA;&#xA;I am leaning towards Example2 and have started using it in my code. I'd love to hear about other solutions.&#xA;" reporter="//@users.13" status="New" owner="//@users.56" labels="//@issueLabels.16" stars="2">
      <comments text="&#xA;FWIW, your first Comparator doesn't satisfy the contract: it's not transitive, since something with a getSubProperty() == null compares as equal to everything, but not everything is equal to everything else.&#xA;&#xA;As far as your approaches go, exceptions of any kind are usually a nasty performance killer, so I'd be concerned about approach 2.  Approach 1 is somewhat interesting, but a bit difficult to follow.&#xA;&#xA;In Java 8, you could do something quite short and neat here:&#xA;&#xA;import static java.util.Comparator.*;&#xA;&#xA;   Comparator&lt;MyProperty> comparator = comparing(MyProperty::getSubProperty,&#xA;     nullsFirst(comparing(SubProperty::getSubSubProperty,&#xA;       nullsFirst(comparing(SubSubProperty::value)))));&#xA;" date="Jul 10, 2014" owner="//@users.4"/>
      <comments text="&#xA;Hey,&#xA;&#xA;Thanks for feedback! As for the non-transitiveness it was simply a typo (and cope-pasty error). Apologize for that.&#xA;&#xA;I did not know about exceptions being a performance killer. That's unfortunate, because I really liked that solution!&#xA;&#xA;The idea with example 1 is to have a helper class with the following purposes:&#xA; - to minimize repetition of the values being compared. They are only needed at instantiation and will thus minimize repetition (which is similar goad with other comparison helpers in Guava).&#xA; - easily check if any of the values are null.&#xA; - easily sort based on nulls.&#xA;&#xA;Thinking about this I also realized there's a third solution that does not require any of my helper classes/methods:&#xA;&#xA;ComparisonChain chain = ComparisonChain.start();&#xA;try {&#xA;    chain = chain.compare(left.getSubProperty(), right.getSubProperty());&#xA;    chain = chain.compare(left.getSubProperty().getSubSubProperty(), right.getSubProperty().getSubSubProperty());&#xA;    chain = chain.compare(left.getSubProperty().getSubSubProperty().value(), right.getSubProperty().getSubSubProperty().value());&#xA;catch (NullPointerException e) {&#xA;    return chain.result();&#xA;}&#xA;&#xA;This obviously would use exceptions, too, but [1] hints that exceptions thrown and caught within the same method is performant and effectively handled by a goto[2]. Then there's the debate of catching NullpointerExceptions...&#xA;&#xA;I'd love to hear your opinion and whether there's an Guava-idiomatic way of doing these kind of comparisons.&#xA;&#xA;[1] http://stackoverflow.com/a/299315/260805&#xA;[2] ..although, I haven't benchmarked this myself.&#xA;" date="Jul 12, 2014" owner="//@users.13"/>
      <comments text="&#xA;To reduce duplication, could you extract a method that pulls out the sub-sub value (or null)? Then you could call it on each input and compare the values. Or, at that point, you could use Ordering.onResultOf:&#xA;&#xA;private static Ordering&lt;MyProperty> ORDER = Ordering.natural().nullsFirst().onResultOf(&#xA;    new Function&lt;MyProperty, SubSubProperty>() {&#xA;      @Override public SubSubProperty getSubSubProperty(MyProperty property) {&#xA;        return (property.getSubProperty() == null || property.getSubProperty().getSubSubProperty() == null)&#xA;            ? null&#xA;            : property.getSubProperty().getSubSubProperty().value();&#xA;      }&#xA;    };&#xA;&#xA;There's less duplication, but there's still a bunch of boilerplate. I'd be happy to hear better suggestions, but I'm not sure how much better we'll do without Louis's Java 8 suggestion.&#xA;" date="Jul 16, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1849" date="Sep 17, 2014" summary="Hashing support for bcrypt" description="&#xA;Please support bcrypt in com.google.common.hash.Hashing&#xA;&#xA;http://en.wikipedia.org/wiki/Bcrypt&#xA;&#xA;&quot;A Future-Adaptable Password Scheme&quot; by Niels Provos and David Mazieres (USENIX, 1999)&#xA;http://www.openbsd.org/papers/bcrypt-paper.ps&#xA;" reporter="//@users.27" status="New" owner="//@users.56" labels="//@issueLabels.13 //@issueLabels.16" stars="3">
      <comments text="&#xA;No one should be using bcrypt for hash tables, which is what Hashing is for.&#xA;" date="Sep 24, 2014" owner="//@users.21"/>
      <comments text="&#xA;Hashing is not only (or even primarily) for hash tables: https://code.google.com/p/guava-libraries/wiki/HashingExplained&#xA;" date="Sep 24, 2014" owner="//@users.6"/>
      <comments text="&#xA;Bcrypt is one of the three good password hashing schemes -- md5() or sha256() are outdated and insecure.&#xA;&#xA;https://password-hashing.net&#xA;&#xA;http://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage&#xA;&#xA;http://codahale.com/how-to-safely-store-a-password/&#xA;" date="Sep 24, 2014" owner="//@users.27"/>
      <comments text="> sha256() are outdated and insecure.&#xA;&#xA;That's pure nonsense. SHA-256 is still rather modern (SHA-3 is out, but it'll take years) and secure HASH FUNCTION.&#xA;&#xA;bcrypt is NO hash function, it's a key derivation function. Using hash functions as a KDF is insecure, no matter how good the function.&#xA;&#xA;A KDF is no com.google.common.hash.HashFunction as it always needs a salt. This is can be an additional input[1] or generated randomly[2]. Fitting it to the interface by fixing an argument would be a very stupid idea. Allowing a hash function to behave randomly would be no smarter.&#xA;&#xA;I'm not saying that it doesn't belong to Guava, I'm just saying that it doesn't belong to the hash package. No HF is a KDF and vice versa.&#xA;&#xA;[1]:&#xA;http://docs.spring.io/autorepo/docs/spring-security/3.1.7.RELEASE/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html&#xA;[2]:&#xA;https://github.com/wg/scrypt/blob/master/src/main/java/com/lambdaworks/crypto/SCrypt.java&#xA;" date="Sep 24, 2014" owner="//@users.46"/>
    </issues>
    <issues id="1847" date="Sep 13, 2014" summary="In Guava 18, MapMaker.makeComputingMap scope has changed, but it's referenced from Guice 4 Beta4" description="&#xA;java.lang.IllegalAccessError: tried to access method com.google.common.collect.MapMaker.makeComputingMap(Lcom/google/common/base/Function;)Ljava/util/concurrent/ConcurrentMap; from class com.google.inject.internal.Annotations$AnnotationChecker&#xA;at com.google.inject.internal.Annotations$AnnotationChecker.(Annotations.java:104)&#xA;at com.google.inject.internal.Annotations.(Annotations.java:122)&#xA;at com.google.inject.spi.InjectionPoint.(InjectionPoint.java:94)&#xA;at com.google.inject.spi.InjectionPoint$InjectableField.toInjectionPoint(InjectionPoint.java:440)&#xA;at com.google.inject.spi.InjectionPoint.getInjectionPoints(InjectionPoint.java:725)&#xA;at com.google.inject.spi.InjectionPoint.forInstanceMethodsAndFields(InjectionPoint.java:358)&#xA;at com.google.inject.spi.InjectionPoint.forInstanceMethodsAndFields(InjectionPoint.java:377)&#xA;at com.google.inject.internal.BindingBuilder.toInstance(BindingBuilder.java:84)&#xA;&#xA;I know the method is marked as deprecated, but changing it's scope has resulted in other libraries with dependencies on it that haven't been updated; including Guice.&#xA;" reporter="//@users.20" status="New" owner="//@users.56" stars="2">
      <comments text="&#xA;Cross reference Guice issue: https://github.com/google/guice/issues/846&#xA;" date="Sep 13, 2014" owner="//@users.20"/>
    </issues>
    <issues id="1848" date="Sep 15, 2014" summary="Improve Joiner#join documentation and exception message for null behavior" description="&#xA;I'm not sure whether it is an actual bug so I formulated the subject as a question, but I think that if some instances of Joiner (namely those not generated from skipNulls() or useForNull(String)) don't support null arguments and explicitly throw an NPE the parameters of the Joiner#join() method shouldn't be annotated @Nullable.&#xA;&#xA;I also think having a subtype of Joiner (something like NullSupportedJoiner) just for this wouldn't make sense, so if this is done to prevent unnecessary static analysis warnings on Joiner#join() method calls with possibly null parameter values, I would suggest that it at least is added to the documentation of the join() method (that the Joiner instance needs to support null values for the parameters to be nullable).&#xA;It IS explained in the javadoc of the class but it's easy to miss when just looking at the method documentation (e.g. from an IDE).&#xA;&#xA;Throwing a more explicit error (e.g. adding a message about &quot;skipNulls()&quot; call requirement to the thrown NPE) may also be a nice way to document this requirement.&#xA;&#xA;Let me know if I misunderstood something.&#xA;" reporter="//@users.12" status="New" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.15" stars="2">
      <comments text="&#xA;I think we take the position that a parameter has to be @Nullable if *any* implementation of the type permits nulls there. This is certainly not ideal. (It's also not ideal that I'm not 100% sure that I have our policy right.) For general despair around the issue of nullability annotations, see issue 1812.&#xA;&#xA;For this specific case, we can be more optimistic. We can improve the error message and the doc. I'm modifying this bug's title to focus on that.&#xA;" date="Sep 18, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1870" date="Today (4 hours ago)" summary="Maps.unmodifiableNavigableMap not covariant in V" description="&#xA;Maps.unmodifiableNavigableMap is declared as follows:&#xA;&#xA;&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, V> map);&#xA;&#xA;this could be changed to &#xA;&#xA;&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V> map);&#xA;&#xA;as there are no methods in NavigableMap that take a V as a method parameter. This would also be consistent with the declarations of Collections.unmodifiableSortedMap and ImmutableSortedMap.copyOfSorted.&#xA;" reporter="//@users.5" status="New" owner="//@users.56" labels="//@issueLabels.12 //@issueLabels.14" stars="1"/>
    <issues id="1831" date="Aug 12, 2014" summary="RangeSet does not document concurrent modification of asRanges()" description="&#xA;RangeSet#asRanges() document how changes to the set are propagated to the inherited set. Is the asRanges() result immutable? Are changes propagated? Or are concurrent modifications not allowed?&#xA;" reporter="//@users.13" status="New" owner="//@users.56" labels="//@issueLabels.8 //@issueLabels.12" stars="2">
      <comments text="&#xA;Eh, sorry should have been &quot;RangeSet#asRanges() _does not_ document&quot;. I was a bit too quick there..&#xA;" date="Aug 12, 2014" owner="//@users.13"/>
      <comments text="&#xA;Looks like it all boils down to a call to SortedMap#values() whose result has undefined behaviour when the map is modified.&#xA;" date="Aug 12, 2014" owner="//@users.13"/>
    </issues>
    <issues id="1832" date="Aug 12, 2014" summary="Canonicalize a whole RangeSet at once" description="&#xA;I recently noticed/realized that RangeSets over discrete numbers aren't fully reduced. I fully understand why this happens (to handle continuous ranges, such as Floats), however there are cases when it would be really useful to fully reduce a discrete RangeSet. My current use case I'd like to summarize/log a bunch of Long IDs that am storing in a database. Adding `Range#singleton`s will not suffice since the ranges aren't reduced.&#xA;&#xA;To workaround this, I wrote a piece of code that does exactly this:&#xA;&#xA;&#xA;    private void reduceRangeSet(RangeSet&lt;Long> rangeSet) {&#xA;        restart: while (true) {&#xA;            Set&lt;Range&lt;Long>> ranges = rangeSet.asRanges();&#xA;            if (ranges.size() &lt;= 1)&#xA;                break;&#xA;            Range&lt;Long> prevRange = null;&#xA;            for (Range&lt;Long> range : ranges) {&#xA;                if (prevRange != null &amp;&amp; range.contains(range.lowerEndpoint()) // Takes care of checking open/close range end&#xA;                        &amp;&amp; prevRange.contains(range.lowerEndpoint() - 1)) {&#xA;                    rangeSet.add(Range.closedOpen(range.lowerEndpoint() - 1, range.lowerEndpoint()));&#xA;                    &#xA;                    // Must restart outer loop since rangeSet.asRanges() might not update on changes.&#xA;                    continue restart;&#xA;                }&#xA;                prevRange = range;&#xA;            }&#xA;            &#xA;            // If we came here we found nothing to reduce.&#xA;            break;&#xA;        }&#xA;    }&#xA;&#xA;The code does it's job for me, but I suggest it's rewritten to not use nested loops if possible.&#xA;&#xA;A proposal would be to add something similar to maybe &quot;RangeSets.reduce(RangeSet&lt;Long> ...&quot; and possibly also add &quot;RangeSets.reduce(RangeSet&lt;Integer> ...&quot; and maybe even &quot;RangeSets.reduce(RangeSet&lt;Byte> ...&quot;.&#xA;" reporter="//@users.13" status="Research" owner="//@users.56" labels="//@issueLabels.16 //@issueLabels.12" stars="3">
      <comments text="&#xA;It's not clear to me why you'd use this approach, or why you'd special-case for all these types.  The idea is intended to be that you call Range.canonical(DiscreteDomain), passing in the appropriate DiscreteDomain for your type, before adding or removing it from the RangeSet.  &#xA;&#xA;If you canonicalize all Ranges you use to modify your RangeSet, your RangeSet should only contain canonical ranges no matter how ranges get merged, subtracted, etc.&#xA;&#xA;Is there a reason that solution doesn't work for you?&#xA;" date="Aug 12, 2014" owner="//@users.50"/>
      <comments text="&#xA;Ignorant question: would it make any sense to add a canonicalize(DiscreteDomain) method to RangeSet, which would basically replace every Range in the set with its canonical version? Maybe that would result in a different set of ranges than you'd get if you only added canonical ranges to the set in the first place?&#xA;" date="Aug 12, 2014" owner="//@users.6"/>
      <comments text="&#xA;lowas: Did not know about canonical. It solved my issue. In my case calling canonical for every add is a better solution as I'm using RangeSet to reduce memory pressure.&#xA;&#xA;cgdecker: A canonicalize method is, after my fix, not necessary. So far, I have not had a use case for that now that I know of canonical form of a Range.&#xA;" date="Aug 15, 2014" owner="//@users.13"/>
      <comments text="&#xA;I love the happy resolution to your problem.&#xA;&#xA;Let's keep this open to consider the value of a RangeSet canonicalization function.&#xA;" date="Aug 15, 2014" owner="//@users.41"/>
    </issues>
    <issues id="1838" date="Aug 25, 2014" summary="missing functionality in CacheStats" description="&#xA;&#xA;Hi,&#xA;&#xA;it looks like CacheStats is missing putCount, which makes statistics not complete if you have situations where cache is populated by load and explicit put.&#xA;&#xA;An possible implementation can be found at:&#xA;&#xA;https://code.google.com/r/kofemann-kofemann-cache-with-put-count/source/detail?r=4810e0e85ea406b0e23324f0379351a23f8eb514&#xA;&#xA;-k&#xA;" reporter="//@users.3" status="New" owner="//@users.50" labels="//@issueLabels.14 //@issueLabels.4" stars="3">
      <comments text="(No comment was entered for this change.)&#xA;" date="Aug 25, 2014" owner="//@users.57"/>
    </issues>
    <issues id="1839" date="Aug 29, 2014" summary="Overloaded versions of Ints/Longs.tryParse with a radix" description="&#xA;Please add these overloaded methods:&#xA;&#xA;Ints.tryParse(String s, int radix)&#xA;Longs.tryParse(String s, int radix)&#xA;&#xA;That way, Ints/Longs.tryParse could be used as drop-in replacements both String versions of Integer/Long.valueOf&#xA;&#xA;Another thing worth thinking about would be to add similar methods that return Optional&lt;Integer / Long>, forcing client code to actually react on the changed semantics of using tryParse rather than valueOf. Of course the question of how to name these methods is a nasty one. tryParse would've been a perfect naming choice for that&#xA;" reporter="//@users.52" status="New" owner="//@users.50" labels="//@issueLabels.16 //@issueLabels.1" stars="2">
      <comments text="(No comment was entered for this change.)&#xA;" date="Aug 29, 2014" owner="//@users.6"/>
      <comments text="&#xA;Did we have any reservations that tryParse(&quot;foo&quot;, 10) might look like it's providing a default value rather than a radix? I forget.&#xA;&#xA;(We did give some thought to Optional&lt;Integer> and so forth. Our reasoning for sticking with Integer was that the method was intended to be fast. But it's not clear cut. For example, and extreme version of that reasoning could have led to our choosing to return |long| with an out-of-int-bounds value used to indicate invalid inputs. We could also have introduced OptionalInteger/OptionalLong classes.)&#xA;" date="Aug 29, 2014" owner="//@users.43"/>
    </issues>
    <issues id="1835" date="Aug 19, 2014" summary="ImmutableSortedSet with 1 non-Comparable element" description="&#xA;Creating a singleton immutable sorted set by calling of() with a non-Comparable object is not allowed (via &quot;FauxverideShim&quot;). However, one can be created by first instantiating a single element Collection and creating a copyOf() it.&#xA;&#xA;Example (throws Exception):&#xA;  Object notComparable = new Object();&#xA;  ImmutableSortedSet.of(notComparable);&#xA;&#xA;Example (works):&#xA;  Object notComparable = new Object();&#xA;  ImmutableSortedSet.copyOf(ImmutableSet.of(notComparable));&#xA;&#xA;I submit that they should both work or both fail. While technically a singleton non-comparable SortedSet violates the SortedSet contract (&quot;All elements inserted into a sorted set must implement the Comparable interface&quot;), it make senses to me that an immutable SortedSet of 1 element could be an exception (and thus not throw an Exception). In fact, TreeSet does not fail with a single non-Comparable element:&#xA;&#xA;  SortedSet&lt;Object> sortedSet = new TreeSet&lt;Object>();&#xA;  sortedSet.add(notComparable);&#xA;" reporter="//@users.39" status="Accepted" owner="//@users.56" labels="//@issueLabels.7 //@issueLabels.12" stars="2">
      <comments text="&#xA;Nice find. I believe we should make copyOf fail.&#xA;&#xA;I believe the TreeSet bug you mention is finally fixed for JDK 8.&#xA;" date="Aug 20, 2014" owner="//@users.41"/>
      <comments text="&#xA;I checked and you're correct that the TreeSet bug is fixed (in a Java 7 release). For enterprise (read too boring to enumerate here) reasons, we're still on a late build of Java 6. I retract my final comment and agree with your assessment.&#xA;" date="Aug 20, 2014" owner="//@users.39"/>
    </issues>
    <issues id="1837" date="Aug 23, 2014" summary="Probable EventBus memory leak when shared class loader used" description="&#xA;Hi,&#xA;&#xA;I am having Guava loaded by shared classloader inside Tomcat and every webapp can register into static singleton EventBus waiting to incoming events. Problem is that it looks like that EventBus from shared classloader is unable to free registered methods when webapp is undeployed.&#xA;&#xA;I have attached test case with workaround and probable fix when LoadingCache uses weakKeys with weakValues.&#xA;&#xA;Could you look at it - code will tell you more. You can build test case with Guava 14 and 17 (Maven profile) when symptoms are the same. &#xA;&#xA;Thx&#xA;Ivos&#xA;&#xA;&#xA;*Test case 1*&#xA;{{{Using Guava version 17.0&#xA;class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@1d6535bf&#xA;class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@1d6535bf&#xA;--- start ---&#xA;Test using ordinary Guava&#xA;class guava.Callback loaded by java.net.URLClassLoader@25b0eadd&#xA;class guava.Callback$Event loaded by java.net.URLClassLoader@25b0eadd&#xA;onEvent(guava.Callback$Event@edea70b)&#xA;&#x9;Callback&#x9;java.net.URLClassLoader@25b0eadd&#xA;&#x9;Event&#x9;&#x9;java.net.URLClassLoader@25b0eadd&#xA;--- end ---&#xA;Loading cache result {class guava.Callback=[public void guava.Callback.onEvent(guava.Callback$Event)]}&#xA;=== Memory leak detected? ===}}}&#xA;&#xA;*Test case 2*&#xA;_Note: take a look at inconsistency message_&#xA;{{{Using Guava version 17.0&#xA;class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;--- start ---&#xA;Test with weak values loading cache&#xA;class com.google.common.cache.LocalCache$LocalLoadingCache loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;class guava.Callback loaded by java.net.URLClassLoader@1f4cc34b&#xA;class guava.Callback$Event loaded by java.net.URLClassLoader@1f4cc34b&#xA;onEvent(guava.Callback$Event@c063ed4)&#xA;&#x9;Callback&#x9;java.net.URLClassLoader@1f4cc34b&#xA;&#x9;Event&#x9;&#x9;java.net.URLClassLoader@1f4cc34b&#xA;--- end ---&#xA;Loading cache result {}&#xA;=== Memory leak detected? ===&#xA;Inconsistent .toString({}) and .size(1) when LoadingCache.asMap() called ???}}}&#xA;&#xA;*Test case 3*&#xA;{{{Using Guava version 17.0&#xA;class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@5fab9dac&#xA;--- start ---&#xA;Test with loading cache invalidation workaround&#xA;class guava.Callback loaded by java.net.URLClassLoader@f785762&#xA;class guava.Callback$Event loaded by java.net.URLClassLoader@f785762&#xA;onEvent(guava.Callback$Event@2aae2481)&#xA;&#x9;Callback&#x9;java.net.URLClassLoader@f785762&#xA;&#x9;Event&#x9;&#x9;java.net.URLClassLoader@f785762&#xA;--- end ---&#xA;Loading cache result {} }}}&#xA;&#xA;" reporter="//@users.17" status="New" owner="//@users.56" labels="//@issueLabels.14 //@issueLabels.10" stars="3">
      <comments text="&#xA;I guess this is caused by the static members of `SubscriberRegistry`: `flattenHierarchyCache` and `subscriberMethodsCache`. They use `weakKeys`, but this seems to be of no use at all, because of the strong value references. In your example, an entry linking `Callback.class` to `ImmutableList.of(Callback#onEvent)` gets created, and the method strongly references its class, so nothing can be GC'ed.&#xA;" date="Aug 27, 2014" owner="//@users.46"/>
      <comments text="&#xA;I know why it is caused :-) . Anyways thanks for summarization...&#xA;" date="Aug 27, 2014" owner="//@users.17"/>
      <comments text="&#xA;I'm not sure what can be done about this. In the flattenHierarchyCache case (used for event types), I think we could safely store the values in WeakReferences. In the subscriberMethodsCache, I'm pretty sure we can't, because Class always returns *copies* of the Method objects. In other words, if we store WeakReferences to the Methods, nothing will be strongly referencing those Method objects and they'll just get GC'ed, meaning we aren't really caching anything. And just not caching the Methods seems like it could have a significant performance impact.&#xA;&#xA;As an aside, I don't feel like using a shared EventBus to communicate between separate web applications is a good idea. In particular, I'd be concerned about things like different applications loading the &quot;same&quot; class with different classloaders. There are other tools that are better suited for what is effectively interprocess communication.&#xA;" date="Aug 30, 2014" owner="//@users.6"/>
      <comments text="> nothing will be strongly referencing those Method objects&#xA;&#xA;I'd say, as long as they're used in an `EventBus`, their `Subscriber`s will. But if they're not, then they can be GC'd even when their classes are loaded and this is AFAIK unsolvable without ephemerons.&#xA;&#xA;And you'd have to use `ImmutableList&lt;WeakReference&lt;Method>>` which means that you could get an incomplete method list from the cache. Surely solvable, but ugly.&#xA;&#xA;Anyway, using `weakKeys` in the current design doesn't help at all, does it?&#xA;&#xA;A minor optimization: I guess `getAnnotatedMethodsNotCached` could use `flattenHierarchyCache` instead of `TypeToken.of(clazz).getTypes().rawTypes()`.&#xA;&#xA;" date="Aug 30, 2014" owner="//@users.46"/>
      <comments text="> I'd say, as long as they're used in an `EventBus`, their `Subscriber`s will. But if they're not, then they can be GC'd even when their classes are loaded and this is AFAIK unsolvable without ephemerons.&#xA;&#xA;True, though if you've got a class that is subscribed and unsubscribed repeatedly it's not really helping.&#xA;&#xA;> And you'd have to use `ImmutableList&lt;WeakReference&lt;Method>>` which means that you could get an incomplete method list from the cache. Surely solvable, but ugly.&#xA;&#xA;Actually, if the Methods are being thrown into WeakReferences in the CacheLoader, they wouldn't have any strong references left even before the call to LoadingCache.get that loads them completes. Which makes it sound like it's possible that you might *never* get a complete list of Methods back. &#xA;&#xA;> Anyway, using `weakKeys` in the current design doesn't help at all, does it?&#xA;&#xA;No, not really.&#xA;&#xA;> A minor optimization: I guess `getAnnotatedMethodsNotCached` could use `flattenHierarchyCache` instead of `TypeToken.of(clazz).getTypes().rawTypes()`.&#xA;&#xA;It could, but I don't feel like it's really an optimization at all given that the result of getAnnotatedMethodsNotCached is cached itself. Right now, that TypeToken.of(clazz).getTypes().rawTypes() should only be called once per class anyway, so we'd be caching the result for no reason. (And I think it's very unlikely that there would be any overlap between the current usage of flattenHiearchyCache and this, since currently it's only used for event classes, while this would be using it for subscriber classes.) If we weren't caching the result, that would be a different story.&#xA;" date="Aug 30, 2014" owner="//@users.6"/>
      <comments text="&#xA;I think that good enought solution would be having flush cache methods on EventBus (or on AnnotatedSubscriberFinder) like JavaBeans Introspector have. &#xA;&#xA;java.beans.Introspector#flushCaches()&#xA;java.beans.Introspector#flushFromCaches(Class&lt;?>)&#xA;&#xA;Btw. In my design I have MyEvent classes loaded by same shared classloader which loads Guava. And shared event classes refer to classes from same shared classloader or from parent class loaders.&#xA;" date="Aug 31, 2014" owner="//@users.17"/>
    </issues>
  </issueTracker>
  <issueLabels name="Package-Concurrent"/>
  <issueLabels name="Package-Primitives"/>
  <issueLabels name="Package-IO"/>
  <issueLabels name="Type-Performance"/>
  <issueLabels name="Package-Cache"/>
  <issueLabels name="Milestone-Release19"/>
  <issueLabels name="Package-Reflect"/>
  <issueLabels name="Type-Defect"/>
  <issueLabels name="Type-ApiDocs"/>
  <issueLabels name="Package-General"/>
  <issueLabels name="Package-EventBus"/>
  <issueLabels name="Package-Testing"/>
  <issueLabels name="Package-Collect"/>
  <issueLabels name="Package-Hash"/>
  <issueLabels name="Type-Enhancement"/>
  <issueLabels name="Package-Base"/>
  <issueLabels name="Type-Addition"/>
  <users email="rob.maxw...@gmail.com" id="rob.maxw...@gmail.com"/>
  <users email="jens.neh...@gmail.com" id="jens.neh...@gmail.com"/>
  <users email="qi.c...@ocado.com" id="qi.c...@ocado.com"/>
  <users email="kofem...@gmail.com" id="kofem...@gmail.com"/>
  <users email="wasserman.louis" id="wasserman.louis"/>
  <users email="thecoop1...@googlemail.com" id="thecoop1...@googlemail.com"/>
  <users email="cgdecker@google.com" id="cgdecker@google.com"/>
  <users email="fry@google.com" id="fry@google.com"/>
  <users email="dharkn...@gmail.com" id="dharkn...@gmail.com"/>
  <users email="greg.mar...@elasticsearch.com" id="greg.mar...@elasticsearch.com"/>
  <users email="tomas.za...@gmail.com" id="tomas.za...@gmail.com"/>
  <users email="anth...@whitford.com" id="anth...@whitford.com"/>
  <users email="legrand....@gmail.com" id="legrand....@gmail.com"/>
  <users email="jens.ran...@tink.se" id="jens.ran...@tink.se"/>
  <users email="stefan.l...@gmail.com" id="stefan.l...@gmail.com"/>
  <users email="jroes...@gmail.com" id="jroes...@gmail.com"/>
  <users email="andrew.m...@threewide.com" id="andrew.m...@threewide.com"/>
  <users email="bedla.cz...@gmail.com" id="bedla.cz...@gmail.com"/>
  <users email="daniil.g...@gmail.com" id="daniil.g...@gmail.com"/>
  <users email="dpletc...@google.com" id="dpletc...@google.com"/>
  <users email="cl...@magicalspirits.net" id="cl...@magicalspirits.net"/>
  <users email="tavianator@gmail.com" id="tavianator@gmail.com"/>
  <users email="christia...@gmail.com" id="christia...@gmail.com"/>
  <users email="bardur.a...@gmail.com" id="bardur.a...@gmail.com"/>
  <users email="paolo.fu...@gmail.com" id="paolo.fu...@gmail.com"/>
  <users email="abecc...@mantano.com" id="abecc...@mantano.com"/>
  <users email="archie.c...@gmail.com" id="archie.c...@gmail.com"/>
  <users email="sebastia...@gmail.com" id="sebastia...@gmail.com"/>
  <users email="venkates...@gmail.com" id="venkates...@gmail.com"/>
  <users email="b...@cwconsult.dk" id="b...@cwconsult.dk"/>
  <users email="j...@nwsnet.de" id="j...@nwsnet.de"/>
  <users email="adam.h...@gmail.com" id="adam.h...@gmail.com"/>
  <users email="anderson...@gmail.com" id="anderson...@gmail.com"/>
  <users email="fabian.z...@gmail.com" id="fabian.z...@gmail.com"/>
  <users email="crai...@microsoft.com" id="crai...@microsoft.com"/>
  <users email="arg...@gmail.com" id="arg...@gmail.com"/>
  <users email="luke.ush...@gmail.com" id="luke.ush...@gmail.com"/>
  <users email="be...@google.com" id="be...@google.com"/>
  <users email="smrtprj...@gmail.com" id="smrtprj...@gmail.com"/>
  <users email="tadam...@gmail.com" id="tadam...@gmail.com"/>
  <users email="heue...@gmail.com" id="heue...@gmail.com"/>
  <users email="kevinb@google.com" id="kevinb@google.com"/>
  <users email="phwend...@gmail.com" id="phwend...@gmail.com"/>
  <users email="cpov...@google.com" id="cpov...@google.com"/>
  <users email="ogregoire" id="ogregoire"/>
  <users email="consiliu...@gmail.com" id="consiliu...@gmail.com"/>
  <users email="Maaarti...@gmail.com" id="Maaarti...@gmail.com"/>
  <users email="henn...@schmiedehausen.org" id="henn...@schmiedehausen.org"/>
  <users email="mombelli...@gmail.com" id="mombelli...@gmail.com"/>
  <users email="ozzy...@gmail.com" id="ozzy...@gmail.com"/>
  <users email="lowas...@google.com" id="lowas...@google.com"/>
  <users email="cristian...@gmail.com" id="cristian...@gmail.com"/>
  <users email="SeanPFl...@googlemail.com" id="SeanPFl...@googlemail.com"/>
  <users email="hillge...@gmail.com" id="hillge...@gmail.com"/>
  <users email="cairomas...@gmail.com" id="cairomas...@gmail.com"/>
  <users email="jbj...@gmail.com" id="jbj...@gmail.com"/>
  <users email="----" id="----"/>
  <users email="kak@google.com" id="kak@google.com"/>
  <users email="NatalyaD...@gmail.com" id="NatalyaD...@gmail.com"/>
  <users email="leventov...@gmail.com" id="leventov...@gmail.com"/>
</gc:GoogleCodeProject>
